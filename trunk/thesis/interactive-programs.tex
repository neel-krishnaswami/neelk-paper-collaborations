\chapter{Verifying Interactive Programs}

\section{Introduction}

In many interactive programs, there are mutable data structures which
change over time, and which must maintain some relationships with one
another. For example, in a web browser, we need to present a web page
both as a tree data structure for scripts to manipulate, and display a
graphical image for the human user to view. Any change made to the
tree by a script must be reflected in a change to the image that the
human sees --- the two structures must remain synchronized.

Likewise, in a spreadsheet, each cell contains a formula, which may
refer to other cells, and whenever the user changes a cell, all of the
cells which transitively depend upon it must be updated. Since
spreadsheets can get very large, this should ideally be done in a lazy
way, so that only the cells visible on the screen, and the cells
necessary to compute them, are themselves recomputed.

Typically, these dependencies are written using what is called the
\emph{subject-observer} pattern. A mutable data structure (the
subject) maintains a list of all of the data structures whose
invariants depend upon it (the observers), and whenever it changes, it
calls a function on each of those observers to update them in response
to the change. (And in turn, the observers of the subject may be
subjects of still other observers, ultimately forming DAGs of
notifications.)

While natural, these programs are very challenging to verify in a
modular way. The reason is that there are two directions of
dependency, both of which matter for program proof. First, our program
invariant must have ownership over the subject's data (its
\emph{footprint}) in order to prove the correctness of code modifying
the subject. This direction of ownership is natural to verify with
separation logic.

In addition, these programs must also explicitly maintain the
\emph{other} direction of dependency as well --- we track everything
which depends upon the subject, and modify them appropriately whenever
the subject changes.  The natural program invariant now becomes a
global property: we need to know the full dependency graph covering
all subjects and observers, so that we can say that the reads and
is-read-by relations are relational transposes of one another. The
global nature of this invariant means that a naive correctness proof
will not respect the modular structure of the program --- if we modify
the dependency graph in any way, we now have to re-verify the entire
program!

However, the intention of the subject-observer pattern is precisely to
allow the program to remain oblivious to the exact number and nature
of the observers, which allows the programmer to add new observers
without disturbing the behavior of the rest of the program.  Our goal,
then, is to find a way of taking this piece of practical software
engineering wisdom, and casting it into formal terms amenable to
proof.

Concretely, this chapter's contributions are as follows: 

\begin{itemize}
  \item I define a library with a monadic API for writing
    demand-driven computations with dynamic dependencies and local
    state, and which is implemented as higher-order functions
    dynamically creating networks of imperative callbacks.

    I give an ``abstract semantics'' for this library, structured as a
    set of separation logic lemmas about our dataflow library. These
    lemmas permit \emph{modular} correctness proofs about programs
    using this API, even in the face of the fact that the program
    invariants must be defined globally upon the whole callback
    network.

    The key idea is to distinguish between the direct footprint of a
    command, and the program state which can depends upon that
    footprint. The lemmas are then phrased so that they refer only to
    the direct footprint of each command in the API. In addition, we
    structure our lemmas to justify a ramified frame property for our
    abstract semantics, which we can use to verify different parts of
    an imperative dataflow network separately.

    To do this, I follow the recipe laid out in the previous chapter,
    only now in a more complicated setting. I introduce a
    domain-specific separation logic of dataflow cells, and show how
    to specify cells in such a way that they only mention their
    footprint, and use a ramification operator to specify their effect
    on the rest of the heap. In addition to the ramification operator
    itself, we also need to specify several predicates and operators
    to let us reason about the state of the dataflow heap.

  \item To show that this is actually a good technique for specifying
    libraries, I use this specification to verify an imperative
    implementation of combinators implementing stream transducers in
    the style of functional reactive programming. This proof does not
    need to know about the implementation of the dataflow library; it
    works entirely in terms of the specification of dataflow cells.

    Ultimately, clients can reason about the behavior of the
    imperative implementation ``as if'' it were purely functional,
    even though it is implemented using local state and imperative
    callback procedures.
\end{itemize}

\section{Demand-Driven Notification Networks}

A simple intuition for a ``demand-driven notification network'' is to
think of it as a generalized spreadsheet. We have a collection of
cells, each of which contain program expressions whose evaluation may
refer to other cells. When a cell is read, the expression within the
cell is evaluated, possibly triggering the evaluation of other cells
in a cascade. Furthermore, each cell memoizes its expression, so that
repeated reads will not trigger re-evaluation. Each cell also maintains a
set of dependencies, so that if its code is changed, it and its
transitively reachable dependencies all invalidate their memoized
values.

\subsection{Implementing Notification Networks}

\begin{figure}
\mbox{}
\begin{specification}
\nextline $\codetype{\alpha} = \monad{(\alpha \times \cellset)}$ \nextline[1em]
$\celltype{\alpha} = \{$\=$code: \reftype{(\codetype{\alpha})};$ \nextline
                   \>$value: \reftype{(\opttype{\;\alpha})};$ \nextline
                   \>$reads: \reftype{\cellset};$ \nextline
                   \>$obs:   \reftype{\cellset};$ \nextline
                   \>$id:    \N\}$ \nextline[1em]

$\ecell = \exists \alpha:\star.\; \celltype{\alpha}$ \nextline[1em]

$\ctext{return} : \forall \alpha:\star.\; \alpha \to \codetype{\alpha}$ \nextline
$\ctext{return}\;x = \comp{\pair{x}{\ctext{emptyset}}}$ \nextline[1em]

$\ctext{bind} : \forall \alpha,\beta:\star.\; \codetype{\alpha} \to (\alpha \to \codetype{\beta}) \to \codetype{\beta}$ \nextline
$\ctext{bind}\;\cmd\;f = [$\=$\letv{(v,r_1)}{\cmd}{}$ \nextline
                        \>$\letv{(v',r_2)}{f\;v}{}$ \nextline
                        \>$\;\pair{v'}{\ctext{union}\;r_1\;r_2}]$\nextline[1em]

$\ctext{read} : \forall \alpha:\star.\; \celltype{\alpha} \to \codetype{\alpha}$ \nextline
$\ctext{read}\;a = [$\=$\letv{o}{\comp{!a.value}}{}$ \nextline
                     \>$\ctext{run}\;\ctext{case}(o,$ \nextline
                     \>\qquad\= $\ctext{Some}\;v \to \comp{\pair{v}{\ctext{singleton}\;(\pack{\alpha}{a})}},$ \nextline
                     \>      \> $\ctext{None} \to [$\=$\letv{\cmd}{\comp{!a.code}}{}$ \nextline
                     \>      \>                     \>$\letv{(v,r)}{\cmd}{}$ \nextline
                     \>      \>                     \>$\letv{\_}{\comp{a.value := \Some(v)}}{}$\nextline
                     \>      \>                     \>$\letv{\_}{\comp{a.reads := r}}{}$ \nextline
                     \>      \>                     \>$\letv{\_}{\ctext{iterset}\;(\ctext{add\_observer}\;(\pack{\alpha}{a}))\;r}{}$ \nextline
                     \>      \>                     \>$\;\pair{v}{\ctext{singleton}\;(\pack{\alpha}{a})}])]$ \nextline[1em]

$\getref : \forall \alpha : \reftype{\alpha} \to \codetype{\alpha}$ \nextline
$\getref r = \comp{\letv{v}{\comp{!r}}{\pair{v}{\ctext{emptyset}}}}$ \nextline[1em]

$\setref : \forall \alpha : \reftype{\alpha} \to \alpha \to \codetype{\unittype}$ \nextline
$\setref r\;v = \comp{\letv{\_}{\comp{r := v}}{\pair{\unit}{\ctext{emptyset}}}}$ \nextline[1em]

$\newcell : \forall \alpha:\star.\; \codetype{\alpha} \to \monad{\celltype{\alpha}}$ \nextline
$\newcell\;\cmd = [$\=$\letv{id}{[!counter]}{}$ \nextline
                    \>$\letv{\_}{\comp{counter := id + 1}}{}$ \nextline
                    \>$\letv{code}{\newref{\codetype{\alpha}}{\cmd}}{}$ \nextline
                    \>$\letv{value}{\newref{\opttype{\;\alpha}}{\ctext{None}}}{}$ \nextline
                    \>$\letv{reads}{\newref{\cellset}{\ctext{emptyset}}}{}$ \nextline
                    \>$\letv{obs}{\newref{\cellset}{\ctext{emptyset}}}{}$ \nextline
                    \>$\; (code, value, reads, obs, id)]$ 
\end{specification}
\caption{Implementation of Notification Networks}
\label{notification-implementation}
\end{figure}

\begin{figure}
\mbox{}
\begin{specification}
\nextline
$\updatecell : \forall \alpha:\star.\; \celltype{\alpha} \to \codetype{\alpha} \to \monad{\unittype}$\nextline
$\updatecell\;\alpha\;\mathit{cell}\;\cmd = 
     [$\=$\letv{\_}{\ctext{mark\_unready}\;\pack{\alpha}{\mathit{cell}}}{}$ \nextline
       \>$\mathit{cell}.code := \cmd]$ \nextline[1em]

$\ctext{mark\_unready} : \ecell \to \monad{\unittype}$ \nextline
$\ctext{mark\_unready}\;cell =\; $\=$\ctext{unpack}(\alpha, a) = cell\; \ctext{in}$\nextline
\>  $[$\=$\letv{os}{\comp{!a.obs}}{}$ \nextline
\>     \>$\letv{rs}{\comp{!a.reads}}{}$ \nextline
\>     \>$\letv{\_}{\ctext{iterset}\;\ctext{mark\_unready}\;os}{}$ \nextline
\>     \>$\letv{\_}{\ctext{iterset}\;(\ctext{remove\_obs}\;cell)\;rs}{}$ \nextline
\>     \>$\letv{\_}{\comp{a.value := \ctext{None}}}{}$ \nextline
\>     \>$\letv{\_}{\comp{a.reads := \ctext{emptyset}}}{}$ \nextline
\>     \>$a.obs   := \ctext{emptyset}]$ 
\nextline[1em]
$\ctext{add\_observer} : \ecell \to \ecell \to \monad{1}$ \nextline
$\ctext{add\_observer} \;o \;(\pack{\beta}{c}) = [$\=$\letv{os}{[!(c.\mathit{obs})]}{}$ \nextline
                                                  \>$\letv{os}{[\ctext{addset}\;os\;o]}{}$ \nextline
                                                  \>$c.\mathit{obs} := os]$
\nextline[1em]
$\ctext{remove\_obs} : \ecell \to \ecell \to \monad{1}$ \nextline
$\ctext{remove\_obs} \;o \;(\pack{\beta}{c}) = [$\=$\letv{os}{[!(c.\mathit{obs})]}{}$ \nextline
                                             \>$\letv{os}{[\ctext{removeset}\;os\;o]}{}$ \nextline
                                             \>$c.\mathit{obs} := os]$

\end{specification}
\caption{Implementation of Notification Networks}
\label{notification-implementation-update}
\end{figure}

Our API for creating notification networks is given in
Figure~\ref{notification-implementation} and
Figure~\ref{notification-implementation-update}. First, we will describe
the interface, and then discuss its implementation.

The interface exposes two basic abstract data type constructors, $\ctext{cell}$
and $\ctext{code}$.

The type $\celltype{\alpha}$ is the type of dynamic data values. A
cell contains a reference to a piece of code, a possible memoized
value, and enough information to correctly invalidate its memoized
value when the cell's dependencies change. We can create a new cell by
calling $\newcell \cmd$, which returns a brand new cell with the code
expression $\cmd$ inside it. We can also modify a cell with the
command $\updatecell\;cell\;\cmd$, which modifies the cell $cell$ by
installing the new expression $\cmd$ in it.

The type $\codetype{\alpha}$ is a monadic type, representing the type of
computations that can read cells. It supports the usual operations
$\return e$ and $\bind \cmd\; (\semfun{x}{e'})$, which embed a pure value
into the $\ctext{code}$ type and implement sequential composition,
respectively. In addition, the primitive operations on this monad
include reading a cell with the $\readcell cell$ function call, and
reading and modifying local state with the $\getref r$ and $\setref
r\;v$ operations.

The difference between $\readcell$ and $\getref$ or $\setref$ is that
the first operation reads a cell, possibly further executing the code
in that cell. In contrast, $\getref$ and $\setref$ are just the
operations to update primitive pointers, lifted to live within the
$\codetype{\alpha}$ monad.
 
The actual implementation is also given in
Figures~\ref{notification-implementation} and~\ref{notification-implementation-update}. 
The abstract type of code is
implemented using the underlying monad of imperative commands, so that
$\codetype{\alpha}$ is implemented with the type $\monad{(\alpha
  \times \cellset)}$.  The intuition is that when we evaluate a term
we are allowed to read some cells along the way, and so must return a
set of all the cells that we read in order to do proper dependency
management. So, $\cellset$ is a type representing sets of
(existentially-quantified) cells.  (The precise specification of
$\cellset$ is given in Appendix A, since describing it is a
distraction from the main development.)

Cells are represented with a 5-tuple. For readability, we use a
record-style notation for them, even though our formal language has
only binary tuples, since records can be translated into nested
tuples.

There is a reference pointing to the code expression, as well as a
value field pointing to an optional value. The value field will be set
to $\ctext{None}$ if the cell is in an unready, un-memoized state, and
will be $\ctext{Some}\;v$ if the cell's code has already been
evaluated to a value $v$. In addition there are two fields
representing the dependencies. If the code expression has been
evaluated and a memoized value generated, then the $reads$ field will
point to the set of cells that the computation directly read while
computing its value. Otherwise it will point to the empty
set. Conversely, the field $obs$ contains the cell's observers --- the
set of cells that have read the current cell as part of their own
computations. Obviously, this is only non-empty when the cell has been
evaluated. Finally, each cell also has an integer id field, which is a
unique numeric identifier for every cell that is created by the
library. This permits us to compare cells (even of different type) for
equality, which is needed for dependency management.

The $\return$ operation for the library simply returns its argument
value and the empty set, since it does not read any cells. Likewise,
$\bind \cmd\;f$ will evaluate the first argument and pass the returned
value to the function $f$. It will return the function's return value,
together with the union of the two read sets. $\getref r$ and $\setref
r\;v$ simply read and update the reference, and return empty read
sets, since neither of them read any cells. The only reason we need 
these operations in our interface is for typing reasons; we are defining
a user-defined monad, and $\getref$ and $\setref$ lift the read and
write operations of the underlying language into this monad, adding 
the extra plumbing associated with it.

Interesting things first happen with the $\readcell e$ operation. This
function will first check to see if the cell has a memoized value
ready. If it does, we return that immediately. Otherwise, we evaluate
the cell's code, and update the current cell's value and read set. In
addition, each cell that was read in the evaluation of the code (i.e.,
the set returned as the second component of the monadic type's return
value) also has its observer set updated with the newly-ready current
cell. Now, if any of the dependencies change, they will be able to
invalidate the current cell, which observes them. Note that the
dependencies between cells are all dynamic --- we cannot examine the
inside of a code expression to find its ``free cells'', and so we rely
upon the invariant that a code expression will return every cell it
read, in addition to its return value.

Further interesting things happen with the $\newcell\;\cmd$ operation.
It creates a new cell value, setting the code field with the argument
$\cmd$, and generating an id by dereferencing and incrementing the
contents of the variable $counter$. The $counter$ variable, of type
$\reftype{\N}$, occurs freely in this definition, because it denotes a
piece of state global to the module, which must be initialized by
whatever initialization routine first constructs the whole module as
an existential package.  Since $counter$ is otherwise private, we can
generate unique identifiers by incrementing it as we create new cells.

Finally, the $\updatecell\;cell\;\cmd$ operation updates a cell
$cell$ with a new code expression $\cmd$. (As an aside, it's worth
noting that this is a genuine, unavoidable, use of higher-order store:
we make use of pointers to code, including the ability to dynamically
modify them.) Once we modify a cell, any memoized value it has is no
longer necessarily correct.

Therefore, we have to forget the memoized value of the cell, as well
as the memoized values of any cell which transitively observes the
cell. This is what the $\ctext{mark\_unready}$ function does. Given a
current cell, it takes each observer of the current cell and
recursively marks it unready. Then it removes the current cell from
the observer sets of each cell the current cell reads, and nulls out
the current cell's memoized value, as well as setting he current
cell's read and observer sets to empty. Notice there is no explicit
base case in the recursive definition; if there are any cycles in the
dependency graph, invalidation could go into an infinite loop.

So far, we have described the implementation invariants incrementally
and informally. Before proceeding to the formal description, we will
state them again informally, all in one place:

\begin{itemize}
  \item Every cell must have a unique numeric identifier.
  \item Every cell is either ready, or unready. 
  \item Every ready cell has a memoized value, and maintains 
    two sets, one containing every cell that it reads, and the
    other containing every cell it is observed by. 
  \item Every unready cell has no memoized value, and has 
    both an empty read set and an empty observer set. 
  \item The overall dependency graph among the valid cells must form a
    directed acyclic graph. 
  \item The reads and the observers must be the same, only 
    pointing in opposite directions.
\end{itemize}

Formalizing these constraints is relatively straightforward, but we
have the problem that these constraints are global in nature:
we cannot be sure that the dependency graph is acyclic without having
it all available to examine, and likewise we cannot in general know
that a cell is in the read set of everything in its observed set
without knowing the whole graph. Handling this difficultly is one of
the primary contributions of this work. 

\section{The Abstract Semantics of Notifications}

\subsection{The Structure of the Global Invariant}

The key to getting around our difficulties lies in the difference
between the implementation of $\updatecell$, and of $\ctext{read}$.
$\updatecell$ calls $\ctext{mark\_unready}$, which recursively follows
the observers. The $\ctext{read}$ function, on the other hand,
proceeds in the opposite direction --- it evaluates code expressions,
recursively descending into the footprint of its command. The opposite
direction these two functions look is why we end up needing a global
invariant: we need to know that these two directions are in harmony
with one another.

Now, note that the type of calls to $\ctext{update}$ is simply the
monadic type $\monad{\unittype}$, which precludes clients from
constructing expressions of type $\codetype{\alpha}$ which invoke
it. The reason for this is that the $\codetype{\alpha}$ is an abstract
type, and clients can construct terms of this type only by using the
$\ctext{return}, \ctext{bind}, \ctext{read}, \ctext{getref}$ and
$\ctext{setref}$ operations. Since none of these operations themselves
invoke $\ctext{update}$, no client code can place a code expression in a
cell which can invoke it. (Making this argument completely airtight
would require a parametric model of our language, which we do not
have, but the intuition is sufficient to guide the design of the
program invariant.)

As a result, when we evaluate a code expression, we will never
actually follow the observer fields -- we only patch them as
needed, whenever we evaluate a cell and change it from unready to
ready.  As a result, an abstract description of the heap which
\emph{does not explicitly mention the observer sets} will prove
sufficient for reasoning about the behavior of $\codetype{\alpha}$
expressions.

With this plan, we introduce \emph{abstract heap formulas}, which are
syntactic descriptions of the state of part of the cell heap. These
syntactic expressions are given by the following grammar:
\begin{displaymath}
  \begin{array}{lcl}
    \phi & ::= & I \bnfalt \phi \otimes \psi \bnfalt \cellpos{a}{\cmd}{v}{r} \bnfalt \cellneg{a}{\cmd}\\
         &  |  & \localref{r}{v} 
  \end{array}
\end{displaymath}

Informally, a formula $I$ represents an empty abstract heap, and a
formula $\phi \otimes \psi$ represents an abstract heap that can be
broken into two disjoint parts $\phi$ and $\psi$. We will only
consider formulas modulo the associativity and commutativity of
$\otimes$, and take $I$ to be the unit of this binary operator.

The atomic form $\localref{r}{v}$ says that $r$ is a piece of local
state owned by the network, currently with value $v$. There are two
atomic forms representing cells. $\cellneg{a}{\cmd}$ says that $a$ is
a cell with code $\cmd$ that is unready to deliver a value --- it
needs to be re-evaluated before it can yield a
value. $\cellpos{a}{\cmd}{v}{r}$ says that $a$ is a cell with code
$\cmd$ that will deliver the value $v$, under the condition that all
the cells in its read set $r$ are themselves ready. However, if
anything in $r$ is unready (i.e., anything it reads is unready), then
$a$ itself is unready. (We will sometimes write $\celleither{a}{\cmd}$
when we do not care whether $a$ is ready or not.)

First, notice the must/may flavor of this reading. The formula
$\cellneg{a}{\cmd}$ says that $a$ \emph{must} be unready.  The formula
$\cellpos{a}{\cmd}{v}{r}$ says that $a$ \emph{may} be ready,
conditional on the readiness of the elements of its read set
$r$. Second, notice that the backwards dependencies are entirely
missing from these formulas. We have simply left out the other half of
the dependency graph from this description. Forgetting this
information will be critical for local reasoning.

We have emphasized that the straightforward invariant is not obviously
modular. Before we can elaborate any further on this point, we will
need to look at the formal statement of the heap invariant. We
introduce the predicate $G(\phi)$, which describes the entire heap of
cells allocated by our library, and which satisfy both the conditions
described in the previous section, and the additional constraint that
the cell heap agree with $\phi$.\footnote{This is why we insisted that
  the abstract heap formulas are syntactic objects --- this permits us
  to define predicates on them by induction over the structure of the
formula.}


\begin{tabbing}
    $G(\phi) \triangleq \exists H \in CellHeap.\; Inv(H, \phi)$ \\ [1em]

$Inv(H, \phi) \triangleq $ \\
\;\;\= $$\=$ R_H^\dagger = O_H \land R_H^+ \mbox{ strict partial order }$ \\
    \> \> $\land\; R_H \subseteq V_H \times V_H \land unique(H)$ \\
    \> \> $\land\; \satisfies{H}{\phi} \land heap(H) * \mathit{refs}(\phi)$ \\
\end{tabbing}

The auxiliary definitions we used in this definition are all given in
Figure~\ref{heap-invariant}. 

We first assert the existence of a cell heap $H = (D,h)$, which is a
collection of cells $D$, together with a function $h$ mapping each
cell to a code expression, a possible value, a read set, an observed
set, and an integer identifier, which satisfies the overall invariant
$Inv(H, \phi)$.



In the first two lines of $Inv(H, \phi)$, we assert all of the global 
conditions in terms of the mathematical cell heap $H$. First, we assert that 
the relational transpose $(\cdot)^\dagger$ of the reads relation $R_H$ is the
observes relation $O_H$, which enforces the condition that the reads
and observe relations be the same, only pointing in opposite
directions (i.e., if $a$ reads $b$, then $b$ is observed by
$a$). Then, we require that the transitive (but not reflexive) closure
of the reads relation, $R^+_H$ form a strict partial order. Strictness
enforces the condition that there be no cycles in the dependence graph
(because otherwise there would be elements $a$, such that $(a, a) \in
R^+_H$).  Next, we require that the reads relation $R_H$ is a subset of
the Cartesian product $V_H \times V_H$ of the set of cells with values
$V_H$. This ensures that a) there are no dependencies on unready
cells, and b) all unready cells have empty read and observe
sets. Finally, we ask that all of the cells in $H$ have unique
identifiers --- $unique(H)$ asserts that the identifier field is one
half of an isomorphism between the cells in $H$, and the natural
numbers from 0 to the size of $H$.

In the third line, we begin by requiring that the cell heap $H$ satisfy
the abstract heap formula $\phi$, which formalizes the informal
reading of the abstract heap formulas given earlier. This satisfaction
relation follows the general style of separation logic quite closely; 
in a sense, our abstract heap formulas are giving a domain-specific
version of separation logic.

The last clause $heap(H)$ finally connects the cell heap, which is a
purely mathematical object, to the actual low-level heap the
implementation uses. We ask that the global counter reference
$counter$ point to an integer field equal to the size of the cell
heap, and then use the iterated separating conjunction $\forall^*$ to
require that for each cell in the cell heap, we have pointers to the
appropriate code, value, read and observer fields. The read and
observer fields point to values of type $\cellset$, each of which
represent the appropriate sets of cells.  Since none of the prior
clauses say anything about the local state, we also use the
$\mathit{refs}(\phi)$ function to take a formula, and assemble a
collection of points-to assertions $r \pointsto v$ from each
$\localref{r}{v}$ in our formula. 

As a reminder, the specifications of the set operations are given in
Appendix A of this chapter. An unusual feature of this specification
is that we have a three-place predicate $\mathit{set}(W, v, xs)$,
which says that $v$ is a value representing a set of $\mathit{ecell}$s
$xs$.

Naively, we would expect there to be only a two-place
relation$\mathit{set}(v, xs)$, but unfortuantely that does not work.
The reason is that since we cannot directly compare cells of different
type for equality, we include a unique integer id field in each
cell. These integer identity fields are dynamically generated as the
program executes, and the $W$ parameter tracks the association between
the id fields and the natural equality of the $\mathit{ecell}$ type.

Note that the separation requirements in $\mathit{heap}(H)$ ensure
that every cell value $c$ in set of cells $D$ has a disjoint set of
pointer values. As a result, we do not have to specify this condition
explicitly, since its failure would falsify the precondition.

\begin{figure}
\mbox{}
\begin{tabbing}
$CellHeap = \Sigma$\=$ D \in \powersetfin{\ecell}.$ \\
               \>$(\Pi (\pack{\alpha}{\_}) \in D. ($\=${\codetype{\alpha}} \;\times$
                                         ${\opttype{\;\alpha}} \;\times$ 
                                         ${\powersetfin{\ecell}} \;\times$ 
                                         ${\powersetfin{\ecell}} \;\times$ 
                                         $\N)$ \\[1em]
       

$code = \pi_1$ \\
$value = \pi_2$ \\
$reads = \pi_3$ \\
$obs = \pi_4$ \\
$id = \pi_5$ \\[1em]

$V_{(D, h)} = \comprehend{c \in D}{\exists v.\; value(h(c)) = \ctext{Some}(v)}$ \\
$R_{(D, h)} = \comprehend{(c,c') \in D \times D}{ c' \in reads(h(c)) }$ \\
$O_{(D, h)} = \comprehend{(c,c') \in D \times D}{ c' \in obs(h(c)) }$ \\[1em]

$\mathit{Fin}(n) = \comprehend{ i \in \N }{ i < n }$ \\[1em]

$unique(D,h) = \exists$\=$i : Fin(|D|) \to D.\; i \circ (id \circ h) = I_D \; \land (id \circ h) \circ i = I_{|D|}$  \\
where $I_X : X \to X = \fun{x}{x}$ \\[1em]

$\satisfies{(D,h)}{\phi} = (D,h), D \models \phi$ \\[1em]

$\models \;\subseteq\; \comprehend{((D,h), D') \in CellHeap \times \powersetfin{\ecell}}{D' \subseteq D}$ \\[0.5em]

$(D,h), D' \models \localref{r}{v} \qquad \qquad$\=$\iff \top$ \\
$(D,h), D' \models I$                            \>$\iff \top$ \\
$(D,h), D' \models \phi \otimes \psi$            \>$\iff \exists D_1, D_2.\;$\=$D' = D_1 \uplus D_2 
                                                      \land (D,h), D_1 \models \phi
                                                      \land (D,h), D_2 \models \psi$ \\
$(D,h), D' \models \cellneg{a}{\cmd}$               \>$\iff a \in D' \land code(h(a)) = \cmd \land a \not \in V_{(D,h)}$ \\
$(D,h), D' \models \cellpos{a}{\cmd}{v}{r}$         \>$\iff $\=$ a \in D' \land code(h(a)) = \cmd \;\land$ \\
\>      \>$\mathrm{if}\;r \subseteq V_{(D,h)}$ \\
\>      \>$\mathrm{then}\;value(h(a)) = \ctext{Some}\;v \land reads(h(a)) = r$ \\
\>      \>$\mathrm{else}\;a \not\in V_{(D,h)}$\\[1em]
 

$heap(D,h) = $ \\
\;\;$counter \pointsto |D| \;* $ \\
\;\;$\forall^* (\pack{\tau}{c}\mbox{ as }cell) \in D.\;$\=$\exists v_r, v_o : \cellset.\;$ \\
                         \>$c.code \pointsto code(h(cell))   \;* $ \\
                         \>$c.value \pointsto value(h(cell)) \;* $ \\
                         \>$c.reads \pointsto v_r \;* $ \\
                         \>$c.obs   \pointsto v_o \;* $ \\
                         \>$c.id    = id(h(cell)) \;\land$ \\
                         \>$set(D, v_r, reads(h(cell))) \;\land$ \\
                         \>$set(D, v_o, obs(h(cell)))$ \\[1em]

$\mathit{refs}(I) \qquad\qquad\qquad\qquad$\=$= \emp$ \\
$\mathit{refs}(\phi \otimes \psi) $\>$= \mathit{refs}(\phi) * \mathit{refs}(\psi)$ \\
$\mathit{refs}(\cellneg{c}{\cmd}) $\>$= \emp$ \\
$\mathit{refs}(\cellpos{c}{\cmd}{v}{r}) $\>$= \emp$ \\
$\mathit{refs}(\localref{r}{v}) $\>$= r \pointsto v$ \\
\end{tabbing}

\caption{Definitions for Heap Invariant}
\label{heap-invariant}
\end{figure}

The global character of this invariant should be evident; we need to
talk about \emph{all} of the cells in the heap in order to state our
invariants. So it is not immediately clear that we have made much
progress towards a modular proof technique. However, we are actually
very close: with just two more ideas, we will be able to give a
solution to this problem.

\subsection{Frame Properties via Polymorphism}

As we mentioned earlier, our abstract heap formulas essentially give
us a small domain-specific separation logic. This means that in order
to reason locally over cell heaps, we need to find an
application-specific version of the frame rule for our library. 

To do this, we will adapt some ideas proposed by
Benton~\cite{benton}, and Birkedal and Yang~\cite{birkedal-yang}. They
suggested interpreting the frame rule of separation logic as a form of
quantification --- instead of having a separate frame rule that allows
adding a frame to any triple, they proposed that all of the atomic
rules of the program logic be replaced with rules possessing an extra
quantifier ranging over ``the rest of the heap'':

\begin{mathpar}
  \inferrule*[right=Example]
          { }
          { \forall R.\; \setof{ (e \pointsto v) * R } \;e := v'\; \setof{ (e \pointsto v') * R}}
\end{mathpar}

This quantifier is propagated through the proof, and any use of the
frame rule can be interpreted as instantiating the universal
quantifier appropriately. The reason this idea is fruitful for us is
that it will allow us to give a frame rule, even though the underlying
semantics of our library does not actually satisfy any analogues of
the traditional safety monotonicity and frame lemmas. For example, the
$\updatecell$ operation certainly does not act locally --- it
recursively traverses the observers set, possibly mutating a very
large part of the cell graph.

\subsection{Correctness of $\newcell$ and $\updatecell$}

In this subsection, I will prove the correctness of the two operations
in our interface which lie outside the $\codetype{\alpha}$
monad. Specifications and proofs of the operations in the monad will
follow, afterwards.

\subsubsection{Correctness of $\updatecell$}

We will now prove the soundness of the following triple specifying
$\updatecell$.

\begin{prop}{(Update Rule)}
For all cells $o$ and code expressions $\cmd$ and $\cmd'$, the following
triple is provable: 

\begin{tabbing}
$\forall \psi:\formula.\; $\=$\setof{G(\celleither{o}{\cmd'} \otimes \psi)}$ \\
                           \>$\run {\updatecell\;o\;\cmd}$ \\
                           \>$\setof{a:1.\; G(\cellneg{o}{\cmd} \otimes \psi)}$
\end{tabbing}
\end{prop}

\textbf{Proof Strategy.} The key to this proof is the conditional
interpretation of the $\cellpos{c}{\cmd}{v}{r}$ formula. When we execute
the $\updatecell$ command, we recursively find every cell which
depends on $o$, and modify it to be unready.

Now consider any positive cell formula in $\psi$ which reads $o$,
directly or indirectly. The satisfaction relation for $\phi$ tells us
that a positive formula must have everything in its read set be ready,
in order to represent a ready cell. So by changing $o$'s formula to
the unready state, we no longer require that positive formula
represent a ready cell. As a result, we can leave the entire frame
$\psi$ untouched, even though the physical heap it represents may have
been (quite drastically) modified.

However, before we can give a proper proof of this theorem, we need to
specify and prove correct the $\ctext{mark\_unready(c)}$ procedure,
which does the bulk of the work of the update function. The purpose of
this function is to set every cell transitively reachable from $c$ to
the unready state.

As with the proofs in the previous chapter, these follow the pattern 
of a lemma about partial orders, a lemma connecting it to the satisfaction
relation, and finally a correctness proof of the procedure. 

First, we will prove the fact that the order in which we delete
reachable subtrees does not matter. This is necessary since the 
algorithm will sequentially delete reachable sub-DAGs, and we
need to know that the effect of sequential deletion is equivalent
to a parallel one.  

\begin{lemma}{(Reachability in Deleted Graphs)}
Suppose we have $H = (D,h)$ such that $R^+_H$ is a strict partial
order, $R_H \subseteq V_H \times V_H$, $R^\dagger_H = O_H$, and
$\mathit{unique}(H)$.  Now, for any $X \subseteq D$, define $U^H_X =
\comprehend{d \in D}{(d, c) \in R^*_H \land c \in X}$ to be the set
of cells which transitively read any cell in $X$, and also define
$h|_X$ so that:
\begin{itemize}
\item $\mathit{code}(h|_X(c')) = \mathit{code}(h(c'))$
\item $\mathit{value}(h|_X(c')) = \IfThenElse{c' \in U^H_X}{\None}{\mathit{value}(h(c'))}$
\item $\mathit{reads}(h|_X(c')) = \IfThenElse{c' \in U^H_X}{\emptyset}{\mathit{reads}(h(c'))}$
\item $\mathit{obs}(h|_X(c')) = \IfThenElse{c' \in U^H_X}{\emptyset}{\mathit{obs}(h(c')) - U^H_X}$
\item $\mathit{identity}(h|_X(c')) = \mathit{identity}(h(c'))$
\end{itemize}
If $H = (D,h)$, we will write $H|_X$ to mean $(D,h|_X)$. 

It is the case that $(d,c) \in R^*_{H|_X}$ if and only if $(d,c) \in R^*_H \land c \not\in U^H_X \land d \not\in U^H_X$. 
\end{lemma}

\begin{proof}

\begin{tabbedproof}
\oo $\Rightarrow$: \\
\ooo Assume $(d,c) \in R^*_{H|_X}$ \\
\ooo Since $R_{H|_X} \subseteq V_{H|_X} \times V_{H|_X}$, we know $R^\ast_{H|_X} \subseteq V_{H|_X} \times V_{H|_X}$ \\
\ooo So $d \in V_{H|_X}$ and $c \in V_{H|_X}$ \\
\ooo Therefore we have a sequence $(d, \ldots, c)$, with each adjacent pair in $R_{H|_X}$ \\
\ooo Now, we proceed by induction on the number of steps from $d$ to $c$. \\
\ooo Case $n = 0$: \\
\oooo Then $c = d \in V_{H|_X}$.\\
\oooo Since $\mathit{value}(h|_{X}(c)) = \IfThenElse{c \in U^H_X}{\None}{\mathit{value}(h(c))}$, we know $c \not\in U^H_X$ \\
\ooo Case $n = k+1$: \\
\oooo Hence we have a sequence $(d, \ldots, c_k, c)$ with each adjacent pair in $R_{H|_X}$, \\
\oooo such that $(d, c_k) \in R^*_H$ and $d \not \in U^H_X$ and $c_k \not \in U^H_x$ \\ 
\oooo We know $c \in \mathit{reads}(h|_X(c_k)) = \IfThenElse{c_k \in U^H_X}{\emptyset}{\mathit{reads}(h(c_k))}$ \\
\oooo Since $c_k \not \in U^H_X$, we know $c \in \mathit{reads}(h(c_k))$, so $(c_k, c) \in R_H$ \\
\oooo Hence $(d, c) \in R^*_H$ \\
\oooo We know $c \not \in U^H_X$, since if it were then $c_k \in U^H_X$, which is contradictory \\
\oo $\Leftarrow$: \\
\ooo Asssume $(d,c) \in R^*_H \land c \not\in U^H_X \land d \not\in U^H_X$. \\
\ooo So we have a sequence $(d, \ldots, c)$ with each adjacent pair, if any, in $R_H$ \\
\ooo Now, we will show $(d, \ldots, c) \in R^*_X$ by induction on the number of steps from $d$ to $c$ \\
\ooo Case $n = 0$: \\
\oooo So $d = c \in V_{H|_X}$. \\
\oooo Since $d \not\in U^H_X$, we know $d \in V_{H|X}$ \\
\oooo Hence $(d,c) \in R^*_{H|_X}$ \\
\ooo Case $n = k+1$: \\
\oooo We have $(d, \ldots, c_k, c)$ such that $(d,c_k) \in R^*_H \land (c_k,c) \in R_H \land c \not\in U^H_X \land d \not\in U^H_X$. \\
\oooo If $c_k \in U^H_X$ then $d \in U^H_X$, which is a contradiction, and so $c_k \not\in U^H_X$ \\
\oooo By induction, $(d, \ldots, c_k) \in R^*_H$ \\
\oooo Since $(c_k,c) \in R_H$, we know $c \in \mathit{reads}(h(c_k))$ \\ 
\oooo Since $c_k \not\in U^H_X$, it follows $c \in \IfThenElse{c_k \in U^H_X}{\emptyset}{\mathit{reads}(h(c_k))}$ \\
\oooo Hence $c \in \mathit{reads }(h|_X(c_k))$ \\
\oooo Hence $(c_k,c) \in R_{H|_X}$ \\
\oooo Hence by transitivity $(d, c) \in R^*_{H|_X}$ \\ 
% \ooo For every $(c_k, c_{k+1}) \in (d, \ldots, c)$, we know $c_{k+1} \in \mathit{reads}(h(c_k))$ \\
% \ooo So we know $c_{k+1} \in \IfThenElse{c_k \in U^H_X}{\emptyset}{\mathit{reads}(h(c_k))}$ \\
% \ooo Hence for every $(c_k, c_{k+1}) \in (d, \ldots, c)$, we know $c_{k+1} \in \mathit{reads}(h|_X(c_k))$ \\
% \ooo Hence $(d,c) \in R^*_{H|_X}$ \\
\end{tabbedproof}
\end{proof}

\begin{lemma}{(Path Union)}
Suppose we have $H = (D,h)$ such that $R^+_H$ is a strict partial
order, $R_H \subseteq V_H \times V_H$, $R^\dagger_H = O_H$, and
$\mathit{unique}(H)$. 

Then $U^{H|_X}_{\setof{z}} \cup H^H_X = U^H_{X \cup \setof{z}}$.

% Then $c \in U^{H|_{X}}_{\setof{z}} \vee
% (c \not\in U^{H|_{X}}_{\setof{z}} \land c \in U^H_{X})$
% is logically equivalent to $c \in U^H_{\setof{z}} \vee c \in U^H_{X}$.
\end{lemma}


\begin{proof}
\begin{tabbedproof}
\oo We want to show for all $c$, that $c \in U^{H|_X}_{\setof{z}} \cup H^H_X$ iff $c \in U^H_{X \cup \setof{z}}$. \\
\oo First, note that the second condition is equivalent to $c \in U^H_X \vee c \in U^H_{\setof{z}}$. \\
\oo Next, note $c \in U^{H|_{X}}_{\setof{z}}$ is equivalent to $(c,z) \in R^*_{H|_{X}}$, \\
\oo which is equivalent to  $(c, z) \in R^*_H \land c \not\in U^H_{X} \land z \not\in U^H_{X}$, \\
\oo which is equivalent to  $c \in U^H_{\setof{z}} \land c \not\in U^H_{X} \land z \not\in U^H_{X}$. \\
% \oo Expanding $c \in U^{H|_X}_{\setof{z}}$ in the formula $c \in U^{H|_{X}}_{\setof{z}} \vee (c \not\in U^{H|_{X}}_{\setof{z}} \land c \in U^H_{X})$, we get \\
% \oox $(c \in U^H_{\setof{z}} \land c \not\in U^H_{X} \land z \not\in U^H_{X}) \;\vee$ \\
% \oox $(\lnot(c \in U^H_{\setof{z}} \land c \not\in U^H_{X} \land z \not\in U^H_{X}) \land c \in U^H_{X})$   \\
% \oo We can simplify the second clause as follows: \\
% \oo $\lnot(c \in U^H_{\setof{z}} \land c \not\in U^H_{X} \land z \not\in U^H_{X}) \land c \in U^H_{X}$   \\
% \ooo $\simeq (c \not\in U^H_{\setof{z}} \vee c \in U^H_X \vee z \in U^H_X) \land c \in U^H_X$ \\
% \ooo $\simeq (c \not\in U^H_{\setof{z}} \land c \in U^H_X) \vee 
%              (z \in U^H_X \land c \in U^H_X) \vee 
%              c \in U^H_X$ \\
% \ooo $\simeq c \in U^H_X$ \\
\oo Hence the whole condition is equivalent to:\\
\oox $(c \in U^H_{\setof{z}} \land c \not\in U^H_{X} \land z \not\in U^H_{X}) \vee c \in U^H_{X}$ if and only if 
    $c \in U^H_{\setof{z}} \vee c \in U^H_{X}$ \\
\oo The forward direction of the equivalence trivial. \\
\oo To prove the backwards direction, assume $c \in U^H_{\setof{z}} \vee c \in U^H_{X}$ \\
\ooo Now case on this assumption \\
\ooo Case $c \in U^H_{X}$: \\
\oooo Then $c \in U^H_{X}$ \\
\ooo Case $c \in U^H_{\setof{z}}$: \\ 
\oooo Consider whether $c \in U^H_{X}$ \\
\oooo Case $c \in U^H_{X}$: \\
\ooooo Then $c \in U^H_{X}$ \\
\oooo Case $c \not\in U^H_{X}$: \\
\ooooo Consider whether $z \in U^H_{X}$ \\
\ooooo Case $z \in U^H_{X}$: \\
\oooooo Since $c \in U^H_{\setof{z}}$, we know $(c, z) \in R^*_H$ \\
\oooooo Since $z \in U^H_{X}$, we know $(z, x) \in R^*_H$ for some $x \in X$ \\
\oooooo By transitivity, $(c, x) \in R^*_H$  \\
\oooooo Hence $c \in U^H_{X}$, which is a contradiction \\
\ooooo Case $z \not\in U^H_{X}$: \\
\oooooo Then $c \in U^H_{\setof{z}} \land c \not\in U^H_{X} \land z \not\in U^H_{X}$ \\
\end{tabbedproof}
\end{proof}

\begin{lemma}{(Sequentialization)}
Suppose we have $H = (D,h)$ such that $R^+_H$ is a strict partial
order, $R_H \subseteq V_H \times V_H$, $R^\dagger_H = O_H$, and
$\mathit{unique}(H)$.

Then $H|_X|_Y = H|_{X \cup Y}$.
\end{lemma}

\begin{proof}
We prove this by induction on the size of $Y$. 
\begin{tabbedproof}
\oo Case $Y = \emptyset$: \\
\ooo Immediate \\
\oo Case $Y = Z \uplus \setof{z}$: \\
\ooo By induction, we know that $H|_X|_Z = H|_{X \cup Z}$ \\
\ooo Consider whether $z \in X \cup Z$ \\
\ooo Case $z \in X \cup Z$: \\
\oooo Now consider whether $z \in V_H$ \\
\oooo If $z \in V_H$:\\
\ooooo Then we know that $z \in U^H_{X \cup Z}$, since $(z, z) \in R^\ast_H$ \\
\ooooo Then $U^{H|_{X \cup Z}}_{\setof{z}} = \emptyset$ \\
\ooooo Therefore $H|_{X \cup Z}|_{\setof{z}} = H|_{X \cup Z} = H|_{X \cup Y}$  \\ 
\oooo If $z \not\in V_H$: \\
\ooooo Then $z \not\in V_{H|_{X \cup Z}}$, and so $U^{H|_{X \cup Z}}_{\setof{z}} = \emptyset$ \\
\ooooo Therefore $H|_{X \cup Z}|_{\setof{z}} = H|_{X \cup Z} = H|_{X \cup Y}$  \\ 
\ooo Case $z \not\in X \cup Z$: \\
\oooo To show that $H|_{X \cup Z}|_{\setof{z}} = H|_{\setof X \cup Z \cup \setof{z}} $, we need to show $h|_{X \cup Z}|_{\setof{z}} = h|_{\setof X \cup Z \cup \setof{z}}$ \\
\oooo 1. Consider $\mathit{reads}(h|_{X \cup Z}|_{\setof{z}}(c))$ \\
\ooooo $\mathit{reads}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^{H|_{X \cup Z}}_{\setof{z}}}{\emptyset}{\mathit{reads}(h|_{X \cup Z}(c))}$ \\
\ooooo $\mathit{reads}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^{H|_{X \cup Z}}_{\setof{z}}}{\emptyset}{\IfThenElse{c \in U^H_{X \cup Z}}{\emptyset}{\mathit{reads}(h(c))}}$ \\
\ooooo $\mathit{reads}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^{H|_{X \cup Z}}_{\setof{z}} \vee c \in U^H_{X \cup Z}}{\emptyset}{\mathit{reads}(h(c))}$ \\
\ooooo By the path union lemma, \\
\ooooox $\mathit{reads}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^H_{X \cup Z \cup \setof{z}}}{\emptyset}{\mathit{reads}(h(c))}$ \\
\ooooo Hence $\mathit{reads}(h|_{X \cup Z}|_{\setof{z}}(c)) = \mathit{reads}(h|_{X \cup Z \cup \setof{z}})$ \\
\oooo 2. Consider $\mathit{value}(h|_{X \cup Z}|_{\setof{z}}(c))$ \\
\ooooo $\mathit{value}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^{H|_{X \cup Z}}_{\setof{z}}}{\None}{\mathit{value}(h|_{X \cup Z}(c))}$ \\
\ooooo $\mathit{value}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^{H|_{X \cup Z}}_{\setof{z}}}{\None}{\IfThenElse{c \in U^H_{X \cup Z}}{\None}{\mathit{value}(h(c))}}$ \\
\ooooo $\mathit{value}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^{H|_{X \cup Z}}_{\setof{z}} \vee c \in U^H_{X \cup Z}}{\None}{\mathit{value}(h(c))}$ \\
\ooooo By the path union lemma, \\
\ooooox $\mathit{value}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^H_{X \cup Z \cup \setof{z}}}{\None}{\mathit{value}(h(c))}$ \\
\ooooo Hence $\mathit{value}(h|_{X \cup Z}|_{\setof{z}}(c)) = \mathit{value}(h|_{X \cup Z \cup \setof{z}})$ \\
\oooo 3. Consider $\mathit{obs}(h|_{X \cup Z}|_{\setof{z}}(c))$ \\
\ooooo $\mathit{obs}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^{H|_{X \cup Z}}_{\setof{z}}}{\emptyset}{\mathit{obs}(h|_{X \cup Z}(c)) - U^{H|_{X \cup Z}}_{\setof{z}}}$ \\
\ooooo $\mathit{obs}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^{H|_{X \cup Z}}_{\setof{z}}}{\emptyset}{\IfThenElse{c \in U^H_{X \cup Z}}{\emptyset}{\mathit{obs}(h|_{X \cup Z}(c)) - U^{H|_{X \cup Z}}_{\setof{z}}}}$ \\
\ooooo $\mathit{obs}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^{H|_{X \cup Z}}_{\setof{z}} \vee c \in U^H_{X \cup Z}}{\emptyset}{\mathit{obs}(h|_{X \cup Z}(c)) - U^{H|_{X \cup Z}}_{\setof{z}}}$ \\
\ooooo By the path union lemma, \\
\ooooox $\mathit{obs}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^H_{X \cup Z \cup \setof{z}}}{\emptyset}{\mathit{obs}(h|_{X \cup Z}(c)) - U^{H|_{X \cup Z}}_{\setof{z}}}$ \\
\ooooo So $\mathit{obs}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^H_{X \cup Z \cup \setof{z}}}{\emptyset}{\mathit{obs}(h(c)) - U^H_{X \cup Z} - U^{H|_{X \cup Z}}_{\setof{z}}}$ \\
\ooooo So $\mathit{obs}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^H_{X \cup Z \cup \setof{z}}}{\emptyset}{\mathit{obs}(h(c)) - (U^H_{X \cup Z} \cup U^{H|_{X \cup Z}}_{\setof{z}})}$ \\
\ooooo By the path union lemma, $U^H_{X \cup Z} \cup U^{H|_{X \cup Z}}_{\setof{z}} = U^H_{X \cup Z \cup \setof{z}}$ \\
\ooooo Hence $\mathit{obs}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^H_{X \cup Z \cup \setof{z}}}{\emptyset}{\mathit{obs}(h(c)) - U^H_{X \cup Z \cup \setof{z}}}$ \\
\ooooo Hence $\mathit{obs}(h|_{X \cup Z}|_{\setof{z}}(c)) = \mathit{obs}(h|_{X \cup Z \cup \setof{z}}(c))$
\end{tabbedproof}
\end{proof}

\begin{lemma}{(Transitive Invalidation Preserves Order Structure)}
Suppose we have $H = (D,h)$ such that 
\begin{enumerate}
\item $R^+_H$ is a strict partial order 
\item $R_H \subseteq V_H \times V_H$
\item $R^\dagger_H = O_H$ 
\item $\mathit{unique}(H)$
\end{enumerate}
\noindent For any cell $c \in D$, it is the case that for $H' = (D, h') = H|_{\setof{c}}$, we have
\begin{enumerate}
\item $R^+_{H'}$ is a strict partial order 
\item $V_{H'} = V_H - U^H_{\setof{c}}$
\item $R_{H'} \subseteq V_{H'} \times V_{H'}$
\item $R^\dagger_{H'} = O_{H'}$ 
\item $\mathit{unique}(H')$
\end{enumerate}
\end{lemma}

\begin{proof}
\begin{enumerate}
\item $R^+_{H'}$ is a strict partial order 
  \begin{tabbedproof}
    \oo This follows if $R^+_{H'}$ is a transitive relation without any $(a,a) \in R^+_H$ \\
    \oo Since it is a transitive closure, it is a transitive relation \\
    \oo To show that there is no $a \in D$ such that $(a,a) \in R^+_{H'}$, \\
    \ox we will show that $R^+_{H'} \subseteq R^+_H$ \\
    \oo Assume that $(a_0,b) \in R^+_{H'}$ \\
    \oo Then there is a sequence $a_0, \ldots, a_k$ such that $b = a_k$ and each $a_{i+1} \in \mathit{reads}(h'(a_i))$ \\
    \oo Suppose we have an $i$ such that $a_{i+1} \in \mathit{reads}(h'(a_i))$ \\
    \oo Hence it follows that $a_i \not\in U^H_{\setof{c}}$, since otherwise $\mathit{reads}(h'(a_i)) = \emptyset$ \\
    \oo Hence it follows that $\mathit{reads}(h'(a_i)) = \mathit{reads}(h(a_i))$ for $i < k$ \\
    \oo Hence $a_0, \ldots, a_k$ such that $b = a_k$ and each $a_{i+1} \in \mathit{reads}(h(a_i))$ \\
    \oo Hence $(a_0, b) \in R^+_H$ \\
    \oo Hence $a_0 \not= b$, since $R^+_H$ strict partial order 
  \end{tabbedproof}

\item $V_{H'} = V_H - U^H_{\setof{c}}$
  \begin{tabbedproof}
    \oo Suppose $a \in V_{H'}$ \\
    \ooo Then $\mathit{value}(h'(a)) = \Some(v)$ for some $v$ \\
    \ooo Hence $a \not\in U^H_{\setof{c}}$ \\
    \ooo Hence $\mathit{value}(h'(a)) = \mathit{value}(h(a))$  \\
    \ooo Hence $a \in V_H$ \\
    \ooo Hence $a \in V_{H} - U^H_{\setof{c}}$ \\
    \oo Conversely, suppose $a \in V_{H} - U^H_{\setof{c}}$ \\
    \ooo Then $\mathit{value}(h(a)) = \Some(v)$ for some $v$ \\
    \ooo But since $a \not\in U^H_{\setof{c}}$, we know $\mathit{value}(h'(a)) = \mathit{value}(h(a)) = \Some(v)$ \\
    \ooo Hence $a \in V_{H'}$ 
  \end{tabbedproof}

\item $R_{H'} \subseteq V_{H'} \times V_{H'}$
  \begin{tabbedproof}
    \oo Assume $(a,b) \in R_{H'}$ \\
    \oo Hence $b \in \mathit{reads}(h'(a))$ \\
    \oo Hence we know that $a \not\in U^H_{\setof{c}}$ \\
    \oo Hence we know that $b \in \mathit{reads}(h(a))$ and $(a,b) \in R_H$\\
    \oo Hence we know that $a \in V_H$ and $b \in V_H$\\
    \oo Hence we know that $a \in V_H - U^H_{\setof{c}}$ \\
    \oo Hence we know that $a \in V_{H'}$ \\
    \oo Since $U^H_{\setof{c}}$ is transitively-closed, we know that if $b \in U^H_{\setof{c}}$, then $a \in U^H_{\setof{c}}$ \\
    \oo Since $a \not\in U^H_{\setof{c}}$, we know that $b \not\in U^H_{\setof{c}}$ \\
    \oo Hence we know that $b \in V_H - U^H_{\setof{c}}$ \\
    \oo Hence we know that $b \in V_{H'}$ 
  \end{tabbedproof}

\item $R^\dagger_{H'} = O_{H'}$ 
  \begin{tabbedproof}
    \oo Suppose that $(a, b) \in R^\dagger_{H'}$. \\
    \ooo We want to show that $(a, b) \in O_{H'}$ \\
    \ooo We know that $(b, a) \in R_{H'}$ \\
    \ooo We know that $a \in \mathit{reads}(h'(b))$ \\
    \ooo Since $R_{H'} \subseteq V_{H'} \times V_{H'}$, we know $a \not\in U^H_{\setof{c}}$ and $b \not \in U^H_{\setof{c}}$ \\
    \ooo Hence $a \in \mathit{reads}(h(b))$ \\ 
    \ooo Hence $b \in \mathit{obs}(h(a))$ \\
    \ooo Hence $b \in \mathit{obs}(h'(a))$ \\
    \ooo Hence $(a,b) \in O_{H'}$ \\
    \oo Suppose that $(a, b) \in O_{H'}$. \\
    \ooo We want to show that $(a,b) \in R^\dagger_{H'}$, so we want $(b,a) \in R_{H'}$ \\
    \ooo Since $(a,b) \in O_{H'}$, we know $b \in \mathit{obs}(h'(a))$ \\
    \ooo Hence $a \not\in U^H_{\setof{c}}$ and $b \in \mathit{obs}(h(a)) - U^H_{\setof{c}}$ \\
    \ooo So $b \in \mathit{obs}(h(a))$ and $b \not \in U^H_{\setof{c}}$ \\
    \ooo So $(a,b) \in O_H$ \\
    \ooo So $(b,a) \in R_H$, and so $a \in \mathit{reads}(h(b))$ \\
    \ooo Since $b \not\in U^H_{\setof{c}}$, $\mathit{reads}(h'(b)) = \mathit{reads}(h(b))$ \\
    \ooo Therefore $a \in \mathit{reads}(h'(b))$, and so $(b,a) \in R_{H'}$ \\
    \ooo Therefore $(a,b) \in R^\dagger_{H'}$ 
  \end{tabbedproof}

\item $\mathit{unique}(h) = \mathit{unique}(h')$.

This is immediate, since $\mathit{identity}(h) = \mathit{identity}(h')$ 
\end{enumerate}
\end{proof}


\begin{lemma}{(Updating the Abstract Heap)}
Suppose we have $H = (D,h)$ and $H, D' \models \phi \otimes
\celleither{c}{\cmd}$ and $c \in D$. Then for $H' = (D, h') = H|_{\setof{c}}$, we
have $H', D' \models \phi \otimes \cellneg{c}{\cmd}$.
\end{lemma}

\begin{proof}
\begin{tabbedproof}
\oo Assume we have $H, D' \models \phi \otimes \celleither{c}{\cmd}$ \\
\oo Then we have $D_1, D_2$ such that $D_1 \uplus D_2 = D'$ and $H, D_1 \models \phi$ and $H, D_2 \models \celleither{c}{\cmd}$ \\
\oo Note that this means $c$ is not in $D_1$ \\
\oo First, consider $(D,h), D_1 \models \phi$ \\
\ooo We will show by induction that for all $\phi, D_1$ such that $c \not\in D_1$, $(D,h'), D_1 \models \phi$ \\
\ooo Case $\phi = I$ or $\phi = \localref{r}{v}$: \\
\oooo In this case, by the definition of satisfaction, $(D,h), D_1 \models I$ or $(D,h), D_1 \models \localref{r}{v}$\\
\ooo Case $\phi = \psi \otimes \theta$: \\
\oooo In this case, we have $D'_1, D'_2$ such that $D_1 = D'_1 \uplus D'_2$ and \\
\oooox $(D,h), D'_1 \models \psi$ \\
\oooox $(D,h), D'_2 \models \theta$ \\
\oooo By induction, we know that \\
\oooox $(D,h'), D'_1 \models \psi$ \\
\oooox $(D,h'), D'_2 \models \theta$ \\
\oooo Hence by the definition of satisfaction, $(D,h'), D_1 \models \psi \otimes \theta$ \\
\ooo Case $\phi = \cellneg{a}{\cmd}$: \\
\oooo In this case, we know $a \in D_1$ and $\mathit{code}(h(a)) = \cmd$ and $a \not\in V_{(D,h)}$ \\
\oooo Hence $\mathit{value}(h(a)) = \None$, and so $\mathit{value}(h'(a)) = \None$ \\
% \oooo Since $R_H \subseteq V_H \times V_H$, it follows  $U = \emptyset$ \\
% \oooo Hence $h' = h$ \\
\oooo Hence $(D,h'), D_1 \models \cellneg{a}{\cmd}$ \\
\ooo Case $\phi = \cellpos{a}{\cmd}{v}{r}$: \\
\oooo Now, consider whether $r \subseteq V_H$ \\
\oooo If $r \subseteq V_H$: \\
\ooooo We know $a \in D_1$ and $\mathit{code}(h(a)) = \cmd$ and 
       $\mathit{value}(h(a)) = \Some(v)$ and $\mathit{reads}(h(a)) = r$ \\
\ooooo So $a \in V_H$. \\
\ooooo Now consider whether $a \in U^H_{\setof{c}}$ \\
\ooooo If $a \in U^H_{\setof{c}}$: \\
\oooooo First, note $a \not\in V_{(D,h')}$ \\
\oooooo Next, note $(a, c) \in R^*_H$ \\
\oooooo Since $c \not= a$ (since $c$ is not in $D_1$), we know $(a, c) \in R^+_H$ \\
\oooooo Hence there is a $d \in r$ such that $(a,d) \in R_H$ and $(d, c) \in R^*_H$  \\
\oooooo Since $(a,d) \in R_H$, we know $d \in r$, and since $(d, c) \in R^*_H$, we know $d \in U^H_{\setof{c}}$ \\
\oooooo Consequently, $\mathit{value}(h'(d)) = \None$, and so $d \not\in V_{(D,h')}$\\
\oooooo Hence $r \not\subseteq V_{(D, h')}$ \\
\oooooo Hence $(D,h'), D_1 \models \cellpos{a}{\cmd}{v}{r}$ \\
\ooooo If $a \not\in U^H_{\setof{c}}$: \\
\oooooo Then note $a \in V_{(D,h')}$ \\
\oooooo Furthermore, $(a, c) \not\in R^*_H$, and so $a \not\in U^H_{\setof{c}}$ \\
\oooooo Therefore $\mathit{value}(h|_{\setof{c}}(a)) = \mathit{value}(h(a)) = \Some(v)$ and \\
\oooooo we know $\mathit{reads}(h|_{\setof{c}}(a)) = \mathit{reads}(h(a)) = r$ \\
\oooooo Since $(a, c) \not\in R^*_H$, there is no $d \in r$ such that $(d, c) \in R^*_H$  \\
\oooooo Hence $r \cap U^H_{\setof{c}} = \emptyset$ \\
\oooooo Hence $r \subseteq V_{(D,h')}$ \\
\oooooo Hence $(D,h'), D_1 \models \cellpos{a}{\cmd}{v}{r}$ \\
\oooo If $r \not\subseteq V_H$: \\
\ooooo Then we know $a \in D_1$ and $\mathit{code}(h(a)) = \cmd$ and $a \not\in V_H$  \\
\ooooo Since $V_{H'} \subseteq V_H$, we know $r \not\subseteq V_{H'}$ too \\
% \ooooo Since $R_H \subseteq V_H \times V_H$, it follows that $\comprehend{c'\in D}{(a,c') \in R} = \emptyset$. \\
% \ooooo Hence $U = \emptyset$ \\
% \ooooo Hence $h' = h$ \\
\ooooo Hence $(D,h'), D_1 \models \cellpos{a}{\cmd}{v}{r}$ \\
\oo As a result, we can conclude that $(D,h'), D_1 \models \phi$ \\
\oo Next, consider $(D,h), D_2 \models \celleither{c}{\cmd}$: \\
\ooo Since $(c, c) \in R^*_H$,  we know $c \in U$ \\
\ooo Hence it follows $c \not\in V_{(D, h')}$ \\
\ooo Hence $(D,h'), D_2 \models \cellneg{c}{\cmd}$ \\
\oo Therefore, it follows that $(D,h'), D' \models \phi \otimes \cellneg{c}{\cmd}$ \\ 
\end{tabbedproof}
\end{proof}


\begin{lemma}{(The $\ctext{mark\_unready}$ procedure preserves order structure)}
Suppose $H = (D,h)$ where $R^+_H$ is a strict partial order,
$O^\dagger_H = R_H$, $R_H \subseteq V_H \times V_H$ and
$\mathit{unique}(H)$. Then for any $c \in D$ and $H' = (D, h') =
H|_{\setof{c}}$, the $\ctext{mark\_unready}$ function satisfies the following specification:

\begin{displaymath}
\mspec{\mathit{heap}(H)}{\ctext{mark\_unready}(c)}{a:\unittype}{\mathit{heap}(H')}
\end{displaymath}
  
\end{lemma}

\begin{proof}
We will be to prove this function using the fixed point induction
rule, using precisely this specification. (In fact, the function is
totally correct, since it is always called on arguments higher up in
the partial ordering on cells, but tracking the termination metric in
detail obscures the key ideas.)

Now we will proceed line-by-line through the function body of $\ctext{mark\_unready}(c)$: 

\begin{tabbedproof}
\oo We know \\
\oox $R^\dagger_H = O_H$ \\
\oox $R^+_H$ strict partial order \\
\oox $R_H \subseteq V_H \times V_H$ \\
\oox $\mathit{unique}(H)$ \\
\oox $\mathit{heap}(H)$ \\
\ooo Consider whether $c$ is in $V_H$ \\
\ooo Suppose $c \not\in V_H$: \\
\oooo Then $U = \emptyset$, since $R_H \subseteq V_H \times V_H$ \\ 
\oooo Therefore $H'$ is equal to $H$ \\
\oooo Since $R_H \subseteq V_H \times V_H$, we know $\mathit{reads}(h'(c)) = \mathit{obs}(h'(c)) = \emptyset$ \\
\oooo $[\unpack{\alpha}{a}{c}{}$ \\
\oooo Now, we know that $c = \pack{\alpha}{a}$ \\
\oooo $\letv{os}{[!(a.obs)]}{}$ \\
\oooo $\letv{rs}{[!(a.reads)]}{}$ \\
\oooo From the definition of $\mathit{heap}(H)$, we know that  \\
\oooo $\mathit{set}(D, os, \emptyset)$ and $\mathit{set}(D, rs, \emptyset)$ \\
\oooo Simplifying using the axioms for sets, lines 8 and 9 of Figure~\ref{notification-implementation-update} are no-ops \\
\oooo $\letv{\_}{[a.value := \None]}{}$ \\
\oooo $\letv{\_}{[a.reads := \ctext{emptyset}]}{}$ \\
\oooo $a.obs := \ctext{emptyset}]$ \\
\oooo None of these assignments have any effect on the validity of $\mathit{heap}(H')$ \\
\ooo Suppose $c \in V_H$: \\
\oooo $[\unpack{\alpha}{a}{c}{}$ \\
\oooo Now, we know that $c = \pack{\alpha}{a}$ \\
\oooo $\letv{os}{[!(a.obs)]}{}$ \\
\oooo $\letv{rs}{[!(a.reads)]}{}$ \\
\oooo From the definition of $\mathit{heap}(H)$, we know that  \\
\oooo $\mathit{set}(D, os, \mathit{obs}(h(c)))$ and $\mathit{set}(D, rs, \mathit{reads}(h(c)))$ \\
\oooo Furthermore, we also know that for every $o \in os$, $(c, o) \in O_H$, and hence $(o, c) \in R_H$. \\
\oooo Since $R^+_H$ is a strict partial order, $c \not \in U^H_{\setof{o}}$ for any $o \in os$ \\
\oooo Therefore, we know that $c \not\in U^H_{os}$ and that $U^H_{os \cup \setof{c}} = U^H_{os} \cup \setof{c} = U^H_{\setof{c}}$ \\
\oooo Now, by the equational axioms in the cellset interface, $\ctext{iterseq\;mark\_unready}\;os$ \\
\ooox is equal to a sequence of calls to $\ctext{mark\_unready}$, once for each element of $\mathit{obs}(h(c))$\\
\oooo By induction on the size of $\mathit{obs}(h(c))$, we end in a logical state $(D, h|_{os})$, \\
\ooox and a physical state $\mathit{heap}(D, h|_{\setof{os}})$, which (using lemma 79)  \\
\ooox satisfies the properties $R^\dagger_{(D,h|_{os})} = O_{(D,h|_{os})}$, $R^+_{(D,h|_{os})}$ is a strict partial order, \\
\ooox $R_{(D,h|_{os})} \subseteq V_{(D,h|_{os})} \times V_{(D,h|_{os})}$ and $\mathit{unique}(D,h|_{os})$ \\
\oooo Since $V_{H|_{os}} = V_H - U^H_{os}$, and $c \not \in U^H_{os}$, we know $c \in V_{H|_{os}}$ \\ 
\oooo Furthermore, we know that $U^{H|_{os}}_{\setof{c}} = \setof{c}$, since we know that \\
\oooox $U^{H|_{os}}_{\setof{c}} \cup U^H_{os} = U^H_{os \cup \setof{c}} = U^H_{os} \cup \setof{c}$ \\
\oooo Therefore consider $h' = h|_{os}|_{\setof{c}}$, which is equivalent to  \\
\oooox $\mathit{value}(h'') = \semfun{c'}{\IfThenElse{c' = c}{\None}{\mathit{value}(h|_{os}(c'))}}$ \\
\oooox $\mathit{reads}(h'') = \semfun{c'}{\IfThenElse{c' = c}{\emptyset}{\mathit{reads}(h|_{os}(c'))}}$ \\
\oooox $\mathit{obs}(h'') = \semfun{c'}{\IfThenElse{c'\in \mathit{obs}(h(c))}{\emptyset}{\mathit{obs}(h|_{os}(c')) - \setof{c}}}$ \\
\oooo This is equivalent to \\
\oooox $\mathit{value}(h'') = \semfun{c'}{\IfThenElse{c' \in U^{H|_{os}}_{\setof{c}}}{\None}{\mathit{value}(h|_{os}(c'))}}$ \\
\oooox $\mathit{reads}(h'') = \semfun{c'}{\IfThenElse{c' \in U^{H|_{os}}_{\setof{c}}}{\emptyset}{\mathit{reads}(h|_{os}(c'))}}$ \\
\oooox $\mathit{obs}(h'') = \semfun{c'}{\IfThenElse{c'\in \mathit{obs}(h(c))}{\emptyset}{\mathit{obs}(h|_{os}(c')) - U^{H|_{os}}_{\setof{c}}}}$ \\
\oooo By the equational axioms in the cellset interface, $\ctext{iterseq}\;(\ctext{remove\_obs}\;cell)\;rs$ \\
\ooox is equal to a sequence of calls to $\ctext{remove\_obs}$, once for each element of $\mathit{reads}(h'(c))$\\
\oooo $\letv{\_}{[a.value := \None]}{}$ \\
\oooo $\letv{\_}{[a.reads := \emptyset]}{}$ \\
\oooo $a.obs := \emptyset]$ \\
\oooo These updates then ensure that $\mathit{heap}(D, h'')$ is satisfied. \\
\oooo From lemma 78 and line 27,  $h'' = h|_{os}|_{\setof{c}} = h|_{os \cup \setof{c}} = h|_{c} = h'$ from the premise\\ 
\end{tabbedproof}
\end{proof}

\begin{lemma}{(Correctness of $\ctext{mark\_unready}$)}
The $\ctext{mark\_unready}$ function satisfies the following specification:   
\begin{displaymath}
\mspec{Inv(H, \phi \otimes \celleither{c}{\cmd})}{\ctext{mark\_unready}}{a:\unittype}{\exists H'.\;Inv(H', \phi \otimes \cellneg{c}{\cmd})}
\end{displaymath}
\end{lemma}

\begin{proof}
  This follows immediately from the previous lemma, together with lemmas 79 and 80. 
\end{proof}

\ \\

\begin{lemma}{(Updating Negative Formulas)}
Suppose we have  $H = (D,h)$ and $H, D' \models \phi \otimes \cellneg{c}{\cmd}$. Then, if
we define $h'$ such that $\mathit{code}(h'(c)) = \cmd'$ and $h'$ is equal to $h$ otherwise, 
it follows that with $H' = (D,h')$, we have $H', D' \models \phi \otimes \cellneg{c}{\cmd'}$. 
\end{lemma}

\begin{proof}
  \begin{tabbedproof}
    \oo Assume $H, D' \models \phi \otimes \cellneg{c}{\cmd}$. \\
    \ooo So we have $D_1, D_2$ such that $D' = D_1 \uplus D_2$ and $H, D_1 \models \phi$ and $H, D_2 \models \cellneg{c}{\cmd}$ \\
    \ooo Since $H, D_2 \models \cellneg{c}{\cmd}$, we know that $c \in D_2$ and $c \not\in D_1$ \\
    \ooo As a lemma, we show $\forall \hat{D}$, if $H, \hat{D} \models \phi$ and $c \not \in \hat{D}$, then $H', \hat{D} \models \phi$ \\
    \ooo We proceed by induction on $\phi$: \\
    \oooo Case $\phi = I$ or $\phi = \localref{r}{v}$: \\
    \ooooo This case is immediate \\
    \oooo Case $\phi = \psi \otimes \theta$: \\
    \ooooo In this case, we have $D_3, D_4$ such that $\hat{D} = D_3 \uplus D_4$ and  \\
    \ooooox $H, D_3 \models \psi$ and $H, D_4 \models \theta$ \\
    \ooooo So by induction we have $H', D_3 \models \psi$ and $H', D_4 \models \theta$ \\
    \ooooo Hence $H', \hat{D} \models \phi$\\
    \oooo Case $\phi = \cellneg{c'}{\cmd}$: \\
    \ooooo We know $c' \in \hat{D}$, and therefore $c' \not= c$. \\
    \ooooo Hence $h'(c') = h(c)$ \\
    \ooooo Hence $H', \hat{D} \models \cellneg{c'}{\cmd}$ \\
    \oooo Case $\phi = \cellpos{c'}{\cmd}{v}{r}$: \\
    \ooooo We know that $c' \in \hat{D}$, and therefore $c \not= c'$ \\
    \ooooo Hence $h'(c') = h(c')$ \\
    \ooooo Therefore $\mathit{reads}(h'(c')) = \mathit{reads}(h(c'))$, $\mathit{value}(h'(c')) = \mathit{value}(h(c'))$, \\
    \oooox and $\mathit{code}(h'(c')) = \mathit{code}(h(c'))$ \\ 
    \ooooo Furthermore, $V_{H'} = V_H$ since $\mathit{value} \circ h' = \mathit{value} \circ h$\\
    \ooooo Hence $H', \hat{D} \models \cellpos{c'}{\cmd}{v}{r}$: \\
    \ooo Therefore we conclude that $H', D_1 \models \phi$ \\
    \ooo Now, we want to show $H', D_2 \models \cellneg{c}{\cmd'}$ \\
    \oooo We know $c \in D_2$ and $\mathit{value}(h(c)) = \None$ \\
    \oooo Furthermore, $\mathit{code}(h'(c)) = \cmd'$ and $\mathit{value}(h'(c)) = \None$ \\
    \oooo Hence $H', D_2 \models \cellneg{c}{\cmd'}$ \\
    \ooo Since $D' = D_1 \uplus D_2$, we conclude $H', D' \models \phi \otimes \cellneg{c}{\cmd'}$ 
  \end{tabbedproof}
\end{proof}

\begin{lemma}{(Update Rule)}
For all cells $o$ and code expressions $\cmd$ and $\cmd'$, the following
triple is provable: 

\begin{tabbing}
$\forall \psi:\formula.\; $\=$\setof{G(\celleither{o}{\cmd'} \otimes \psi)}$ \\
                           \>$\run {\updatecell\;o\;\cmd}$ \\
                           \>$\setof{a:1.\; G(\cellneg{o}{\cmd} \otimes \psi)}$
\end{tabbing}
\end{lemma}

\begin{proof}
This follows immediately from first applying the specification of $\ctext{mark\_unready}$, 
and then using the previous lemma on updating negative formulas. 
\end{proof}


\subsubsection{Correctness of $\newcell$}

We can prove the soundness of a similar specification for $\newcell$ as
well:

\begin{prop}{(New Cell Rule)}
For all code expressions $\cmd$ of type $\alpha$, the following specification is provable: 
\begin{tabbing}
$\forall \psi:\formula.\; $\=$\setof{G(\psi)}$ \\
                           \>$\run {\newcell\;\cmd}$ \\
                           \>$\setof{a:\celltype{\alpha}.\; G(\cellneg{a}{\cmd} \otimes \psi)}$
\end{tabbing}
\end{prop}

\begin{proof}
This is much easier than $\updatecell$: we just need to allocate a new
numeric id for the new cell, and show that the extended cell heap
continues to satisfy all of the expected properties.

Concretely, suppose that $G(\psi) = \mathit{Inv}{(H, \psi)}$ for some
$H = (D,h)$. Now, by the invariant, we know that each cell in $D$ has
a unique numeric id somewhere in the range from $0$ to $|D|-1$. Then,
on lines 29-30 of Figure~\ref{notification-implementation}, we
increment the global counter by 1, and let $id = |D|$.  Then, on lines
31-34, we allocate a pointer $\mathit{code}$ to the code $\cmd$, a
pointer $\mathit{value}$ to $\None$ (to indicate the unitialized
state), as well as pointers $\mathit{reads}$ and $\mathit{obs}$ to
empty read and observer sets.

At line 35, all of these values are bound to variables in scope, so we
can define $H' = (D',h')$, where $\mathit{ec} = \pack{\tau}{\mathit{(code, value, read, obs, id)}}$, 
and 
\begin{displaymath}
(D',h') = (D \cup \setof{\mathit{ec}}, h' = [h|\mathit{ec}: (\cmd, \None, \emptyset, \emptyset, id)])
\end{displaymath}

Then, it is easy to show that the modified heap realizes $H'$ --- the
only fact that does not carry over immediately are the predicates
establishing the the read and observer sets are implemented
correctly. This is because they held for world $D$, and we are now in
world $D'$. Happily, we required as an axiom that $(W \subseteq W')
\implies \mathit{set}(W, v, S) \implies \mathit{set}(W', v, S)$. (See 
lines 22-23 of Appendix 6.8.)

Finally, we need to show that $\cellneg{a}{\cmd} \otimes \psi$ is
satisfied by $H'$. This follows from an easy induction on $\psi$:
since $h'$ is just an extension of $h$ with $V_{H'} = V_H$, none
of the conditionals or function calls in the cell predicates have
different results, which means that the truth-values they define
are unchanged. 

Then we can hide $H'$ behind an existential to establish the postcondition. 
\end{proof}

\begin{figure}
\mbox{}
\begin{mathpar}
  \inferrule*[right=Ready]
            {\forall c' \in r.\; \exists v.\; \ready{\phi}{c'}{v}}
            {\ready{\phi \otimes \cellpos{c}{\cmd}{v}{r}}{a}{v}}
  \\
  \\
  \inferrule*[right=UnreadyPos]
            {\exists c' \in r.\; \unready{\phi}{c'}}
            {\unready{\phi \otimes \cellpos{c}{\cmd}{v}{r}}
                     {c}}
  \and
  \inferrule*[right=UnreadyNeg]
            { }
            {\unready{\phi \otimes \cellneg{c}{\cmd}}{c}}
\end{mathpar}
\caption{Ready and Unready Judgments}
\label{readiness}
\end{figure}

\begin{figure}
\mbox{}
  \begin{displaymath}
    \begin{array}{lcl}
      \closed{I}{s} & = & \top \\
      \closed{\phi \otimes \psi}{s} & = & \closed{\phi}{s} \land \closed{\psi}{s} \\ 
      \closed{\localref{r}{v}}{s} & = & \top \\
      \closed{\cellneg{a}{\cmd}}{s} & = & \top \\
      \closed{\cellpos{a}{\cmd}{v}{r}}{s} & = & r \subseteq s \\
    \end{array}
  \end{displaymath}
\caption{Closedness predicate}
\label{closedness}  
\end{figure}

\begin{figure}
\mbox{}
  \begin{displaymath}
    \begin{array}{lcl}
      R(s, I)                 & = & I \\
      R(s, \phi \otimes \psi) & = & R(s, \phi) \otimes R(s, \psi) \\
      R(s, \localref{r}{v})   & = & \localref{r}{v} \\
      R(s, \cellneg{c}{\cmd})    & = & \cellneg{c}{\cmd} \\
      R(s, \cellpos{c}{\cmd}{v}{r}) & = & \left\{\begin{array}{ll}
                                                \cellpos{c}{\cmd}{v}{r} 
                                              & \mbox{if } s \cap r = \emptyset \\
                                                \cellneg{c}{\cmd}
                                              & \mbox{otherwise}
                                              \end{array}
                                       \right.
    \end{array}
  \end{displaymath}
\caption{Definition of the Ramification Operator $R$}
\label{ramify-def}
\end{figure}

\section{Ramified Frame Properties}

The proof strategy of the previous section is sufficient for
$\newcell$ and $\updatecell$, but is not adequate for defining a frame
property for expressions of $\codetype{\alpha}$.

As an example, suppose that we want to evaluate the formula $\readcell
c$, in a cell heap described by $\cellneg{a}{\return 5}$.  Clearly,
this is a sufficient footprint, and we expect to a) get the return
value 5, and b) see the cell formula change to $\cellpos{a}{\return
  5}{5}{\emptyset}$.  However, the fact that we are now changing cells
from negative to positive means that the conditional character of
readiness, which worked in our favor with $\updatecell$ and
$\newcell\!\!$, now works against us.

In particular, suppose that we run this command with a framed abstract heap
formula $\psi = \cellpos{b}{\readcell a}{17}{\setof{a}}$. Now, the
whole starting heap will be:
\begin{displaymath}
\cellneg{a}{\return 5} \otimes \cellpos{b}{\readcell a}{17}{\setof{a}}  
\end{displaymath}
In any heap satisfying this formula, $b$ will be unready, because it depends 
on an unready cell. But when we execute $\readcell a$, simply copying $\psi$ 
into the post-state will give us the cell formula:
\begin{displaymath}
\cellpos{a}{\return 5}{5}{\emptyset} \otimes \cellpos{b}{\readcell a}{17}{\setof{a}}
\end{displaymath}
That is, our satisfaction relation now expects $b$ to be ready and have the 
value 17, even though $\readcell a$ never touches $b$ at all!

Clearly, we cannot simply copy the same frame formula into the pre-
and the post-condition states in the specification of commands like
$\readcell a$.

To deal with this problem, we will return to the idea of
ramifications, introduced in the previous chapter. We can understand
our difficulty as an instance of the ramification problem as
follows. 

When we evaluate a code expression, we may read some unready cells and
send them from an unready state in the precondition to a ready state
in the postcondition. However, our frame may contain some cell
formulas which were unready only because one of the cells in the
footprint was unready. Therefore, when we update the footprint, we
must modify the frame formula to account for the ramifications of the
change to the footprint. So even though the actual physical storage
representing the frame does not change at all, we need to modify our
abstract formula to reflect our updated state of knowledge.

In our case, \emph{all} of the effects on the frame arise from the
cells we flip from unready to ready. Thus, given a set of cells which
became ready, we can repair the framing formula by taking each
positive cell formula, and setting it to a negative state if its read
set includes anything that went from unready to ready. We define the
ramification operator $R(s, \psi)$ in Figure~\ref{ramify-def}.  It is
a simple structural induction over a framing formula, whose only
action is to replace the positive cell formulas in $\psi$ whose read
sets intersect with $s$ with a corresponding negative cell formula.
The ramification operator has a number of useful properties, which are
most easily expressed after we have introduced a few auxiliary
judgments and predicates.

In Figure~\ref{readiness} we define the two judgments $\unready{\phi}{o}$
and $\ready{\phi}{o}{v}$, which establish whether a cell is ready or
unready, from the syntactic structure of $\phi$. 

\begin{prop}{(Soundness of $\ready{\phi}{o}{v}$ and $\unready{\phi}{o}$)}
For all $o$ and $H$ such that $H = (D,h)$:

\begin{enumerate}
\item For all $\phi$ and $D' \subseteq D$, if $H, D' \models \phi$ and $\ready{\phi}{o}{v})$, then $\mathit{value}(h(o)) = \ctext{Some}\;v$
\item For all $\phi$ and $D' \subseteq D$, if $H, D' \models \phi$ and $\unready{\phi}{o})$, then $o \not\in V_H$
\end{enumerate}
\end{prop}

\begin{proof}
\begin{enumerate}
\item For all $\phi$ and $D' \subseteq D$, if $H, D' \models \phi$ and $\ready{\phi}{o}{v})$, then $\mathit{value}(h(o)) = \ctext{Some}\;v$.

We prove this by induction on the derivation of
$\ready{\phi}{o}{v}$. Assume we know $D' \subseteq D$, that 
$H, D' \models \phi$, and $\ready{\phi}{o}{v}$. 

Then, by inversion on the derivation of $\ready{\phi}{o}{v}$, we know
that $\phi = \psi \otimes \cellpos{o}{\cmd}{v}{r}$, and for each $c'
\in r$, we have a derivation of $\ready{\psi}{c'}{v'}$ for some
$v'$. Since we know $H, D' \models \phi$, we also know there are $D_1,
D_2$ such that $D_1 \uplus D_2 = D'$, $H, D_1 \models
\cellpos{o}{\cmd}{v}{r}$ and $H, D_2 \models \psi$.

Then, by induction, we know that for each $c' \in r$, $c' \in V_H$. Hence
we know that $r \subseteq V_H$, and so by
the fact that $(D,h), D_1 \models \cellpos{o}{\cmd}{v}{r}$,
we know that $o \in V_H$ and $\mathit{value}(h(o)) =
\ctext{Some}(v)$. Hence the conclusion follows.

\item For all $\phi$ and $D' \subseteq D$, if $H, D' \models \phi$ and $\unready{\phi}{o})$, then $o \not\in V_H$.

We prove this by induction on the derivation of $\unready{\phi}{o}$.

Assume we know $D' \subseteq D$, that $H, D' \models \phi$, and
$\unready{\phi}{o}$. Inversion on $\unready{\phi}{o}$ gives two
possibilities.

First, consider the case where $\phi = \psi \otimes \cellneg{o}{\cmd}$. 
Then, the fact that $(D,h), D' \models \psi \otimes \cellneg{o}{\cmd}$
implies that $o \not\in V_H$. 

Now, consider the other case, where $\phi = \psi \otimes
\cellpos{o}{\cmd}{v}{r}$. Then, we know that there is some $a \in r$
such that $\unready{\psi}{a}$ holds, and by induction we know that $a
\not\in V_H$. Since $a \in r$, it follows that $r \not\subseteq V_H$, and so the
fact that $(D,h), D \models \psi \otimes \cellneg{o}{\cmd}$ implies
that $o \not\in V_H$.
\end{enumerate}
\end{proof}


In Figure~\ref{closedness}, we define the $\closed{\phi}{s}$ predicate,
which asserts that every cell formula in $\phi$ reads at most the
cells in $s$. Now, we can summarize the interactions between the 
ramification operator $R$ and abstract heap formulas as follows: 

\begin{prop}{(Interaction Properties)}
Given sets of cells $s$ and $u$, cell $o$, value $v$, and formula $\phi$, we have
that:
\begin{itemize}
\item $R(s, R(u, \phi)) = R(s \cup u, \phi)$
\item If $\unready{\phi}{o}$, then $\unready{R(u, \phi)}{o}$ 
\item If $\ready{R(u, \phi)}{o}{v}$, then $\ready{\phi}{o}{v}$ 
\item If $R(u, \phi)$ and $\closed{\phi}{s}$, then $R(u, \phi) = R(u \cap s, \phi)$ 
\end{itemize}
\end{prop}

All of these facts can be proved with simple inductive arguments. 

The first property means that if we evaluate two expressions, we can
simply combine their ramification effects without having to worry
about the order that they were evaluated in. The second and third let
us know that a ramification cannot make us forget a cell is unready,
nor can it make anything ready that was not ready before. The last
property permits us to constrain the effect of a ramification --- if we
know that two parts of the abstract heap formula do not read each
other at all, we can deduce that ramifications from one will not
affect the other.

\begin{prop}{(Entailments)}
Define $\phi \vdash \theta$ to mean that for all $H$ and $D$, that if $H, D \models \phi$ then 
$H, D \models \theta$. 

\begin{itemize}
\item For all $\phi, \theta$, we have $\phi \otimes \theta \vdash \phi$
\item For all $\phi, \phi', \psi$, if $\phi \vdash \phi'$ then $\phi \otimes \psi \vdash \phi' \otimes \psi$  
\item If $\unready{\phi}{c}$ then $\phi \dashv\vdash R(\setof{c}, \phi)$
\item If $\unready{\phi \otimes \celleither{c}{\cmd}}{c}$ then $\phi \otimes \celleither{c}{\cmd} \dashv\vdash \phi \otimes \cellneg{c}{\cmd}$
\end{itemize}
\end{prop}

\begin{proof}
\begin{itemize}
\item For all $\phi, \theta$, we have $\phi \otimes \theta \vdash \phi$
\begin{tabbedproof}
\oo Assume we have $\phi, \theta$ and $H, D \models \phi \otimes \theta$ \\
\oo As a lemma, we inductively show that \\
\ox for all $\phi$ and $D' \supseteq D$, we have that $H, D \models \phi$ implies $H, D' \models \phi$ \\
\ooo Case $\phi = I$: \\
\oooo Immediate \\
\ooo Case $\phi = \localref{r}{v}$: \\
\oooo Immediate\\
\ooo Case $\phi = \psi \otimes \theta$: \\
\oooo If $D' \supseteq D$, then there is a $D''$ such that $D' = D \uplus D''$ \\
\oooo By inversion, we have $D_1$ and $D_2$ with $D = D_1 \uplus D_2$ such that \\
\ooox $H, D_1 \models \psi$ and $H, D_2 \models \theta$ \\
\oooo By induction, we know that $H, D_1 \uplus D'' \models \psi$ \\
\oooo Since $D''$ is disjoint from $D$, we know it is disjoint from $D_1$ and $D_2$ \\
\oooo Hence $D_1 \uplus D''$ is disjoint from $D_2$ \\
\oooo Hence $H, D_1 \uplus D'' \uplus D_2 \models \psi \otimes \theta$ \\
\oooo Hence $H, D' \models \phi$ \\
\ooo Case $\phi = \cellneg{c}{\cmd}$: \\
\oooo Since $c \in D$, we know $c \in D'$ \\
\oooo Hence $H, D' \models \cellneg{c}{\cmd}$ \\
\ooo Case $\phi = \cellpos{c}{\cmd}{v}{r}$: \\
\oooo Since $c \in D$, we know $c \in D'$ \\
\oooo Hence $H, D' \models \cellneg{c}{\cmd}$ \\
\oo Now note that we have $D_1, D_2$ such that $D = D_1 \uplus D_2$ and \\
\ox $H, D_1 \models \phi$ and $H, D_2 \models \theta$ \\
\oo Since $D \supseteq D_1$, we know that $H, D \models \phi$ \\
\end{tabbedproof}

\item For all $\phi, \phi', \psi$, if $\phi \vdash \phi'$ then $\phi \otimes \psi \vdash \phi' \otimes \psi$  
\begin{tabbedproof}
\oo Assume we have $\phi \vdash \phi'$ \\
\oo Now, assume we have $H, D$ such that $H,D \models \phi \otimes \psi$ \\
\ooo So we know that there are $D_1, D_2$ such that $D = D_1 \uplus D_2$ and \\
\oox $H, D_1 \models \phi$ and $H, D_2 \models \psi$ \\
\ooo Since $\phi \vdash \phi'$, we know $H, D_1 \models \phi'$ \\
\ooo Hence $H, D_1 \uplus D_2 \models \phi' \otimes \psi$ \\
\ooo Hence $H, D \models \phi' \otimes \psi$ \\
\end{tabbedproof}


\item If $\unready{\phi}{c}$ then $\phi \dashv\vdash R(\setof{c}, \phi)$
\begin{tabbedproof}
\oo Assume $\unready{\phi}{c}$ \\
\oo We want to show that for all $H$ and $D$, that $H, D \models \phi$ iff $H, D \models R(\setof{c}, \phi)$ \\
\oo Assume $H$ \\
\oo $\Rightarrow$: We will show inductively that for all $D$, if $H, D \models \phi$ then $H, D \models R(\setof{c}, \phi)$ \\ 
\ooo Assume $H, D \models \phi$ \\ 
\ooo Case $\phi = I$: \\
\oooo Since $R(\setof{c}, I) = I$, this case is immediate \\
\ooo Case $\phi = \localref{r}{v}$: \\
\oooo Since $R(\setof{c}, \localref{r}{v}) = \localref{r}{v}$, this case is immediate \\
\ooo Case $\phi = \sigma \otimes \theta$: \\
\oooo Since $H, D \models \sigma \otimes \theta$, we know  \\
\ooox there are $D_1, D_2$ such that $D = D_1 \uplus D_2$ and$H, D_1 \models \sigma$ and $H, D_2 \models \theta$ \\
\oooo By induction $H, D_1 \models R(\setof{c}, \sigma)$ and $H, D_2 \models R(\setof{c}, \theta)$ \\
\oooo Hence $H, D \models R(\setof{c}, \sigma) \otimes R(\setof{c}, \theta)$ \\
\oooo Hence $H, D \models R(\setof{c}, \sigma \otimes \theta)$ \\
\ooo Case $\phi = \cellneg{c'}{\cmd}$: \\
\oooo Since $R(\setof{c}, \cellneg{c'}{\cmd}) = \cellneg{c'}{\cmd}$, this case is immediate \\
\ooo Case $\phi = \cellpos{c'}{e'}{v'}{r'}$: \\
\oooo Consider whether $c \in r'$: \\
\oooo If $c \not\in r'$: \\
\ooooo Then $R(\setof{c}, \cellpos{c'}{e'}{v'}{r'}) = \cellpos{c'}{e'}{v'}{r'}$ and this case is immediate \\
\oooo If $c \in r'$: \\
\ooooo Since $\unready{c}{\cmd}$ is sound, we know that $c \not\in V_H$. \\ 
\ooooo Hence $r' \not\subseteq V_H$, and so we know that $c' \not\in V_H$ \\
\ooooo Furthermore, we know that $c' \in D$, and $\mathit{code}(h(c')) = e'$, \\
\oooox so we know $H, D \models \cellneg{c'}{e'}$ \\
\ooooo Since $c \in r'$, we know $R(\setof{c}, \cellpos{c'}{e'}{v'}{r'}) = \cellneg{c'}{e'}$ \\
\ooooo Hence $H, D \models R(\setof{c}, \cellpos{c'}{e'}{v'}{r'})$ \\
\oo $\Leftarrow$: We show inductively that for all $D$, if $H, D \models R(\setof{c}, \phi)$ then $H, D \models \phi$\\
\ooo Assume $H, D \models R(\setof{c}, \phi)$ \\ 
\ooo Case $\phi = I$: \\
\oooo Since $R(\setof{c}, I) = I$, this case is immediate \\
\ooo Case $\phi = \localref{r}{v}$: \\
\oooo Since $R(\setof{c}, \localref{r}{v}) = \localref{r}{v}$, this case is immediate \\
\ooo Case $\phi = \sigma \otimes \theta$: \\
\oooo We know $R(\setof{c}, \sigma \otimes \theta) = R(\setof{c}, \sigma) \otimes R(\setof{c}, \theta)$ \\
\oooo Hence we know there are $D_1, D_2$ such that $D = D_1 \uplus D_2$ and \\
\ooox $H, D_1 \models R(\setof{c}, \sigma)$ and $H, D_2 \models R(\setof{c}, \theta)$ \\
\oooo By induction $H, D_1 \models \sigma$ and $H, D_2 \models \theta$ \\
\oooo Hence $H, D \models \sigma \otimes \theta$ \\
\ooo Case $\phi = \cellneg{c'}{\cmd}$: \\
\oooo Since $R(\setof{c}, \cellneg{c'}{\cmd}) = \cellneg{c'}{\cmd}$, this case is immediate \\
\ooo Case $\phi = \cellpos{c'}{e'}{v'}{r'}$: \\
\oooo Consider whether $c \in r'$: \\
\oooo If $c \not\in r'$: \\
\ooooo Then $R(\setof{c}, \cellpos{c'}{e'}{v'}{r'}) = \cellpos{c'}{e'}{v'}{r'}$ and this case is immediate \\
\oooo If $c \in r'$: \\
\ooooo We know $H, D \models R(\setof{c}, \cellpos{c'}{e'}{v'}{r'}) = \cellneg{c'}{e'}$ \\
\ooooo Hence $c' \not\in V_H$ \\
\ooooo Since $\unready{c}{\cmd}$ is sound, we know that $c \not\in V_H$. \\ 
\ooooo Since $c \in r'$, we know that $r' \not\subseteq V_H$, and so $c' \not\in V_H$ lets us conclude \\
\ooooo that $H, D \models \cellpos{c'}{e'}{v'}{r'}$ \\
\end{tabbedproof}



\item If $\unready{\phi \otimes \cellpos{c}{\cmd}{v}{r}}{c}$ then $\phi \otimes \cellpos{c}{\cmd}{v}{r} \dashv\vdash \phi \otimes \cellneg{c}{\cmd}$
\begin{tabbedproof}
\oo Assume $\unready{\phi \otimes \cellpos{c}{\cmd}{v}{r}}{c}$  and $H, D$ \\
\oo Now we want to show $H, D \models \phi \otimes \cellpos{c}{\cmd}{v}{r}$ if and only if \\
\ox $H, D \models \phi \otimes \cellneg{c}{\cmd}$ \\
\oo $\Rightarrow$: Assume $H, D \models \phi \otimes \cellpos{c}{\cmd}{v}{r}$ \\
\ooo So we have $D_1, D_2$ such that $D = D_1 \uplus D_2$ and \\
\oox $H, D_1 \models \phi$ and $H, D_2 \models \cellpos{c}{\cmd}{v}{r}$ \\
\ooo From the soundness of $\unready{\phi \otimes \cellpos{c}{\cmd}{v}{r}}{c}$, we know that $c \not \in V_H$ \\
\ooo Hence we know that $H, D_2 \models \cellneg{c}{\cmd}$ \\
\ooo Hence we know that $H, D \models \phi \otimes \cellneg{c}{\cmd}$ \\
\oo $\Leftarrow$: Assume $H, D \models \phi \otimes \cellneg{c}{\cmd}$ \\
\ooo So we have $D_1, D_2$ such that $D = D_1 \uplus D_2$ and \\
\oox $H, D_1 \models \phi$ and $H, D_2 \models \cellneg{c}{\cmd}$ \\
\ooo Since $H, D_2 \models \cellneg{c}{\cmd}$, we know $c \not\in V_H$ \\ 
\ooo We want to show $H, D_2 \models \phi \otimes \cellpos{c}{\cmd}{v}{r}$ \\
\ooo Since $c \not\in V_H$, it suffices to show there is a $d \in r$ such that $d \not\in V_H$ \\
\ooo By inversion on $\unready{\phi \otimes \cellpos{c}{\cmd}{v}{r}}{c}$ we know $\unready{\phi}{d}$ for some $d \in r$ \\
\ooo By soundness of $\unready{\phi}{d}$, we know that $d \not\in V_H$ \\
\ooo Hence we know that $H, D_2 \models \cellpos{c}{\cmd}{v}{r}$ \\
\ooo Hence we know that $H, D \models \phi \otimes \cellpos{c}{\cmd}{v}{r}$ \\
\end{tabbedproof}
\end{itemize}
\end{proof}



\subsection{The Abstract Semantics of Expressions}

Now we can finally define the abstract semantics of the code
expression monad, which we give in Figure~\ref{abs-semantics}.

As before, we describe the effect of an expression $\cmd$ with a Hoare
triple, prefixed with a quantification over all possible frames
$\psi$. Then we assert that from a state $G(\phi \otimes \psi)$,
running $\cmd$ will give us a state $G(\phi' \otimes R(u, \psi))$ ---
that is, we must update the frame with the ramification $u$. Note in
particular that the ramification means that the framing formulas may
\emph{differ} between the pre- and the post-conditions. For composite
commands (such as $\bind \cmd\;f$) we give their specifications as
implications over the specifications of their subcomponents.

In the specification \textsc{AUnit}, we give a specification for the
$\return v$ command, which simply returns its argument and neither
reads nor updates any cells or state. 

The \textsc{ABind} rule explains how sequential composition works for
an expression $\bind \cmd\;f$ --- as expected, we evaluate the first
monadic argument, and pass the result to the functional argument, and
evaluate that. The read and update sets are simply the union of the
two executions. Reading a cell comes in two variants, \textsc{AReady}
and \textsc{AUnready}. If a cell is ready (using the
$\ready{\phi}{c}{v}$ judgment), we simply return its memoized value
without any further computation, and do not need to use a ramification
to update the frame. On the other hand, if a cell is unready (from the
$\unready{\phi}{c}$ judgment), we need to evaluate its code body, and
then update the cell with its new value. So we need to know what the
evaluation of its body can do. Note that we have to apply the
ramification operator to $\phi'$ in the postcondition in the
consequence of \textsc{AUnready}, because the cell we are reading goes
from unready to ready itself. 

We can also read and write local state (with the \textsc{AGetRef} and
\textsc{ASetRef} specifications), which do not have any effect on the
cells. Finally, we have the \textsc{AConseq} rule, which gives us a
version of the rule of consequence from ordinary Hoare logic.

Note that the use of the ready and unready judgments, together with
the entailment relation on abstract heaps, means that we can reason
``syntactically'' about the behavior of cell-manipulating programs: we
do not need to know what the concrete model (or concrete
implementation) when we are proving the correctness of client
programs. We will see this in the next section, which illustrates that
this interface really does give us a genuinely modular way of
reasoning about dataflow networks.

\begin{prop}{(Soundness of Abstract Semantics)}

All of the rules of the abstract semantics in Figure~\ref{abs-semantics} are
provable within our specification logic. 
\end{prop}

At this point, we can now reason about the behavior of the imperative
notification library in terms of its action on the abstract heap. The
combination of quantification and ramification give us a domain-specific 
frame property, which allow us to modularly prove the correctness of programs 
that construct and produce notifications.


\begin{figure}
\mbox{}
\begin{mathpar}
\begin{array}{ll}  
\mbox{\textsc{AUnit}} & 
\forall \psi.\; \mspec{G(\psi)}
                     {\return v}
                     {a}{G(\psi) \land \exists z.\; a = (v, z) \land \mathit{set}(\emptyset, z, \emptyset)} 
\\[1em]

\mbox{\textsc{ABind}} & 
\forall \psi.\; \mspec{G(\phi \otimes \psi)}
                     {\cmd}
                     {a}{G(\phi' \otimes R(u', \psi)) \land \exists z.\;a = (v', z) \land \mathit{set}(r', z, r')} 
                \specand \\
&  \forall \psi.\; \mspec{G(\phi' \otimes \psi)}
                        {f\;v'}
                        {a}{G(\phi'' \otimes R(u'', \psi)) \land \exists z.\; a = (v'', z) \land \mathit{set}(r'', z, r'')}\\
&  \specimp \\
&  \begin{array}{ll}
     \forall \psi. & \left<G(\phi \otimes \psi)\right> \\
                   & \bind \cmd\;f \\
                   &  \left<a.\;G(\phi'' \otimes R(u' \cup u'', \psi)) \land \exists z.\;a = (v'', z) \land \mathit{set}(r' \cup r'', z, r' \cup r'')\right> \\
   \end{array}
\\[2em]

\mbox{\textsc{AReady}} & 
  \setof{\ready{\phi}{c}{v}} \specimp \\
& \forall \psi.\; \mspec{G(\phi \otimes \psi)}
                       {\readcell c}
                       {a}{G(\phi \otimes \psi) \land \exists z.\;a = (v, z) \land \mathit{set}(\setof{c}, z, \setof{c})} 
\\[1em]

\mbox{\textsc{AUnready}} & 
  \setof{\unready{\phi \otimes \celleither{c}{\cmd}}{c}} \specand \\
& \forall \psi.\; \mspec{G(\phi \otimes \psi)}
                       {\cmd}
                       {a}{G(\phi' \otimes R(u, \psi)) \land \exists z.\; a = (v, z) \land \mathit{set}(r, z, r)} \\
& \specimp \\
& \begin{array}{ll}
   \forall \psi. & \left<G(\phi \otimes \celleither{c}{\cmd} \otimes \psi)\right> \\
                 & \readcell c \\
                 & \left<a.\; 
                     \begin{array}{l}
                       G(R(\setof{c}, \phi') \otimes \cellpos{c}{\cmd}{v}{r} \otimes R(u \cup \setof{c}, \psi)) 
                        \;\land \\
                        \exists z.\;a = (v, z) \land \mathit{set}(\setof{c}, z, \setof{c})
                     \end{array}\right> 
  \end{array}
\\[3em]

\mbox{\textsc{AGetRef}}
& \begin{array}{ll}
    \forall \psi.\; 
    &  \left<G(\localref{r}{v} \otimes \psi)\right> \\
    &  \getref r \\
    &  \left<a.\; G(\localref{r}{v} \otimes \psi) 
                  \land  \exists z.\;a = (v,z) \land \mathit{set}(\emptyset, z, \emptyset)
       \right> \\
     \end{array}
\\[2em]

\mbox{\textsc{ASetRef}}
& \begin{array}{ll}
    \forall \psi.\; 
    &  \left<G(\localref{r}{v'} \otimes \psi)\right> \\
    &  \setref r\;v \\
    &  \left<a.\; G(\localref{r}{v} \otimes \psi) 
                  \land  \exists z.\;a = (v,z) \land \mathit{set}(\emptyset, z, \emptyset)
       \right> \\
     \end{array}
\\[2em]

% \mbox{\textsc{ANewCell}}
% & \forall \psi.\; \mspec{G(\psi)}{\newcell \cmd}{(c,z)}{G(\cellneg{c}{\cmd} \otimes \psi) \land \mathit{set}(\emptyset, z, \emptyset)}
% \\[1em]

\mbox{\textsc{AConseq}}
& \setof{\phi' \vdash \phi} \specand \setof{\theta \vdash \theta'} \specand \\
& \forall \psi.\; \mspec{G(\phi \otimes \psi) \land P}{\cmd}{(x,z)}{G(\theta\otimes R(u, \psi)) \land Q} \\
& \specimp \\
& \forall \psi.\; \mspec{G(\phi' \otimes \psi) \land P}{\cmd}{(x,z)}{G(\theta'\otimes R(u, \psi)) \land Q} \specand \\

\end{array}
\end{mathpar}
\caption{Abstract Semantics of Notifications}
\label{abs-semantics}
\end{figure}


\subsection{Proving the correctness of \textsc{AUnit}}
\begin{prop*}{(The \textsc{AUnit} specification is sound)}
The following triple is derivable:
\begin{displaymath}
\forall \psi.\; \mspec{G(\psi)}
                     {\return v}
                     {a}{G(\psi) \land \exists z.\; a = (v, z) \land \mathit{set}(\emptyset, z, \emptyset)} 
\end{displaymath}
\end{prop*}

\begin{proof}
\begin{tabbedproof}
\oo Assume we have $\psi$ and a prestate $G(\psi)$ \\
\oo Now consider the body of $\return v$ \\
\oo $[(v, \mathsf{emptyset})]$ \\
\oo From line 10 in the set specification, we know $\mathit{set}(\emptyset, \mathsf{emptyset}, \emptyset)$ \\
\oo Hence we know that $\exists z.\; a = (v, z) \land \mathit{set}(\emptyset, z, \emptyset)$ and $G(\psi)$ \\
\end{tabbedproof}
\end{proof}

\subsection{Proving the correctness of \textsc{ABind}}

\begin{prop*}{(The \textsc{ABind} specification is sound)}
The following specification is derivable:
\begin{displaymath}
\begin{array}{l}
\forall \psi.\; \mspec{G(\phi \otimes \psi)}
                     {\cmd}
                     {a}{G(\phi' \otimes R(u', \psi)) \land \exists z.\;a = (v', z) \land \mathit{set}(r', z, r')} 
                \specand \\
\forall \psi.\; \mspec{G(\phi' \otimes \psi)}
                        {f\;v'}
                        {a}{G(\phi'' \otimes R(u'', \psi)) \land \exists z.\; a = (v'', z) \land \mathit{set}(r'', z, r'')}\\
\specimp \\
\begin{array}{ll}
     \forall \psi. & \left<G(\phi \otimes \psi)\right> \\
                   & \bind \cmd\;f \\
                   &  \left<a.\;G(\phi'' \otimes R(u' \cup u'', \psi)) \land \exists z.\;a = (v'', z) \land \mathit{set}(r' \cup r'', z, r' \cup r'')\right> \\
   \end{array}
\end{array}
\end{displaymath}
\end{prop*}

\begin{proof}
\begin{tabbedproof}
\oo Assume $\cmd$, $f$, $r'$, $r''$, $v'$, and $v''$. \\
\oo Assume $\forall \psi.\; \mspec{G(\phi \otimes \psi)}
                     {\cmd}
                     {a}{G(\phi' \otimes R(u', \psi)) \land \exists z_1.\;a = (v', r') \land \mathit{set}(r', z_1, r')}$ \\
\oo Assume $\forall \psi.\; \mspec{G(\phi' \otimes \psi)}
                        {f\;v'}
                        {a}{G(\phi'' \otimes R(u'', \psi)) \land \exists z_2.\; a = (v'', z) \land \mathit{set}(r'', z_2, r'')}$ \\
\oo Assume we have $\psi$, and a prestate $G(\phi \otimes \psi)$ \\
\ooo Now consider the body of $\bind$ \\
\ooo $[\letv{(v_1, z_1)}{\cmd}{}$ \\
\ooo So we know $G(\phi' \otimes R(u', \psi)) \land v_1 = v' \land \mathit{set}(r', z_1, r')$ \\
\ooo Simplifying $v_1$ away, we continue with \\
\ooo $\letv{(v_2, z_2)}{f\;v'}{}$ \\
\ooo Now we know $G(\phi'' \otimes R(u'', R(u', \psi))) \land v_2 = v'' \land \mathit{set}(r', z_1, r') \land \mathit{set}(r'', z_2, r'')$ \\
\ooo Simplifying $v_2$ away, and using the $\textsf{union}$ spec on lines 14-15 of the set specification, \\
\ooo we can take $z = \mathsf{union}\;z_1\;z_2$ and know $\mathit{set}(r' \cup r'', z, r' \cup r'')$ \\
\ooo Hence we know $G(\phi'' \otimes R(u' \cup u'', \psi)) \land \mathit{set}(r' \cup r'', z, r' \cup r'')$ \\
\ooo Then the return value: \\
\ooo $(v'', \mathsf{union}\;z_1\;z_2)]$ \\
\ooo lets us conclude $G(\phi'' \otimes R(u' \cup u'', \psi)) \land \exists z.\; a = (v'', z) \land \mathit{set}(r' \cup r'', z, r' \cup r'')$ 
\end{tabbedproof}
\end{proof}

\subsection{Proving the correctness of \textsc{AReady}}

In this subsection, we will prove the following proposition: 

\begin{prop*}{(The \textsc{AReady} specification is sound)}
The following specification holds: 
\begin{displaymath}
\begin{array}{l}
\setof{\ready{\phi}{c}{v}} \specimp \\
\;\;\;\forall \psi.\; \mspec{G(\phi \otimes \psi)}
                       {\readcell c}
                       {a}{G(\phi \otimes \psi) \land \exists z.\;a = (v, z) \land \mathit{set}(\setof{c}, z, \setof{c})} 
\end{array}
\end{displaymath}
\end{prop*}

\begin{proof}
\begin{tabbedproof}
\oo Assume we have $\phi$, $c$ and $v$ \\ 
\oo Assume $\ready{\phi}{c}{v}$ and a $\psi$ \\
\ooo Now assume we have a precondition $G(\phi \otimes \psi)$ \\
\ooo So there is an $H = (D,h)$ such that $\mathit{Inv}(H, \phi \otimes \psi)$ holds \\
\ooo So we know that $H, D \models \phi \otimes \psi$ and $\mathit{heap}(H)$ \\
\ooo So we know that $c.\mathit{value} \pointsto \mathit{value}(h(c))$ \\
\ooo From soundness of $\ready{\phi}{c}{v}$, we know that $\mathit{value}(h(c)) = \Some(v)$ \\
\ooo $[\letv{o}{[!c.value]}{}$ \\
\ooo So we know that $o = \Some(v)$ \\
\ooo Now we can simplify the case statement and continue \\
\ooo $(v, \mathsf{singleton}\;c)]$ \\
\ooo By choosing as a witness $\mathsf{singleton}\;c$, \\
\ooo we know that $\exists z.\;a = (v, z) \land \mathit{set}(\setof{c}, z, \setof{c})$ and $\mathit{Inv}(H, \phi \otimes \psi)$ holds \\
\ooo So $G(H, \phi \otimes \psi)$ and $\exists z.\;a = (v, z) \land \mathit{set}(\setof{c}, z, \setof{c})$ hold
\end{tabbedproof}
\end{proof}

\subsection{Proving the correctness of \textsc{AUnready}}

In this subsection, we will prove the following proposition:

\begin{prop*}{(Soundness of the \text{AUnready} specification)}
The following triple holds:
\begin{displaymath}
\begin{array}{l}
\setof{\unready{\phi \otimes \celleither{c}{\cmd}}{c}} \specand \\
\forall \psi.\; \mspec{G(\phi \otimes \psi)}
                     {\cmd}
                     {a}{G(\phi' \otimes R(u, \psi)) \land \exists z.\; a = (v, z) \land \mathit{set}(r, z, r)} \\
\specimp \\
\begin{array}{ll}
 \forall \psi. & \left<G(\phi \otimes \celleither{c}{\cmd} \otimes \psi)\right> \\
               & \readcell c \\
               & \left<a.\; 
                   \begin{array}{l}
                     G(R(\setof{c}, \phi') \otimes \cellpos{c}{\cmd}{v}{r} \otimes R(u \cup \setof{c}, \psi)) 
                      \;\land \\
                      \exists z.\;a = (v, z) \land \mathit{set}(\setof{c}, z, \setof{c})
                   \end{array}\right> 
\end{array}
\end{array}
\end{displaymath}
\end{prop*}

This follows the standard pattern of (1) proving that the update
preserves the relevant order structure, (2) proving the new abstract
formula continues to model the updated abstract heap, and finally (3)
showing the code actually implements this update. 


\begin{lemma}{(Reading an Unready Cell Preserves Order Structure)}
Suppose that $H = (D,h)$ and $c \in D - V_H$. Then for any subset $r
\subseteq V_H$ and value $v$, define $h'$ so that
\begin{itemize}
\item $\mathit{code} \circ h' = \mathit{code} \circ h$ 
\item $\mathit{value} \circ h' = \semfun{c'}{\IfThenElse{c' = c}{\Some(v)}{\mathit{value}(h(c'))}}$ 
\item $\mathit{reads} \circ h' = \semfun{c'}{\IfThenElse{c' = c}{r}{\mathit{reads}(h(c'))}}$ 
\item $\mathit{obs} \circ h' = \semfun{c'}{\IfThenElse{c' \in r}{\mathit{obs}(h(c')) \cup \setof{c}}{\mathit{obs}(h(c'))}}$ 
\item $\mathit{identity} \circ h' = \mathit{identity} \circ h$
\end{itemize}
\noindent Then it is the case that $H' = (D,h')$ satisfies the five properties below. 
\begin{enumerate}
\item $V_{H'} = V_H \cup \setof{c}$
\item $R^+_{H'}$ is a strict partial order 
\item $R_{H'} \subseteq V_{H'} \times V_{H'}$
\item $R^\dagger_{H'} = O_{H'}$ 
\item $\mathit{unique}(H') = \mathit{unique}(H)$
\end{enumerate}
\end{lemma}

\begin{proof}
\begin{enumerate}
\item $V_{H'} = V_H \cup \setof{c}$ 
  \begin{tabbedproof}
    \oo So we want to show that $a \in V_{H'}$ iff $a \in V_H \cup \setof{c}$ \\
    \oo $\Rightarrow:$ Assume that $a \in V_{H'}$ \\
    \ooo So we know that $\mathit{value}(h'(a)) = \Some(v')$ for some $v'$ \\
    \ooo Now consider whether $a$ is $c$ \\
    \ooo Suppose $a = c$: \\
    \oooo Then $a \in \setof{c}$, and hence $a \in V_H \cup \setof{c}$ \\
    \ooo Suppose $a \not= c$: \\
    \oooo Then we know that $\mathit{value}(h'(a)) = \mathit{value}(h(a))$ \\
    \oooo Since $\mathit{value}(h'(a)) = \Some(v')$, we know $a \in V_H$ \\
    \oooo Hence $a \in V_H \cup \setof{c}$ \\
    \oo $\Leftarrow:$ Assume that $a \in V_H \cup \setof{c}$ \\
    \ooo Now consider whether $a$ is $c$ \\
    \ooo Suppose $a = c$: \\
    \oooo Then $\mathit{value}(h'(a)) = \Some(v)$ \\
    \oooo Therefore $a \in V_{H'}$ \\
    \ooo Suppose $a \not= c$: \\
    \oooo Then $a \in V_H$ \\
    \oooo Also, $\mathit{value}(h'(a)) = \mathit{value}(h(a))$ \\
    \oooo Therefore there is a $v'$ such that $\mathit{value}(h'(a)) = \Some(v')$ \\
    \oooo Hence $a \in V_{H'}$ \\
  \end{tabbedproof}

\item $R^+_{H'}$ is a strict partial order 
  \begin{tabbedproof}
    \oo This follows if $R^+_{H'}$ is a transitive, irreflexive relation \\
    \oo Since it is a transitive closure, it is a transitive relation \\
    \oo So we want to show there is no $a \in D$ such that $(a,a) \in R^+_{H'}$ \\
    \oo Consider an arbitrary $(a_0, b) \in R^+_{H'}$ \\
    \oo Hence there is a sequence $a_0, \ldots, a_{k+1}$ such that $b = a_{k+1}$ \\
    \ox and for each $i \leq k$, $a_{i+1} \in \mathit{reads}(h'(a_i))$ \\
    \oo Now consider whether $c$ is equal to any of the $a_i$ \\
    \oo Suppose $a_i \not= c$ for all $0 \leq i \leq k+1$: \\
    \ooo Then in this case, it follows that $\mathit{reads}(h'(a_i)) = \mathit{reads}(h(a_i))$ for all $i$\\
    \ooo Then $(a_0, a_{k+1}) \in R^+_H$ \\
    \ooo Then $a_0 \not= a_{k+1}$ since $R^+_H$ is irreflexive \\
    \oo Suppose $a_i = c$ for some $0 \leq i \leq k+1$: \\
    \ooo Note that $\mathit{reads}(h'(a)) \subseteq V_H$ for all $a$  \\
    \ooo Since $c \not\in V_H$, it follows $c \not\in \mathit{reads}(h'(a))$ for any $a \in D$ \\
    \ooo Hence $c \not= a_j$ for any $j > 0$, and so $c = a_0$ and $c \not= a_{k+1}$\\
    \ooo Hence $a_0 \not= a_{k+1}$
  \end{tabbedproof}

\item $R_{H'} \subseteq V_{H'} \times V_{H'}$ 
  \begin{tabbedproof}
    \oo We want to show that for all $(a,b)$, if $b \in \mathit{reads}(h'(a))$, then $a \in V_{H'}$ and $b \in V_{H'}$ \\
    \oo Assume $b \in \mathit{reads}(h'(a))$ \\
    \ooo Now consider whether $a = c$  \\
    \ooo Suppose $a = c$: \\
    \oooo Then $a \in V_{H'}$ \\
    \oooo Since $\mathit{reads}(h'(c)) = r$, we know $b \in r$  and $r \subseteq V_H$ \\
    \oooo Since $V_{H} \subseteq V_{H'}$, it follows $b \in V_{H'}$ \\
    \ooo Suppose $a \not= c$: \\
    \oooo Then $\mathit{reads}(h'(a)) = \mathit{reads}(h(a))$ \\
    \oooo Then $b \in \mathit{reads}(h(a))$, and so $(a,b) \in R_H$ \\
    \oooo Since $R_H \subseteq V_H \times V_H$, we know $a \in V_H$ and $b \in V_H$ \\
    \oooo Since $V_{H} \subseteq V_{H'}$, we know $a \in V_{H'}$ and $b \in V_{H'}$ \\
  \end{tabbedproof}

\item $R^\dagger_{H'} = O_{H'}$ 
  \begin{tabbedproof}
    \oo We want to show that for all $(a,b)$, we have $(a,b) \in R^\dagger_{H'}$ iff $(a,b) \in O_{H'}$ \\
    \oo $\Rightarrow:$ Assume $(a,b) \in R^\dagger_{H'}$ \\
    \ooo Then $(b, a) \in R_{H'}$ \\
    \ooo So $a \in \mathit{reads}(h'(b))$ \\
    \ooo We want to show that $b \in \mathit{obs}(h'(a))$ \\
    \ooo Consider whether $b = c$ \\
    \ooo Suppose $b = c$: \\
    \oooo Then $a \in r$, since $\mathit{reads}(h'(b)) = \mathit{reads}(h'(c)) = r$ \\
    \oooo Therefore $\mathit{obs}(h'(a)) = \mathit{obs}(h(a)) \cup \setof{c} = \mathit{obs}(h(a)) \cup \setof{b}$ \\
    \oooo Hence $b \in \mathit{obs}(h'(a))$ \\
    \ooo Suppose $b \not= c$: \\
    \oooo Then $\mathit{reads}(h'(b)) = \mathit{reads}(h(b))$ \\
    \oooo So $a \in \mathit{reads}(h(b))$ \\
    \oooo Hence $b \in \mathit{obs}(h(a))$ \\
    \oooo Since $\mathit{obs}(h(x)) \subseteq \mathit{obs}(h(x))$ for all $x$, $b \in \mathit{obs}(h'(a))$ \\
    \oo $\Leftarrow:$ Assume $(a,b) \in O_{H'}$ \\
    \ooo Then $b \in \mathit{obs}(h'(a))$ \\
    \ooo We want to show that $a \in \mathit{reads}(h'(b))$ \\
    \ooo Consider whether $b = c$ \\
    \ooo Suppose $b = c$: \\
    \oooo Since $c \not\in V_H$, we can see that $a \in r$, \\
    \ooox since those are the only arguments to $\mathit{obs}$ whose results contain $c$ \\ 
    \oooo But $\mathit{reads}(h'(c)) = r$, so $(b, a) \in R_{H'}$ \\
    \ooo Suppose $b \not= c$: \\
    \oooo Consider whether $a = c$: \\
    \oooo Suppose $a = c$: \\
    \ooooo This case is impossible since $c \not\in V_H$ and $\mathit{obs}(h'(x)) = \emptyset$ for any $x \not\in V_H$ \\
    \oooo Suppose $a \not= c$: \\
    \ooooo Then it follows that $b \in \mathit{obs}(h(a))$ \\
    \ooooo Then it follows that $a \in \mathit{reads}(h(b))$ \\
    \ooooo Therefore $a \in \mathit{reads}(h'(b))$ 
  \end{tabbedproof}

\item $\mathit{unique}(H') = \mathit{unique}(H)$

This is immediate since $\mathit{identity} \circ h' = \mathit{identity} \circ h$.
\end{enumerate}
\end{proof}

\begin{lemma}{(Reading an Unready Cell, Semantically)}
Suppose that $H = (D,h)$ and $H, D' \models \phi \otimes
\celleither{c}{\cmd}$ and $c \not\in V_H$. Then for any subset $r
\subseteq V_H$ and value $v$, define $h'$ so that
\begin{itemize}
\item $\mathit{code} \circ h' = \mathit{code} \circ h$ 
\item $\mathit{value} \circ h' = \semfun{c'}{\IfThenElse{c' = c}{\Some(v)}{\mathit{value}(h(c'))}}$ 
\item $\mathit{reads} \circ h' = \semfun{c'}{\IfThenElse{c' = c}{r}{\mathit{reads}(h(c'))}}$ 
\item $\mathit{obs} \circ h' = \semfun{c'}{\IfThenElse{c' \in r}{\mathit{obs}(h(c')) \cup \setof{c}}{\mathit{obs}(h(c'))}}$ 
\item $\mathit{identity} \circ h' = \mathit{identity} \circ h$
\end{itemize}
Then it follows that for $H' = (D,h')$, we have $H', D' \models R(\setof{c}, \phi) \otimes \cellpos{c}{\cmd}{v}{r}$.
\end{lemma}

\begin{proof}
  \begin{tabbedproof}
    \oo Assume $H, D' \models \phi \otimes \celleither{c}{\cmd}$ and $c \not\in V_H$ \\
    \oo Then there are $D_1, D_2$ with $D' = D_1 \uplus D_2$ and $H, D_1 \models \phi$ and $H, D_2 \models \celleither{c}{\cmd}$ \\
    \oo Then $c \in D_2$ and $c \not \in D_1$, and $\mathit{value}(h(c)) = \None$ \\
    \oo By assumption, $\mathit{value}(h'(c)) = \Some(v)$ and $\mathit{reads}(h'(c)) = r$ \\
    \oo Hence $H', D_2 \models \cellpos{c}{\cmd}{v}{r}$ \\
    \oo As a lemma, we will show that for all $\hat{D}, \phi$ if $c \not\in \hat{D}$ and $H, \hat{D} \models \phi$ then $H, \hat{D} \models R(\setof{c}, \phi)$ \\
    \ooo Now proceed by induction on $\phi$: \\
    \ooo Case $\phi = I$: \\
    \oooo By definition $H', \hat{D} \models I$ \\
    \ooo Case $\phi = \localref{r}{v'}$: \\
    \oooo By definition $H', \hat{D} \models \localref{r}{v'}$ \\
    \ooo Case $\phi = \psi \otimes \theta$: \\
    \oooo So we know there are $D_3, D_4$ such that $\hat{D} = D_3 \uplus D_4$ and \\
    \oooox $H, D_3 \models \psi$ and \\
    \oooox $H, D_4 \models \theta$ \\
    \oooo By induction, we know that \\
    \oooox $H', D_3 \models R(\setof{c}, \psi)$ and \\
    \oooox $H', D_4 \models R(\setof{c}, \theta)$ \\
    \oooo Hence $H', \hat{D} \models R(\setof{c}, \psi) \otimes R(\setof{c}, \theta)$ \\
    \oooo Hence $H', \hat{D} \models R(\setof{c}, \psi \otimes \theta)$ \\

    \ooo Case $\phi = \cellneg{c'}{e'}$: \\
    \oooo So we know that $c' \not\in V_H$ and $c' \not= c$ and $\mathit{code}(h(c')) = e'$ and $c' \in \hat{D}$\\
    \oooo Hence $c' \not\in V_{H'}$ and $\mathit{code}(h'(c')) = e'$\\
    \oooo Hence $H', \hat{D} \models \cellneg{c'}{e'}$ \\
    \oooo Hence $H', \hat{D} \models R(\setof{c}, \cellneg{c'}{e'})$ \\

    \ooo Case $\phi = \cellpos{c'}{e'}{v'}{r'}$: \\
    \oooo Now consider whether $r' \subseteq V_H$ \\
    \oooo Suppose $r' \subseteq V_{H}$: \\
    \ooooo So $\mathit{value}(h(c')) = \Some(v')$ and $\mathit{reads}(h(c')) = r'$ and
           $\mathit{code}(h(c')) = e'$ and $a \in D$ \\
    \ooooo Since $c \not \in \hat{D}$, we know $c' \not= c$ \\
    \ooooo Therefore $\mathit{value}(h'(c')) = \Some(v')$ \\
    \ooooo Therefore $\mathit{reads}(h'(c')) = r'$ \\
    \ooooo Since $V_{H'} \supseteq V_H$, it follows that $r' \subseteq V_{H'}'$ \\
    \ooooo Therefore $H', \hat{D} \models \cellpos{c'}{e'}{v'}{r'}$ \\
    \ooooo Furthermore, since $r' \subseteq V_H$, we know $c \not\in r'$ \\
    \ooooo Hence $R(\setof{c}, \cellpos{c'}{e'}{v'}{r'}) = \cellpos{c'}{e'}{v'}{r'}$ \\
    \ooooo Therefore $H', \hat{D} \models R(\setof{c}, \cellpos{c'}{e'}{v'}{r'})$ \\
    \oooo Suppose $r' \not\subseteq V_{H}$: \\
    \ooooo Then $c' \not\in V_H$ and $c' \not= c$\\
    \ooooo So $c' \not \in V_{H'}$ \\
    \ooooo Now, consider whether $c \in r'$: \\
    \ooooo Suppose $c \in r'$: \\
    \oooooo Since $c' \not \in V_{H'}$, we know $H', \hat{D} \models \cellneg{c'}{e'}$ \\
    \oooooo Hence $H', \hat{D} \models R(\setof{c}, \cellpos{c'}{e'}{v'}{r'})$ \\
    \ooooo Suppose $c \not\in r'$: \\
    \oooooo Since $r' \not\subseteq V_H$, there is $x \in r'$ such that $x \not \in V_H$ and $x \not= c$ \\
    \oooooo Therefore $r' \not\subseteq V_{H'}$ \\
    \oooooo Therefore $H', \hat{D} \models \cellneg{c'}{e'}$ \\
    \oooooo Since $c \in r'$, we know $R(\setof{c}, \cellpos{c'}{e'}{v'}{r'}) = \cellneg{c'}{e'}$ \\
    \oooooo Therefore $H', \hat{D} \models R(\setof{c}, \cellpos{c'}{e'}{v'}{r'})$ \\
    \oo We apply the lemma to conclude $H, D_1 \models R(\setof{c}, \phi)$ \\
    \oo Therefore, $H, D \models R(\setof{c}, \phi) \otimes \cellpos{c}{\cmd}{v}{r}$ \\
  \end{tabbedproof}
\end{proof}

\begin{prop*}{(Soundness of the \text{AUnready} specification)}
The following triple holds:
\begin{displaymath}
\begin{array}{l}
\setof{\unready{\phi \otimes \celleither{c}{\cmd}}{c}} \specand \\
\forall \psi.\; \mspec{G(\phi \otimes \psi)}
                     {\cmd}
                     {a}{G(\phi' \otimes R(u, \psi)) \land \exists z.\; a = (v, z) \land \mathit{set}(r, z, r)} \\
\specimp \\
\begin{array}{ll}
 \forall \psi. & \left<G(\phi \otimes \celleither{c}{\cmd} \otimes \psi)\right> \\
               & \readcell c \\
               & \left<a.\; 
                   \begin{array}{l}
                     G(R(\setof{c}, \phi') \otimes \cellpos{c}{\cmd}{v}{r} \otimes R(u \cup \setof{c}, \psi)) 
                      \;\land \\
                      \exists z.\;a = (v, z) \land \mathit{set}(\setof{c}, z, \setof{c})
                   \end{array}\right> 
\end{array}
\end{array}
\end{displaymath}
\end{prop*}

\begin{proof}
\begin{tabbedproof}
\oo Assume we have $\phi, \phi', c, \cmd, v, u, r$ \\
\oo Assume $\unready{\phi \otimes \celleither{c}{\cmd}}{c}$ \\
\oo Assume $\forall \psi.\; 
       \mspec{G(\phi \otimes \psi)}
            {\cmd}
            {a}{G(\phi' \otimes R(u, \psi)) \land \exists z.\; a = (v, z) \land \mathit{set}(r, z, r)} $ \\
\oo Assume we have some $\psi$ \\
\ooo Assume we are in a prestate $G(\phi \otimes \celleither{c}{\cmd} \otimes \psi)$ \\
\ooo So there is an $H = (D,h)$ such that $\mathit{Inv}(H, \phi \otimes \psi)$ holds \\
\ooo Hence we know that \\
\ooox $R^\dagger_H = O_H$ \\
\ooox $R^+_H$ strict partial order \\
\ooox $R_H \subseteq V_H \times V_H$ \\
\ooox $\mathit{unique}(H)$ \\
\ooox $H, D \models \phi \otimes \celleither{c}{\cmd} \otimes \psi$ \\
\ooox $\mathit{heap}(H)$ \\
\ooo Since $\mathsf{unready}$ is sound, we know that $\mathit{value}(h(c)) = \None$ \\
\ooo Hence we also know that $H, D \models \phi \otimes \cellneg{c}{\cmd} \otimes \psi$ \\
\ooo We also know that $c.\mathit{value} \pointsto \None$ \\
\ooo $[\letv{o}{!c.\mathit{value}}{}$ \\
\ooo Now we additionally know that $o = \None$ \\
\ooo Hence we can simplify the remaining program to eliminate the case expression \\
\ooo $\letv{\cmd'}{!a.code}{}$ \\
\ooo From the definition of $\mathit{heap}$, we know that $\cmd' = \mathit{code}(h(c))$ \\
\ooo From the fact that $H, D \models \phi \otimes \cellneg{c}{\cmd} \otimes \psi$, \\
\oox we know $\mathit{code}(h(c)) = \cmd$, so we will substitute $\cmd$ for $\cmd'$ in the sequel \\
\ooo $\letv{(v',z)}{\cmd}{}$ \\
\ooo Using our assumption about $\cmd$, and setting $\psi$ to $\cellneg{c}{\cmd} \otimes \psi$, \\
\ooo our poststate is $G(\phi' \otimes R(u, \cellneg{c}{\cmd} \otimes \psi)) \land v = v' \land \mathit{set}(r, z, r)$ \\
\ooo Simplifying away the $v'$, we get $\mathit{set}(r, z, r)$ and $G(\phi' \otimes \cellneg{c}{\cmd} \otimes R(u, \psi))$ \\
\ooo So our poststate is $\exists H. \mathit{Inv}(H, \phi' \otimes R(u, \cellneg{c}{\cmd} \otimes \psi))$ \\ 
\ooo We will shadow our original $H$, and bind a new $H = (D,h)$ to unpack the existential \\
\ooo so that we have $\mathit{Inv}((D, h), \phi' \otimes R(u, \cellneg{c}{\cmd} \otimes \psi))$ \\
\ooo Simplifying, we have $\mathit{Inv}((D, h), \phi' \otimes R(u, \psi) \otimes \cellneg{c}{\cmd})$ \\
\ooo Now take $H' = (D,h')$ and $h'$ as in the semantic update lemma \\
\ooo By the semantic update lemma, we have $H', D \models R(\setof{c}, \phi' \otimes R(u, \psi) \otimes \cellpos{c}{\cmd}{v}{r})$\\
\ooo So we know $H', D \models R(\setof{c}, \phi') \otimes \cellpos{c}{\cmd}{v}{r} \otimes R(u \cup \setof{c}, \psi))$ \\
\ooo Furthermore we know that this $H'$ preserves the relevant order structure \\
\ooo $\letv{\_}{[c.value := v']}{}$ \\
\ooo $\letv{\_}{[c.reads := z]}{}$ \\
\ooo $\letv{\_}{\mathsf{iterset}\;(\mathsf{add\_observer}\;a)\;z}{}$ \\
\ooo These commands establish $\mathit{heap}(H')$ \\
\ooo The last uses an induction on the size of $r$ and the unfolding axiom in the cellset interface \\
\ooo Now we know $\mathit{Inv}(H', R(\setof{c}, \phi') \otimes \cellpos{c}{\cmd}{v}{r} \otimes R(u \cup \setof{c}, \psi))$ \\
\ooo So we know $G(R(\setof{c}, \phi') \otimes \cellpos{c}{\cmd}{v}{r} \otimes R(u \cup \setof{c}, \psi))$ \\
\ooo $(v, \mathsf{singleton}\;c)]$ \\
\ooo Since $\mathit{set}(\setof{c}, \mathsf{singleton}\;c, \setof{c})$, we can
     take $\mathsf{singleton}\;c$ as a witness to conclude \\
\ooo $G(R(\setof{c}, \phi') \otimes \cellpos{c}{\cmd}{v}{r} \otimes R(u \cup \setof{c}, \psi)) \land \exists z.\;a = (v,z) \land \mathit{set}(\setof{c}, z, \setof{c})$ 
\end{tabbedproof}
\end{proof}

\subsection{Proving the correctness of \textsc{AConseq}}



\begin{prop*}{(The correctness of the \textsc{AConseq} specification)}
The following specification is valid:
\begin{displaymath}
\begin{array}{l}
\setof{\phi' \vdash \phi} \specand \setof{\theta \vdash \theta'} \specand \\
\forall \psi.\; \mspec{G(\phi \otimes \psi) \land P}{\cmd}{(x,z)}{G(\theta\otimes R(u, \psi)) \land Q} \\
\specimp \\
\forall \psi.\; \mspec{G(\phi' \otimes \psi) \land P}{\cmd}{(x,z)}{G(\theta'\otimes R(u, \psi)) \land Q}  \\
\end{array}
\end{displaymath}
\end{prop*}

\begin{proof}
\begin{tabbedproof}
\oo Assume we know $\phi' \vdash \phi$ and $\psi \vdash \psi'$ \\
\oo Furthermore assume $\forall \psi.\; \spec{G(\phi \otimes \psi) \land P}{\cmd}{(x,z)}{G(\theta\otimes R(u, \psi)) \land Q}$ \\
\ooo Now assume $\psi$, and that we are in a prestate $G(\phi' \otimes \psi) \land P$ \\
\ooo So we know there is an $H$ such that $\mathit{Inv}(H, \phi' \otimes \psi)$ \\
\ooo Since $\phi' \vdash \phi$, we know that $H, D \models \phi \otimes \psi$ \\
\ooo Hiding the existential again, we know that $G(\phi \otimes \psi) \land P$ \\
\ooo $\cmd$ \\
\ooo Now by assumption we know $G(\theta \otimes R(u, \psi)) \land Q$ \\
\ooo So we know there is an $H$ such that $\mathit{Inv}(H, \theta \otimes \psi)$ \\
\ooo Since $\theta \vdash \theta'$, we know that $\mathit{Inv}(H, \theta' \otimes \psi)$ \\
\ooo Hiding the existential, we get the poststate $G(\theta'\otimes R(u, \psi)) \land Q$ \\
\end{tabbedproof}
\end{proof}

\subsection{Proving the correctness of \textsc{AGetRef}}


\begin{prop*}
The following specification is valid: 
\begin{displaymath}
\begin{array}{ll}
    \forall \psi.\; 
    &  \left<G(\localref{r}{v} \otimes \psi)\right> \\
    &  \getref r \\
    &  \left<a.\; G(\localref{r}{v} \otimes \psi) 
                  \land  \exists z.\;a = (v,z) \land \mathit{set}(\emptyset, z, \emptyset)
       \right> \\
     \end{array}
\end{displaymath}
\end{prop*}
\begin{proof}
\begin{tabbedproof}
\oo Assume we are in a prestate $G(\localref{r}{v} \otimes \psi)$ \\
\oo So there is an $H = (D,h)$ such that $Inv(H, \localref{r}{v} \otimes \psi)$ holds \\
\oo The spatial part of $Inv$ is $heap(H) * \mathit{refs}(\localref{r}{v} \otimes \psi)$ \\
\oo This is the same as $heap(H) * {r}\pointsto{v} * \mathit{refs}(\psi)$ \\
\oo $[\letv{x}{[!r]}{}$ \\
\oo This leaves us in $Inv(H, \localref{r}{v} \otimes \psi) \land x = v$ \\
\oo $\pair{v}{\ctext{emptyset}}]$ \\
\oo We can now conclude \\
\oo $G(\localref{r}{v} \otimes \psi) \land a = \pair{v}{\ctext{emptyset}}$ \\
\end{tabbedproof}
\end{proof}

\subsection{Proving the correctness of \textsc{ASetRef}}

We first note a useful property:

\begin{lemma}{(Preservation of Satisfiability under Local Store Changes)}
We have that $H, D \models \localref{r}{v} \otimes \psi$ if and only if $H, D \models \localref{r}{v'} \otimes \psi$ 
\end{lemma}
\begin{proof}
This follows by an easy induction on $\psi$, since $sat(H, D, \localref{r}{v}) = \top$. 
\end{proof}

\ \\

\noindent Now, we can proceed to the statement and proof of reading and writing
local references. 

\ \\


\begin{prop*}
The following specification is valid:
\begin{displaymath}
\begin{array}{ll}
\forall \psi.\; 
  &    \left<G(\localref{r}{v'} \otimes \psi)\right> \\
  &    \setref r\;v \\
  &    \left<a.\; G(\localref{r}{v} \otimes \psi) 
                  \land  \exists z.\;a = (v,z) \land \mathit{set}(\emptyset, z, \emptyset)
       \right> 
\end{array}
\end{displaymath}
\end{prop*}

\begin{proof}
\begin{tabbedproof}
\oo Assume we are in a prestate $G(\localref{r}{v'} \otimes \psi)$ \\
\oo Then there is an $H = (D,h)$ such that $R^\dagger_H$ and  $R^+_H$ is a strict partial order, \\
\oo and $R_H \subseteq V_H \times V_H$ and $\mathit{unique}(H)$ and $H, D \models \localref{r}{v'} \otimes \phi$ \\
\oo and $\mathit{heap}(H) * \mathit{refs}(\localref{r}{v'} \otimes \phi)$\\
\oo The spatial part is equivalent to $\mathit{heap}(H) * r \pointsto v' * \mathit{refs}(\phi)$ \\
\oo $[\letv{()}{[r := v]}{}$ \\
\oo Hence $\mathit{heap}(H) * r \pointsto v * \mathit{refs}(\phi)$ \\
\oo Hence $\mathit{heap}(H) * \mathit{refs}(\localref{r}{v} \otimes \phi)$ \\
\oo By lemma, $H, D \models \localref{r}{v} \otimes \phi$ \\
\oo Hence $Inv(H, \localref{r}{v} \otimes \phi)$ \\
\oo Hence $G(\localref{r}{v} \otimes \phi)$ \\
\oo $\pair{\unit}{\ctext{emptyset}}]$ \\
\oo Hence $G(\localref{r}{v} \otimes \phi) \land a = \pair{\unit}{\ctext{emptyset}}$ \\
\oo Hence $G(\localref{r}{v} \otimes \phi) \land \exists z.\; \pair{\unit}{z} \land \mathsf{set}(\emptyset, \ctext{emptyset}, \emptyset)$ \\
\end{tabbedproof}
\end{proof}

\section{Implementing Functional Reactive Programming}

In this section, we will see how to verify an imperative
implementation of a simple synchronous functional reactive programming
system.

\subsection{Specifying Functional Reactive Programs}

\emph{Functional Reactive Programming}~\cite{frp} is a style of
writing interactive programs based on the idea of \emph{stream
  transducers}.  The idea is to model a time-varying input signal of
type $A$ as an infinite stream of $A$'s, and to model an interactive
system as a function that takes a stream of inputs $\stream{A}$ and
yields a stream of outputs $\stream{B}$. Note that a stream can be
viewed either as an infinite sequence of values, or isomorphically as
a function from natural numbers to values (i.e., a function from times
to values). In our discussion, we will switch freely between these two
views, using the most convenient viewpoint.\footnote{Given an infinite stream $vs$, we will use use $take\;n\;vs$ to denote
the finite list consisting of the first $n$ elements of the stream
$vs$. Correspondingly, $drop\;n\;vs$ is the infinite stream with $vs$
with its first $n$ elements cut off. With a function $f$, $map\;f\;vs$
maps $f$ over the elements of $vs$, and given another infinite stream
$us$, the call $zip\;us\;vs$ returns the infinite stream of pairs of
elements of $us$ and $vs$. If $v$ is an element, $v \cdot vs$ will 
denote consing $v$ to the front of $vs$, and if $xs$ is a finite list, then
$xs \cdot vs$ will denote appending the finite sequence $xs$ to the
front of $vs$. Finally, we will write $vs_n$ to denote the $n$-th element
of the stream $vs$.}

However, not all functions $\stream{A} \to \stream{B}$ are legitimate
stream transducers; we need to restrict our attention to \emph{causal}
stream transducers. A transducer is causal if we can compute the first
$n$ elements of the output after having read at most $n$ elements of
the input. 

\begin{tabbing}
$causal(f : \stream{A} \to \stream{B}) \equiv$ \\
\;\;\= $\exists \hat{f} : \listtype{A} \to \listtype{B}.\;\forall as:\stream{A}, n:\N.$ \\
    \> \;\;$take\;n\;(f\;as) = \hat{f}\;(take\;n\;as)$ 
\end{tabbing}

If we are given a causal transducer $p$, we will write $\hat{p}$ to
indicate the corresponding list function which computes its finite
approximations. Then, we can define a family of combinators acting on
causal transducers, which we give in Figure~\ref{transducer-semantics}.

\begin{figure}
\mbox{}
\begin{tabbing}
$\ST{A}{B} = \comprehend{f \in \stream{A} \to \stream{B}}{\mathit{causal}(f)}$\\[1em]

$\mathit{lift} : (A \to B) \to \ST{A}{B}$ \\
$\mathit{lift}\;f\;as = \mathit{map}\;f\;as$ \\[1em]

$\mathit{seq}  : \ST{A}{B} \to \ST{B}{C} \to \ST{A}{C}$ \\
$\mathit{seq}\;p\;q = q \circ p$ \\[1em]

$\mathit{pair}  : \ST{A}{B} \to \ST{A}{C} \to \ST{A}{B \times C}$ \\
$\mathit{pair}\; p\;q\;as = \mathit{zip}\; (p\;\;as)\;(q\;as)$\\[1em]

$\mathit{switch} : \N \to \ST{A}{B} \to \ST{A}{B} \to \ST{A}{B}$ \\
$\mathit{switch}\;k\;p\;q = \semfun{as}{(\mathit{take}\;k\;(p\;as))\cdot(q\;(\mathit{drop}\;k\;as))}$ \\[1em]

$\mathit{loop} : A \to \ST{A\times B}{A \times C} \to \ST{B}{C}$ \\
$\mathit{loop}\;a_0\;p = (\mathit{map}\;\pi_2) \circ (\mathit{cycle}\;a_0\;p)$ \\[1em]

$\mathit{cycle} : A \to \ST{A\times B}{A \times C} \to \ST{B}{A \times C}$ \\
$\mathit{cycle}\;a_0\;p = \lambda bs.\;\lambda n.\;last(gen\;a_0\;p\;v\;n)$ \\[1em]

$\mathit{gen} : A \to \ST{A\times B}{A \times C} \to \listtype{(A \times C)}$\\
$\mathit{gen}\;a_0\;p\;bs\;0 \qquad\;\; = \hat{p}\; [(a_0, bs_0)]$ \\
$\mathit{gen}\;a_0\;p\;bs\;(n+1) = \hat{p}\;(\mathit{zip} \;(a_0 \cdot (\mathit{map}\;\pi_1\;(\mathit{gen}\;a_0\;p\;bs\;n)))\;
                                        (\mathit{take}\;(n+2)\;bs))$ 
\end{tabbing}
\caption{Semantics of Stream Transducers}
\label{transducer-semantics}
\end{figure}

The operation $\mathit{lift}\;f$ creates a stream transducer that simply maps
the function $f$ over its input. Calls to $\mathit{seq}\;p\;q$ are sequential
composition: it feeds the output of $p$ into the input of $q$. The
operator $\mathit{pair}\;p\;q$ defines a fanout operation --- it takes a stream
of values, and applies the stream to both of its arguments, and then
merges the two output streams to produce a stream of pairs. The
function $\mathit{switch}\;k\;p\;q$ is a very simple ``switching combinator''.
It behaves as if it were $p$ for the first $k$ time steps, and then
behaves as if it were $q$, only starting with the input stream
beginning at time $k$.

The combinator $\mathit{loop}\;a_0\;p$ is a feedback operation. It acts
upon a transducer $p$ which takes pairs of $A$s and $B$s, and yields
pairs of $A$s and $C$s. It turns it into a combinator that takes $B$s
to $C$s, by giving $p$ the value $a_0$ (and its $B$-input) on the
first time step, and uses the output $A$ at time $n$ as the input $A$
at time $n+1$. This is useful for constructing transducers that do
things like sum their inputs over time, and other stateful operations. 

Because this function involves feedback, it should not be surprising
that it makes use of the causal nature of its argument operation. The
$\mathit{loop}$ function is defined in terms of $\mathit{cycle}$, which also returns the
sequence of output $A$s, and $\mathit{cycle}$ is defined in terms of $\mathit{gen}$,
which is a function that given an argument $n$ returns a list of
outputs for the time steps from $0$ to $n$. Notice that
$\mathit{gen}\;a_0\;p\;bs\;n$ will always return $n+1$ elements (e.g., at
argument 0, it will return a 1 element list containing the output at
time step 0), which means that the call to $\mathit{last}$ in $\mathit{cycle}$ is
actually safe. In order to calculate $\mathit{gen}$, we need to recursively
calculate the outputs for all smaller time steps, and this is what
$\hat{p}$ is needed for --- it is what lets us know that $p$ has a good
finite approximation.

All of these definitions are familiar to functional programmers, and
there are many techniques to prove properties of these functions ---
coinductive proofs, the $\mathit{take}$-lemma of \citet{bird-wadler}, arguments based on
the isomorphism between streams and functions from natural
numbers. All of these serve to make proving properties about stream
transducers very pleasant. For example, one property we will need in
the next section is the following:

\begin{lemma}{(Loop Unrolling)} We have that 
  \begin{displaymath}
    cycle\;a_0\;p\;bs = f\;(zip\;(a_0\cdot(map\;\pi_1\;(cycle\;a_0\;p\;bs)))\;bs)
  \end{displaymath}
\end{lemma}

\begin{proof}
  This is easily proved using Bird and Wadler's $take$-lemma, which
  says that two streams are equal if all their finite prefixes are
  equal.
\end{proof}


\subsection{Realizing Stream Transducers with Notifications}

\begin{figure}
\mbox{}
\begin{tabbing}
$\ST{\alpha}{\beta} \equiv \celltype{\alpha} \to \monad{\celltype{\beta}}$ \\[1em]

$\liftop : \forall \alpha,\beta:\star.\; (\alpha \to \beta) \to \ST{\alpha}{\beta}$ \\
$\liftop\;f\;input = $ \\
\;\; $\newcell\; (\bind\;(\readcell input)\; (\fun{x}{\alpha}{\return (f\;x)}))$ \\[1em]

$\composeop : \forall \alpha,\beta,\gamma:\star.\; \ST{\alpha}{\beta} \to \ST{\beta}{\gamma} \to \ST{\alpha}{\gamma}$ \\
$\composeop p\;q\;input = [$\=$\letv{middle}{p\;input}$ \\
                            \>$\letv{output}{q\;middle}$ \\ 
                            \>$\;output]$ \\[1em]

$\pairop : \forall \alpha,\beta,\gamma:\star.\; \ST{\alpha}{\beta} \to \ST{\alpha}{\gamma} \to \ST{\alpha}{\beta \times \gamma}$ \\
$\pairop p \; q \; \mathit{input} = $ \\
\;\;$[$\=$\letv{bs}{p\;\mathit{input}}{}$ \\
     \>$\letv{cs}{q\;\mathit{input}}{} $ \\
     \>$\ctext{letv}\;output = \newcell ($\=$\bind (\readcell bs)\; (\lambda b:\beta.$ \\
     \>                                   \>$\bind (\readcell cs)\; (\lambda c:\delta.$ \\
     \>                                   \>$\;\;\return \pair{b}{c})))] \;\ctext{in}$ \\
     \>$\;output]$ \\[1em]

$\switchop : \forall \alpha,\beta:\star.\; \N \to \ST{\alpha}{\beta} \to \ST{\alpha}{\beta} \to \ST{\alpha}{\beta}$ \\
$\switchop k\;p\;q\; input =  $ \\
\;\;$[$\=$\letv{r}{\newref{\N}{0}}{}$ \\
    \>$\letv{a}{p\;input}$ \\
    \>$\letv{b}{p\;input}$ \\
    \>$\ctext{letv}\; out = \newcell\; ($\=$\bind (\getref r) \;(\lambda i:\N.\;$ \\
    \>                                 \>$\bind (\setref r\;(i+1)) \; (\lambda q:\unittype.$ \\
    \>                                 \>$\;\;\ctext{if}(i < k, \readcell a, \readcell b)))) \;\ctext{in}$ \\
    \>$\;\;out]$\\[1em]

$\loopop : \forall \alpha,\beta,\gamma:\star.\; \alpha \to \ST{\alpha\times \beta}{\alpha\times \gamma} \to \ST{\beta}{\gamma}$ \\
$\loopop a_0\; p \; input = $ \\
\;\;$[$\=$\letv{r}{\newref{\alpha}{a_0}}{}$ \\
    \>$\ctext{letv}\; ab = \newcell\; ($\=$\bind (\readcell input)\; (\lambda b:\beta.$ \\
    \>                                \>$\bind (\getref r)\;       (\lambda a:\alpha.$ \\
    \>                                \>$\;\; \return \pair{a}{b}))) \;\ctext{in}$ \\
    \>$\letv{ac}{p\;ab}{}$ \\
    \>$\ctext{letv}\;c = \newcell\; ($\=$\bind (\readcell ac) \;(\lambda v:\alpha \times \gamma.$ \\
    \>                              \>$\bind (\setref r\;(\fst{v})) \;(\lambda q:\unittype.$ \\
    \>                              \>$\;\;\return (\snd{v}))))\;\ctext{in}$ \\
    \>$\;\;c]$ 
\end{tabbing}
\caption{Imperative Stream Transducers}
\label{imperative-transducer-impl}
\end{figure}

While the definitions in the previous subsection yield very clean
proofs, they are not suitable as implementations --- for example,
$loop$ recomputes an entire history at each time step! We can derive
better implementations by thinking about how imperative, event-driven
programming works.

The intuition underlying event-driven programming is that a stream
transducer is implemented with the combination of a notification
network, and an \emph{event loop}.  The event loop is a
(possibly-infinite) loop which updates an input cell at teach time
step, to reflect the events that occurred on that time step, and then
it reads the output cell of the network. When the input cell is
updated, invalidations are propagated throughout the dependency
network, and when the outputs are read, exactly the necessary
re-computations are performed.

We will shortly formalize exactly this idea, but we will first discuss
the implementation given in
Figure~\ref{imperative-transducer-impl} in informal terms. Here,
we define the type of imperative stream transducers as a function type
$\celltype{A} \to \monad{(\celltype{B})}$. This type should be read as
saying that the implementation is a function that, given an input cell
of type $A$, will \emph{construct} a dataflow notification network
realizing the corresponding transducer, and whose return value is the
output cell of type $B$ that the event loop should read. 

The simplest example of this is $\liftop\;f$. It will take an input
cell $input$, and build a new cell which reads $input$, and return $f$
applied to that value. Likewise, given two imperative implementations $p$
and $q$, $\composeop\;p\;q$ will take an input cell, and feed the
input to $p$ to build a network whose output is named $middle$, and
will then give $middle$ to $q$ to get the final output cell. The
overall network will be network built by the calls to both $p$ and
$q$, which interact through $p$'s network putting a value in $middle$,
and $q$'s network reading it.

The operation $\switchop\;k\;p\;q$ is the first example that uses 
local state. Given an $input$ cell, we first build networks corresponding
to $p$ and to $q$ (with outputs $a$ and $b$, respectively). Then we
create a local reference $r$, initialized to $0$. Then we build a cell $out$,
whose code reads and increments $r$, and which will read $a$ or $b$ depending
on whether the reference's contents are less than or equal to $k$. Notice
that the demand-driven nature of evaluation means that we never redundantly
evaluate $p$ or $q$'s networks --- we only ever execute one of them. 

Finally, the operation $\loopop a_0\;p$ builds a feedback network by
explicitly creating a reference to hold an accumulator parameter. It
constructs a local reference initialized to $a_0$, and then constructs
a cell $ab$ which reads the input and the local reference to produce a
pair of type $A \times B$. This cell is given to $p$, to construct a
network with an output cell $ac$, yielding pairs of type $A \times
C$. Finally, we construct the overall output cell $c$, which reads
$ac$ and updates the local reference with a new value of type $A$, and
returns a value of type $C$. The use of a local reference (rather than
a cell) to store the current state of $A$ is essential, because we need
to maintain the acyclicity of the dataflow graph. 

\subsection{Formally Specifying Transducers}

In Figure~\ref{transducer-specification}, we give the predicates we
use to specify our stream transducer library. 

Since transducers are stream transformers, our specification begins
with a specification of how a dataflow network may realize a
stream. The predicate $\Stream(i, vs, I, O, U)$ is a five-place
predicate saying that the cell value $i$ realizes the stream of values
$vs$; $I$ and $O$ are functions in $\N \to \formula$ that give the
input and output state of the stream at each time step; and $U$ is a
function in $\N \to \powersetfin{\ecell}$ which gives the ramification
of reading $i$ at each time step.

The first five lines of the definition of $\Stream$ are housekeeping
conditions on the arguments -- $i$ must always be in the state of
$I_n$, the domains of $I_n$ and $O_n$ must agree, and the cells the
state formula may depend on are bounded to $I_n$ and $O_n$
respectively, and the ramification $U_n$ must be bounded by the cells
in $I_n$. The final condition states that if we read the cell $i$ at
time $n$, in state $I_n$, then we get a return value $vs_n$ which is
the $n$-th element of the stream, and update the state to the $n$-th
output state $O_n$, with a ramification of $U_n$. 

There are two features of this specification worth calling specific
attention to. First, we do not reading a stream to alter the set of
stream cells in its footprint --- we require $I_n = O_n$.  We will use
this to capture the intuition in the work on arrowized FRP that space
leaks can be ruled out by a transducer-based implementation.  Second,
we deliberately do not add any conditions relating the output state at
time $n$ to the input state at time $n+1$. The reason is that such a
relation might not exist! For example, we might wish to allow an event
loop to update a cell as new events arrive. 

We give the definition of $\Transducer(i, o, f, \phi, \phi', U')$ on
lines 9-12 of Figure~\ref{transducer-specification}. Here, $i$ is an
input cell, $o$ is an output cell, and $f$ is a stream transducer.
This says that values coming in on the input cell $i$ are transduced
according to $f$ into values going out on the output cell $o$. As with
the \Stream\ predicate, we give functions $\phi, \phi' :
\mathsf{stream}(A) \to \N \to \formula$ giving, at each timestep, the
state of the transducer before and after $o$ has been read, along with
a function $U : \N \to \powersetfin{\ecell}$ which gives the
ramification for reading $o$. (As compared to the $\Stream$ predicate,
the $\phi$ and $\phi'$ functions are parameterized so that we can
mention the values of the input stream in the post-state formula.)

On line 10, we require that the initial state $(\phi\;vs)_n$ always make $o$
unready at each timestep $n$. This requirement is necessary since the
implementations of $\switchop$ and $\loopop$ use local state, and so
they must be evaluated at each timestep in order to produce the
correct value. Then, on line 11, we require that $R(\setof{i},
(\phi'\;vs)_n) = (\phi\;vs)_{n+1}$.  This says that the the pre-state at time
$n+1$ is equivalent to the post-state at time $n$, after the
post-state sees the ramification of updating the input cell $i$.

Then, on line 12, we assert that for any $vs, I, O$ and $U$, if
$\Stream(i, vs, I, O, U)$ is satisfied, then $\Stream(o, f vs, I
\otimes (\phi\;vs), O \otimes (\phi'\;vs), U \cup U')$ is satisfied (where we lift
$\otimes$ and $\cup$ pointwise). This gives the sense in which 
we can view this pair of cells as a transducer. 

Finally, on lines 13 and 14, we define the $\Realize(\ctext{p}, f)$
predicate, which says that $\ctext{p}$ realizes $f$, if executing
$\ctext{p}$ with an input $i$ constructs structure which work as a
transducer for $f$.

\begin{figure}
\begin{specification}
\nextline $\Stream(i, vs, I, O, U) \triangleq$ 
\nextline \qquad 
          \= $\forall n.\; i \in \domain{I_n} \specand$ 
\nextline \> $\forall n.\; \domain{I_n} = \domain{O_n} \specand$ 
\nextline \> $\forall n.\; \closed{I_n}{\domain{I_n}} \specand$
\nextline \> $\forall n.\; \closed{O_n}{\domain{O_n}} \specand$
\nextline \> $\forall n.\; U(n) \subseteq \domain{I_n} \specand$ 
\nextline \> $\forall n.\; \ready{O_n}{i}{vs_n} \specand$ 
\nextline \> $\forall n, \psi.\; \mspec{ G(I_n \otimes \psi) }{\readcell\;i}{a}{a = \pair{vs_n}{\setof{i}} \land G(O_n \otimes R(U_n, \psi)) }$ 
\\
\nextline $\Transducer(i, o, f, \phi, \phi', U') \triangleq$ 
\nextline \qquad 
          \= $\forall n, vs.\; \unready{(\phi\;vs)_n}{o} \specand$ 
\nextline \> $\forall n, vs.\; R(\setof{i}, (\phi'\;vs)_n) \dashv\vdash (\phi\;vs)_{n+1} \specand$
\nextline \> $\forall n, vs.\; o \in \domain{(\phi\;vs)_n} \specand $ 
\nextline \> $\forall n, vs.\; \closed{(\phi\;vs)_n}{\domain{(\phi\;vs)_n}} \specand$ 
\nextline \> $\forall n, vs.\; \closed{(\phi'\;vs)_n}{\domain{(\phi'\;vs)_n} \cup \setof{i}} \specand$ 

\nextline \> $\forall vs, I, O, U.\; \Stream(i, vs, I, O, U) \specimp \Stream(o, f\;vs, I \otimes \phi, O \otimes (\phi'\;vs), U \cup U')$
\\
\nextline $\Realize(\mathsf{f}, \mathit{f}) \triangleq$ 
\nextline \qquad 
          \= $\forall \psi, i.\;\mspec{ G(\psi) }
                                      {\mathsf{f}\;i}
                                      {a}{\exists \phi, \phi',  U'.\; G(\psi \otimes \phi_0) \land \Transducer(i, a, f, \phi, \phi', U')\;}$
\end{specification}  
\caption{Specifications of Stream Transducers}
\label{transducer-specification}
\end{figure}


\subsection{Correctness Proofs}

Our goal is to prove the following theorems:

\begin{prop}{(FRP Correctness)}
The following specifications are provable: 
\begin{enumerate}
\item $\forall f:A\to B.\; \mathit{Realize}(\liftop f, \mathit{lift}\;f)$
\item $\forall \ctext{p}, f, \ctext{q}, g.\;\mathit{Realize}(\ctext{p}, f) \specand \mathit{Realize}(\ctext{q}, g) \specimp \mathit{Realize}(\composeop \ctext{p\;q}, \mathit{compose}\;f\;g)$
\item $\forall \ctext{p}, f, \ctext{q}, g.\;\mathit{Realize}(\ctext{p}, f) \specand \mathit{Realize}(\ctext{q}, g)
                       \specimp \mathit{Realize}(\pairop \ctext{p\;q}, pair\;f\;g)$
\item $\forall k, \ctext{p}, f, \ctext{q}, g.\;\mathit{Realize}(\ctext{p}, f) \specand \mathit{Realize}(\ctext{q}, g)
                          \specimp \mathit{Realize}(\switchop k\;\ctext{p\;q}, switch\;k\;f\;g)$
\item $\forall a_0, \ctext{p}, f.\; \mathit{Realize}(\ctext{p}, f) \specimp \mathit{Realize}(\loopop\;a_0\;\ctext{p}, loop\;a_0\;f)$
\end{enumerate}
\end{prop}

\noindent In order to do this, we will first prove a sequence of
lemmas asserting that the structures our operations in
Figure~\ref{imperative-transducer-impl} construct are actually transducers. 

\subsubsection{Correctness of $\liftop$}

\begin{lemma}{(The $\ctext{lift}$ network)}
If we have that 
\begin{itemize}
\item $\phi = \semfun{vs\;n}{\cellneg{o}{e}}$ 
\item $\phi' = \semfun{vs\;n}{\cellpos{o}{e}{f\;vs_n}{\setof{i}}}$ 
\item $U = \semfun{n}{\setof{i}}$
\item $e = \bind (\readcell i)\; (\semfun{v}{\return (f\;v)})$
\end{itemize}
then it follows that $\Transducer(i, o, \mathit{lift}\;f, \phi, \phi', U')$. 
\end{lemma}
\begin{proof}
\begin{enumerate}
\item $\forall n, vs.\; \unready{(\phi\;vs)_n}{o}$.

  This is immediate, since $(\phi\;vs)_n = \cellneg{o}{e}$ 

\item $\forall n, vs.\; R(\setof{i}, (\phi'\;vs)_n) \dashv\vdash (\phi\;vs)_{n+1}$
  
  Assume $n$ and $vs$, and observe that $(\phi'\;vs)_n = \cellpos{o}{e}{f\;vs_n}{\setof{i}}$. Then,
  \begin{displaymath}
  \begin{array}{lcl}
    R(\setof{i}, (\phi'\;vs)_n) & = & R(\setof{i}, \cellpos{o}{e}{f\;vs_n}{\setof{i}}) \\
                                & = & \cellneg{o}{e} \\
                                & = & (\phi\;vs)_{n+1}
  \end{array}
  \end{displaymath}

\item $\forall n, vs.\; o \in \domain{(\phi\;vs)_n}$

  Immediate, since $(\phi\;vs)_n = \cellneg{o}{e}$

\item $\forall n, vs.\; \closed{(\phi\;vs)_n}{\domain{(\phi\;vs)_n}} \specand$ 

  Assume $n$ and $vs$, and observe that $(\phi\;vs)_n = \cellneg{o}{e}$. Hence it 
  is closed with respect to $\emptyset$, and hence closed with respect to $\domain{(\phi\;vs)_n}$. 

\item $\forall n, vs.\; \closed{(\phi'\;vs)_n}{\domain{(\phi'\;vs)_n \cup \setof{i}}}$ 

  Assume $n$ and $vs$, and observe that $(\phi'\;vs)_n = \cellpos{o}{e}{f\;vs_n}{\setof{i}}$. Then,
  the result is immediate. 

\item $\forall vs, I, O, U.\; \Stream(i, vs, I, O, U) \specimp \Stream(o, \mathit{lift}\;f\;vs, I \otimes \phi, O \otimes \phi', U \cup U')$
  \begin{tabbedproof}
  \oo Assume we have $vs, I, O$, and $U$, and that $\Stream(i, vs, I, O, U)$ holds. \\
  \oo Now, we want to show $\Stream(o, f\;vs, I \otimes \phi, O \otimes \phi', U \cup U')$ \\
  \\ \oo 1. We want for all $n$, that $o \in \domain{I_n \otimes (\phi\;vs)_n}$ \\
  \ooo This is immediate, since $(\phi\;vs)_n = \cellneg{o}{e}$ \\
  \\ \oo 2. We want for all $n$, that $\domain{I_n \otimes (\phi\;vs)_n} = \domain{O_n \otimes (\phi'\;vs)_n}$ \\
  \ooo By the $\Stream(i, vs, I, O, U)$ hypothesis, we know $\domain{I_n} = \domain{O_n}$ \\
  \ooo Since $(\phi\;vs)_n = \cellneg{o}{e}$ and $\phi' = \semfun{n}{\cellpos{o}{e}{f\;vs_n}{\setof{i}}}$, we know \\
  \oox that $\domain{(\phi\;vs)_n} = \domain{(\phi'\;vs)_n} = \setof{o}$ \\
  \ooo Hence $\domain{I_n \otimes (\phi\;vs)_n} = \domain{O_n \otimes (\phi'\;vs)_n} = \domain{I_n} \cup \setof{o}$  \\
  \\ \oo 3. We want for all $n$, that $\closed{I_n \otimes (\phi\;vs)_n}{\domain{I_n \otimes (\phi\;vs)_n}}$\\
  \ooo Since $(\phi\;vs)_n = \cellneg{c}{e}$, it is closed with respect to any set. \\
  \ooo All the other cells are in $I_n$, which are all closed with respect to $\domain{I_n}$, \\
  \oox and hence $\domain{I_n \otimes (\phi\;vs)_n}$. \\
  \\ \oo 4. We want for all $n$, that $\closed{O_n \otimes (\phi'\;vs)_n}{\domain{O_n \otimes (\phi'\;vs)_n}}$\\
  \ooo We know $(\phi'\;vs)_n = \cellpos{o}{e}{vs_n}{\setof{i}}$. \\
  \ooo Since $i \in \domain{O_n}$, we know $\closed{(\phi'\;vs)_n}{\domain{O_n} \otimes (\phi'\;vs)_n}$ \\
  \ooo All the other cells are in $O_n$, which are all closed with respect to $\domain{O_n}$, \\
  \oox and hence $\domain{O_n \otimes (\phi'\;vs)_n}$  \\
  \\ \oo 5. We want for all $n$, that $U_n \subseteq \domain{I_n}$ \\
  \ooo We know $U_n = \setof{i}$, and $i \in \domain{I_n}$, so $U_n \subseteq I_n$ \\
  \\ \oo 6. We want for all $n$, that $\ready{O_n \otimes (\phi'\;vs)_n}{o}{(\mathit{lift}\;f\;vs)_n}$ \\
  \ooo We know that $(\phi'\;vs)_n = \cellpos{o}{e}{f\;vs_n}{\setof{i}}$. \\
  \ooo Since we know that $\ready{O_n}{i}{vs_n}$, we know that $\ready{O_n \otimes (\phi'\;vs)_n}{o}{f\;vs_n}$ \\
  \ooo Since $f\;vs_n = (\mathit{lift}\;f\;vs)_n$, we know $\ready{O_n \otimes (\phi'\;vs)_n}{o}{(\mathit{lift}\;f\;vs)_n}$ \\

  \\ \oo 7. We want $\forall n, \psi.\; \spec{G(I_n \otimes (\phi\;vs)_n \otimes \psi)}{\readcell\;i}{a}{a = \pair{f\;vs_n}{\setof{o}} \land G(O_n \otimes (\phi'\;vs)_n \otimes R(U_n, \psi))}$ \\
  \ooo Assume $n$ and $\psi$. \\
  \ooo Since we know $\unready{(\phi\;vs)_n}{o}$, we need to use the $\AUnready$ spec. \\
  \ooo So, we can take our state to be $G(I_n \otimes \psi)$, and evaluate $e$ \\
  \ooo using the $\ABind$ and $\AUnit$ rules, together with \\
  \ooo the $\readcell\;i$ hypothesis in the $\Stream(i, vs, I, O, U)$ assumptions \\
  \ooo Reading $i$ gives us the state $G(O_n \otimes R(U_n, \psi))$ and a return value $\pair{vs_n}{\setof{i}}$ \\ 
  \ooo The $\AUnit$ rule keeps the state $G(O_n \otimes R(U_n, \psi))$ and returns $\pair{f\;vs_n}{\emptyset}$ \\
  \ooo Hence $e$ takes $G(O_n \otimes R(U_n, \psi))$ to $G(O_n \otimes R(U_n, \psi))$, returning $\pair{f\;vs_n}{\setof{i}}$ \\
  \ooo Hence $\AUnready$ tells us the poststate is $G(\cellpos{o}{e}{f\;vs_n}{\setof{i}} \otimes R(\setof{o}, O_n \otimes R(U_n, \psi)))$, \\
  \ooo together with a return value of $\pair{f\;vs_n}{\setof{o}}$ \\ 
  \ooo However, since $o \not\in \domain{O_n}$ and $\closed{O_n}{\domain{O_n}}$, the poststate is equivalent to \\
  \ooo $G(\cellpos{o}{e}{f\;vs_n}{\setof{i}} \otimes O_n \otimes R(U_n \cup \setof{o}, \psi)))$, \\
  \ooo This is equivalent to  \\
  \ooo $G(O_n \otimes (\phi'\;vs)_n \otimes R(U_n \cup U'_n, \psi)))$  \\
  \ooo and we have a return value equal to $\pair{f\;vs_n}{\setof{o}}$ \\
  \ooo Since $f\;vs_n = (\mathit{lift}\;f\;vs)_n$, we are done

  \end{tabbedproof}
\end{enumerate}
\end{proof}

\subsubsection{The $\composeop$transducer}

\begin{lemma}{(The $\ctext{composeop}$ network)}
If we have that $\Transducer(i, m, f, \sigma, \sigma', U')$ and $\Transducer(m, o, \theta, \theta', U'')$, 
then it follows that $\Transducer(i, o, \mathit{compose}\;f\;g, \phi, \phi', U' \cup U'')$, where $\phi = \sigma \otimes \theta$
and $\phi'\;vs = \sigma'\;vs \otimes \theta'\;(f\;vs)$. 
\end{lemma}

\begin{proof}
Assume have that $\Transducer(i, m, f, \sigma, \sigma', U')$ and $\Transducer(m, o, \theta, \theta', U'')$. 
\begin{enumerate}
\item $\forall n, vs.\; \unready{(\phi\;vs)_n}{o}$.

  \begin{tabbedproof}
    \oo We want to show that $\unready{(\sigma\;vs)_n \otimes (\theta\;vs)_n}{o}$. \\
    \oo This follows immediately since $\unready{(\theta\;vs)_n}{o}$.
  \end{tabbedproof}

\item $\forall n, vs.\; R(\setof{i}, (\phi'\;vs)_n) \dashv\vdash (\phi\;vs)_{n+1}$

  Observe that:
  \begin{displaymath}
    \begin{array}{lcll}
      R(\setof{i}, (\phi'\;vs)_n) & = & R(\setof{i}, (\sigma'\;vs)_n \otimes (\theta'\;(f\;vs))_n) 
                            & \\
                            & = & R(\setof{i}, (\sigma'\;vs)_n) \otimes R(\setof{i}, (\theta'\;(f\;vs))_n) 
                            & \\
                            & \dashv\vdash & (\sigma\;vs)_{n+1} \otimes R(\setof{i}, (\theta'\;(f\;vs))_n) 
                            & \Transducer(i, m, f, \sigma, \sigma', U') \\
                            & = & (\sigma\;vs)_{n+1} \otimes (\theta'\;(f\;vs))_n 
                            & i \not\in \domain{(\theta'\;(f\;vs))_n} \\
                            & \dashv\vdash & R(\setof{m}, (\sigma\;vs)_{n+1} \otimes (\theta'\;(f\;vs))_n) 
                            & \unready{(\sigma\;vs)_{n+1} \otimes \theta'}{m} \\
                            & = & R(\setof{m}, (\sigma\;vs)_{n+1}) \otimes R(\setof{m}, (\theta'\;(f\;vs))_n) 
                            & \\
                            & \dashv\vdash & (\sigma\;vs)_{n+1} \otimes R(\setof{m}, (\theta'\;(f\;vs))_n) 
                            &  \unready{(\sigma\;vs)_{n+1}}{m} \\
                            & \dashv\vdash & (\sigma\;vs)_{n+1} \otimes (\theta\;vs)_{n+1} 
                            & \Transducer(m, o, g, \theta, \theta', U'')  \\
                            & = & (\phi\;vs)_{n+1} & 
  \end{array}
  \end{displaymath}

\item $\forall n, vs.\; o \in \domain{(\phi\;vs)_n}$ 

  Immediate, since $o \in \domain{(\theta\;vs)_n}$ and $(\phi\;vs)_n = (\sigma\;vs)_n \otimes (\theta\;vs)_n$ \

\item $\forall n, vs.\; \closed{(\phi\;vs)_n}{\domain{(\phi'\;vs)_n}}$

  We know  $\closed{(\sigma\;vs)_n}{\domain{(\sigma\;vs)_n}}$,  
   $\closed{(\theta\;vs)_n}{\domain{(\theta\;vs)_n}}$ hold.
   Hence $\closed{(\sigma\;vs)_n \otimes (\theta\;vs)_n}{\domain{(\sigma\;vs)_n \otimes (\theta\;vs)_n}}$ holds. 
   Since $(\phi\;vs)_n = (\sigma\;vs)_n \otimes (\theta\;vs)_n$, 
 we know $\closed{(\phi\;vs)_n}{\domain{(\phi'\;vs)_n}}$. 


\item $\forall n, vs.\; \closed{(\phi'\;vs)_n}{\domain{(\phi'\;vs)_n} \cup \setof{i}}$ 

  We know $\closed{\sigma'_n}{\domain{\sigma'_n} \cup \setof{i}}$ and $\closed{\theta'_n}{\domain{\theta'_n} \cup \setof{m}}$. 
  Hence $\closed{(\phi'\;vs)_n}{\domain{(\phi'\;vs)_n} \cup \setof{i} \cup \setof{m}}$. However, since $m \in \domain{\sigma'_n}$, we 
  have $\closed{(\phi'\;vs)_n}{\domain{(\phi'\;vs)_n} \cup \setof{i}}$. 


  
\item For all $vs, I, O,$ and $U$, we want to show that if $\Stream(i, vs, I, O, U)$ then $\Stream(o, \mathit{compose}\;f\;g\;vs, I \otimes \phi, O \otimes (\phi'\;vs), U \cup U' \cup U'')$
  \begin{tabbedproof}
  \oo Assume we have $vs, I, O$, and $U$, and that $\Stream(i, vs, I, O, U)$ holds. \\
  \oo From the fact that $\Transducer(i, m, \sigma, \sigma', U')$ holds, \\
  \oo we see $\Stream(m, f\;vs, I \otimes \sigma, O \otimes (\sigma'\;vs), U \cup U')$. \\
  \oo From the fact that $\Transducer(m, o, \theta, \theta', U'')$ holds, \\
  \oo we see $\Stream(m, g\;(f\;vs), I \otimes \sigma \otimes \theta, O \otimes (\sigma'\;vs) \otimes (\theta'\;(f\;vs)), U \cup U' \cup U'')$. \\
  \oo Since $g\;(f\;vs) = \mathit{compose}\;f\;g\;vs$ and $(\sigma'\;vs) \otimes (\theta'\;(f\;vs) = \phi'\;vs$, we see that \\
  \oo $\Stream(m, \mathit{compose}\;f\;g\;vs, I \otimes \sigma \otimes \theta, O \otimes (\phi'\;vs), U \cup U' \cup U'')$.
  \end{tabbedproof}
\end{enumerate}
\end{proof}

\subsubsection{The $\pairop$transducer}

\begin{lemma}{(The $\ctext{pairop}$ network)}
If we have that $\Transducer(i, b, f, \sigma, \sigma', U')$ and $\Transducer(m, c, \theta, \theta', U'')$, 
then it follows that $\Transducer(i, o, \mathit{pair}\;f\;g, \phi, \phi', U' \cup U'' \cup U''')$, where $\phi = \sigma \otimes \theta \otimes \varsigma$
and $\phi' = \sigma' \otimes \theta' \otimes \varsigma'$, where
\begin{itemize}
\item $\varsigma_n = \cellneg{o}{e}$ 
\item $\varsigma'\;vs\;n = \cellpos{o}{e}{(\mathit{pair}\;f\;g\;vs)_n}{\setof{b,c}}$
\item $U'''_n = \setof{o}$
\item $e = \bind (\readcell\;b)\; (\semfun{b_0}{\bind (\readcell c)\;(\semfun{c_0}{\return\pair{b_0}{c_0}})})$
\end{itemize}
\end{lemma}
\begin{proof}
Assume have that $\Transducer(i, m, f, \sigma, \sigma', U')$ and $\Transducer(m, o, \theta, \theta', U'')$, 
\begin{enumerate}
\item $\forall n, vs.\; o \in \domain{(\phi\;vs)_n}$ 

  Immediate

\item $\forall n, vs.\; R(\setof{i}, (\phi'\;vs)_n) \dashv\vdash (\phi\;vs)_{n+1}$
  
  Note that $(\varsigma'\;vs)_n = \cellpos{o}{e}{(\mathit{pair}\;f\;g\;vs)_n}{\setof{b,c}}$. \\
  \begin{displaymath}
    \begin{array}{lcll}
      R(\setof{i}, (\phi'\;vs)_n)  & = & R(\setof{i}, (\sigma'\;vs)_n \otimes (\theta'\;vs)_n \otimes (\varsigma'\;vs)_n) 
      & \\
                                  & = & R(\setof{i}, (\sigma'\;vs)_n) \otimes R(\setof{i}, (\theta'\;vs)_n) \otimes R(\setof{i}, (\varsigma'\;vs)_n) 
      & \\
                                  & = & R(\setof{i}, (\sigma'\;vs)_n) \otimes R(\setof{i}, (\theta'\;vs)_n) \otimes (\varsigma'\;vs)_n
      & \\
                                   & \dashv\vdash &  (\sigma\;vs)_{n+1} \otimes (\theta\;vs)_{n+1} \otimes (\varsigma'\;vs)_n
      & (1) \\ 
                                   & \dashv\vdash &  R(\setof{b}, (\sigma\;vs)_{n+1} \otimes (\theta\;vs)_{n+1} \otimes (\varsigma'\;vs)_n)
      & (2) \\ 
                                   & = & R(\setof{b}, (\sigma\;vs)_{n+1}) \otimes R(\setof{b}, (\theta\;vs)_{n+1}) \otimes R(\setof{b}, (\varsigma'\;vs)_n) 
      & \\
                                   & = & R(\setof{b}, (\sigma\;vs)_{n+1}) \otimes R(\setof{b}, (\theta\;vs)_{n+1}) \otimes \cellneg{o}{e}
      & \\
                                   & = & R(\setof{b}, (\sigma\;vs)_{n+1}) \otimes R(\setof{b}, (\theta\;vs)_{n+1}) \otimes (\varsigma\;vs)_{n+1}
      & \\
                                   & = & R(\setof{b}, (\sigma\;vs)_{n+1}) \otimes (\theta\;vs)_{n+1} \otimes (\varsigma\;vs)_{n+1}
      & (3) \\ 
                                   & \dashv\vdash & (\sigma\;vs)_{n+1} \otimes (\theta\;vs)_{n+1} \otimes (\varsigma\;vs)_{n+1}
      & (4) \\ 
                                   & = & (\phi\;vs)_{n+1}
      & 
    \end{array}
  \end{displaymath}

  \begin{itemize}
    \item[(1)] From $\Transducer$ hypotheses for $\sigma$ and $\theta$.
    \item[(2)] Since $\unready{(\sigma\;vs)_{n+1} \otimes (\theta\;vs)_{n+1} \otimes (\varsigma'\;vs)_n}{b}$ holds.
    \item[(3)] Since $b\not\in \domain{(\theta\;vs)_{n+1}}$. 
    \item[(4)] Since $\unready{(\sigma\;vs)_{n+1}}{b}$ holds, plus entailments. 
  \end{itemize}

\item $\forall n, vs.\; \unready{(\phi\;vs)_n}{o}$.

  Immediate, since $\varsigma\;vs\;n = \cellneg{o}{e}$. 

\item $\forall n, vs.\; \closed{(\phi\;vs)_n}{\domain{(\phi'\;vs)_n}}$

  First note that $\closed{(\sigma\;vs)_n}{\domain{(\sigma\;vs)_n}}$
  and $\closed{(\theta\;vs)_n}{\domain{(\theta\;vs)_n}}$. 
  Furthermore, we have  $\closed{\cellneg{o}{e}}{\emptyset}$, 
  and since $(\phi\;vs)_n = (\sigma\;vs)_n \otimes (\theta\;vs)_n \otimes \cellneg{o}{e}$,
  it follows that 
  $\closed{(\phi\;vs)_n}{\domain{(\phi\;vs)_n}}$.

\item $\forall n, vs.\; \closed{(\phi'\;vs)_n}{\domain{(\phi'\;vs)_n} \cup \setof{i}}$ 

  Assume $n$ and $vs$, and observe that $(\phi'\;vs)_n = (\sigma'\;vs)_n \otimes (\theta'\;vs)_n \otimes \cellpos{o}{e}{(\mathit{pair}\;f\;g\;vs)_n}{\setof{b,c}}$.
  Since $\closed{(\sigma'\;vs)_n}{\domain{(\sigma'\;vs)_n} \cup \setof{i}}$ and 
  $\closed{(\theta'\;vs)_n}{\domain{(\theta'\;vs)_n} \cup \setof{i}}$, then 
  $\closed{(\phi'\;vs)_n}{\domain{\phi'} \cup \setof{i} \cup \setof{b,c}}$. However, $b \in \domain{(\sigma'\;vs)_n}$ and $c \in \domain{(\theta'\;vs)_n}$, 
  so $\closed{(\phi'\;vs)_n}{\domain{\phi'} \cup \setof{i}}$.


\item For all $vs, I, O$, and $U$, if we have $\Stream(i, vs, I, O, U)$ then it follows that $\Stream(o, \mathit{lift}\;f\;vs, I \otimes (\phi\;vs), O \otimes (\phi'\;vs), U \cup U')$
  \begin{tabbedproof}
  \oo Assume we have $vs, I, O$, and $U$, and that $\Stream(i, vs, I, O, U)$ holds. \\
  \oo Also observe that $\Stream(i, vs, O, O, \semfun{n}{\emptyset})$ holds. \\
  \oo So we have $\Stream(a, f\;vs, I \otimes (\sigma\;vs), O \otimes (\sigma'\;vs), U')$ \\
  \oo We also have $\Stream(b, g\;vs, O \otimes (\theta\;vs), O \otimes (\theta'\;vs), U'')$ \\
  \oo Now, we want to show $\Stream(o, f\;vs, I \otimes (\phi\;vs), O \otimes (\phi'\;vs), U \cup U')$ \\
  \\ \oo 1. We want for all $n$, that $o \in \domain{I_n \otimes (\phi\;vs)_n}$ \\
  \ooo Immediate, since $(\phi\;vs)_n = (\sigma\;vs)_n \otimes (\theta\;vs)_n \otimes \cellneg{o}{e}$ \\

  \\ \oo 2. We want for all $n$, that $\domain{I_n \otimes (\phi\;vs)_n} = \domain{O_n \otimes (\phi'\;vs)_n}$ \\
  \ooo Immediate, since we know \\ 
  \ooox $\domain{I_n} = \domain{O_n}$, \\
  \ooox $\domain{(\sigma\;vs)_n} = \domain{(\sigma'\;vs)_n}$ from $\Transducer(i, a, f, \sigma, \sigma', U')$ \\
  \ooox $\domain{(\theta\;vs)_n} = \domain{(\theta'\;vs)_n}$ from $\Transducer(i, b, g, \theta, \theta', U')$\\
  \ooox and $\domain{\cellneg{o}{e}} = \domain{\cellpos{o}{e}{(\mathit{pair}\;f\;g\;vs)_n}{\setof{b,c}}}$. \\

  \\ \oo 3. We want for all $n$, that $\closed{I_n \otimes (\phi\;vs)_n}{\domain{I_n \otimes (\phi\;vs)_n}}$\\
  \ooo We know $\closed{I_n}{\domain{I_n}}$ \\
  \ooo We know $\closed{(\phi\;vs)_n}{\domain{(\phi\;vs)_n}}$ \\
  \ooo Hence we know $\closed{I_n \otimes (\phi\;vs)_n}{\domain{I_n \otimes (\phi\;vs)_n}}$ \\

  \\ \oo 4. We want for all $n$, that $\closed{O_n \otimes (\phi'\;vs)_n}{\domain{O_n \otimes (\phi'\;vs)_n}}$\\
  \ooo We know $\closed{O_n}{\domain{O_n}}$ \\
  \ooo We know $\closed{(\phi'\;vs)_n}{\domain{(\phi'\;vs)_n} \cup \setof{i}}$ \\
  \ooo Since $i \in \domain{O_n}$, we know $\closed{O_n \otimes (\phi'\;vs)_n}{\domain{O_n \otimes (\phi\;vs)_n}}$ \\

  \\ \oo 5. We want for all $n$, that $U_n \subseteq \domain{I_n \otimes (\phi\;vs)_n}$ \\
  \ooo Since $U_n = \setof{o}$, this is immediate. \\

  \\ \oo 6. We want for all $n$, that $\ready{O_n \otimes (\phi'\;vs)_n}{o}{(\mathit{pair}\;f\;g\;vs)_n}$ \\
  \ooo We know $\ready{O_n \otimes (\sigma'\;vs)_n}{b}{(f\;vs)_n}$ \\
  \ooo We know $\ready{O_n \otimes (\theta'\;vs)_n}{c}{(g\;vs)_n}$\\
  \ooo Therefore $\ready{O_n \otimes (\phi'\;vs)_n}{o}{(\mathit{pair}\;f\;g\;vs)_n}$ \\
  \ooo This follows since $(\varsigma'\;vs)_n = \cellpos{c}{e}{(\mathit{pair}\;f\;g\;vs)_n}{\setof{b}{c}}$.  \\
  

  \\ \oo 7. We want $\forall n, \psi.\; \spec{G(I_n \otimes (\phi\;vs)_n \otimes \psi)}{\readcell\;i}{a}{a = \pair{f\;vs_n}{\setof{o}} \land G(O_n \otimes (\phi'\;vs)_n \otimes R(U_n, \psi))}$ \\

  \ooo Assume we have a prestate $G(I_n \otimes (\sigma\;vs)_n \otimes (\theta\;vs)_n \otimes (\varsigma\;vs)_n \otimes \psi )$ \\
  \ooo Since $\unready{I_n \otimes (\phi\;vs)_n}{o}$, we need to use the $\AUnready$ spec. \\
  \ooo So we consider the state $G(I_n \otimes (\sigma\;vs)_n \otimes (\theta\;vs)_n \otimes \psi)$ and the expression $e$ \\
  \ooo By the $\Stream(b, f\;vs, I \otimes (\sigma\;vs), O \otimes (\sigma'\;vs), U')$ hypothesis, we get \\
  \ooo the state $G(O_n \otimes (\sigma'\;vs)_n \otimes R(U_n \cup U'_n, (\theta\;vs)_n) \otimes R(U_n \cup U'_n, \psi))$ \\
  \ooo and the return value $\pair{(f\;vs)_n}{\setof{b}}$ \\ 
  \ooo We know $U_n \cup U'_n \subseteq \domain{I_n \otimes (\sigma\;vs)_n}$, and since $\closed{(\theta\;vs)_n}{\domain{(\theta\;vs)_n}}$ \\
  \ooo Hence $(U_n \cup U'_n) \cap \domain{(\theta\;vs)_n}$ is empty, and so $R(U_n \cup U'_n, (\theta\;vs)_n) = (\theta\;vs)_n$ \\
  \ooo Hence the state is $G(O_n \otimes (\sigma'\;vs)_n \otimes (\theta\;vs)_n \otimes R(U_n \cup U'_n, \psi))$ \\ 
  \ooo To use the $\ABind$ rule, we need to evaluate $\bind (\readcell c)\;(\semfun{c_0}{\return\pair{(f\;vs)_n}{c_0}})$ \\
  \ooo Then from the $\Stream(c, g\;vs, O \otimes (\theta\;vs), O \otimes (\theta'\;vs), U'')$ hypothesis, we get \\
  \ooo $G(O_n \otimes (\theta'\;vs)_n) \otimes R(U''_n, (\sigma'\;vs)_n \otimes R(U_n \cup U'_n, \psi))$ \\ 
  \ooo and a return value of $\pair{(g\;vs)_n}{\setof{c}}$ \\ 
  \ooo Since $U''_n \subseteq \domain{(\theta\;vs)_n}$, we know that $R(U''_n, (\sigma'\;vs)_n) = (\sigma'\;vs)_n$ \\ 
  \ooo Hence the state is $G(O_n \otimes (\theta'\;vs)_n) \otimes (\sigma'\;vs)_n \otimes R(U_n \cup U'_n \cup U''_n, \psi))$ \\ 
  \ooo Now we need to use $\AUnit$ on the remaining command $\return \pair{(f\;vs)_n}{(g\;vs)_n}$ \\ 
  \ooo This leaves the state $G(O_n \otimes (\theta'\;vs)_n \otimes (\sigma'\;vs)_n \otimes R(U_n \cup U'_n \cup U''_n, \psi))$ \\ 
  \ooo and returns $\pair{\pair{(f\;vs)_n}{(g\;vs)_n}}{\setof{b,c}}$ \\ 
  \ooo Then concluding the $\AUnready$ rule our final state is: \\
  \ooo $G((\varsigma'\;vs)_n \otimes R(\setof{o}, O_n \otimes (\theta'\;vs)_n \otimes (\sigma'\;vs)_n \otimes R(U_n \cup U'_n \cup U''_n, \psi)))$ \\ 
  \ooo Simplifying, since $o$ does not occur in $(\theta'\;vs)_n$ or $(\sigma'\;vs)_n$, we get \\
  \ooo $G(O_n \otimes (\theta'\;vs)_n \otimes (\sigma'\;vs)_n \otimes (\varsigma'\;vs)_n \otimes R(U_n \cup U'_n \cup U''_n \cup \setof{o}, \psi)))$ \\ 
  \ooo and a return value of $\pair{\pair{(f\;vs)_n}{(g\;vs)_n}}{\setof{o}}$ \\
  \ooo Since $(\mathit{pair}\;f\;g\;vs)_n = (\mathit{zip}\;(f\;vs)\;(g\;vs))_n = \pair{(f\;vs)_n}{(g\;vs)_n}$, \\
  \ooo we have the desired conclusion. 
  \end{tabbedproof}
\end{enumerate}
\end{proof}

\subsubsection{The $\switchop$ transducer}
\begin{lemma}{(The $\ctext{switch}$ network)}
If we have that $\Transducer(i, b, f, \sigma, \sigma', U')$ and $\Transducer(m, c, \theta, \theta', U'')$, 
then it follows that $\Transducer(i, o, \mathit{switch}\;k\;f\;g, \phi, \phi', U''')$, where 

\begin{itemize}
\item $\phi\;vs\;n = \IfThenElse{n < k}{(\sigma\;vs)_n \otimes (\theta\;(\mathit{drop}\;k\;vs))_0}{(\sigma\;vs)_k \otimes (\theta\;(\mathit{drop}\;k\;vs))_{n-k}} \otimes (\varsigma\;vs)_n$
\item $\varsigma\;vs\;n = \cellneg{o}{e} \otimes \localref{r}{n}$ 
\item $\phi'\;vs\;n = \IfThenElse{n < k}{(\sigma'\;vs)_n \otimes (\theta\;(\mathit{drop}\;k\;vs))_0}{(\sigma\;vs)_k \otimes (\theta'\;(\mathit{drop}\;k\;vs))_{n-k}} \otimes  \otimes (\varsigma'\;vs)_n$
\item $\varsigma'\;vs\;n = \IfThenElse{n < k}{\cellpos{o}{e}{(\mathit{switch}\;f\;g\;vs)_n}{\setof{b}}}
                                        {\cellpos{o}{e}{(\mathit{switch}\;f\;g\;vs)_n}{\setof{c}}} \otimes \localref{r}{n+1}$
\item $e = \bind (\getref\;l)\;(\semfun{i}{\bind\;(\setref\;r\;(i+1))\; (\semfun{\unit}{\IfThenElse{i < k}{\readcell\;b}{\readcell\;c}})})$
\item $U'''_n = \IfThenElse{n < k}{U'_n \cup \setof{o}}{U''_{n-k} \cup \setof{o}}$
\item $e = \bind (\readcell\;b)\; (\semfun{b_0}{\bind (\readcell c)\;(\semfun{c_0}{\return\pair{b_0}{c_0}})})$
\end{itemize}
\end{lemma}
\begin{proof}
Assume have that $\Transducer(i, m, f, \sigma, \sigma', U')$ and $\Transducer(m, o, \theta, \theta', U'')$, 
\begin{enumerate}
\item $\forall n, vs.\; o \in \domain{(\phi\;vs)_n}$ 

  Assume $n$ and $vs$, and note that $(\phi\;vs)_n = \ldots \otimes (\varsigma\;vs)_n$. 
  Since $(\varsigma\;vs)_n = \cellneg{o}{e}$, it follows that $o \in \domain{(\phi\;vs)_n}$. 


\item $\forall n, vs.\; R(\setof{i}, (\phi'\;vs)_n) \dashv\vdash (\phi\;vs)_{n+1}$

  Assume $n$ and $vs$, and consider whether $n < k$.

  Suppose $n < k$. Then:
  \begin{displaymath}
      \begin{array}{lcll}
        R(\setof{i}, (\phi'\;vs)_n) 
        & = & R(\setof{i}, (\sigma'\;vs)_n \otimes (\theta\;(\mathit{drop}\;k\;vs))_0 \otimes (\varsigma'\;vs)_n)
        & \\
        & = & R(\setof{i}, (\sigma'\;vs)_n) \otimes R(\setof{i}, (\theta\;(\mathit{drop}\;k\;vs))_0) \otimes  R(\setof{i}, (\varsigma'\;vs)_n)
        & \\
        & \dashv\vdash & (\sigma\;vs)_{n+1} \otimes R(\setof{i}, (\theta\;(\mathit{drop}\;k\;vs))_0) \otimes  R(\setof{i}, (\varsigma'\;vs)_n)
        & (1) \\
        & \dashv\vdash & (\sigma\;vs)_{n+1} \otimes (\theta\;(\mathit{drop}\;k\;vs))_0 \otimes  R(\setof{i}, (\varsigma'\;vs)_n)
        & (2) \\ 
        & = & (\sigma\;vs)_{n+1} \otimes (\theta\;(\mathit{drop}\;k\;vs))_0 \otimes (\varsigma'\;vs)_n
        & (3) \\ 
        & \dashv\vdash & R(\setof{b}, (\sigma\;vs)_{n+1} \otimes (\theta\;(\mathit{drop}\;k\;vs))_0 \otimes (\varsigma'\;vs)_n
        & (4) \\ 
        & = & R(\setof{b}, (\sigma\;vs)_{n+1}) \otimes R(\setof{b}, (\theta\;(\mathit{drop}\;k\;vs))_0) \otimes R(\setof{b}, (\varsigma'\;vs)_n)
        & \\ 
        & \dashv\vdash & (\sigma\;vs)_{n+1} \otimes R(\setof{b}, (\theta\;(\mathit{drop}\;k\;vs))_0) \otimes R(\setof{b}, (\varsigma'\;vs)_n)
        & (5) \\
        & \dashv\vdash & (\sigma\;vs)_{n+1} \otimes (\theta\;(\mathit{drop}\;k\;vs))_0 \otimes R(\setof{b}, (\varsigma'\;vs)_n)
        & (6) \\ 
        & = & (\sigma\;vs)_{n+1} \otimes (\theta\;(\mathit{drop}\;k\;vs))_0 \otimes \cellneg{o}{e} \otimes \localref{r}{n+1}
        & \\ 
        & = & (\sigma\;vs)_{n+1} \otimes (\theta\;(\mathit{drop}\;k\;vs))_0 \otimes (\varsigma\;vs)_{n+1} 
        & \\ 
        & = & (\phi\;vs)_{n+1}
        \end{array}
  \end{displaymath}
  \begin{itemize}
      \item[(1)] Since we know $\Transducer(i, b, f, \sigma, \sigma', U')$ 
      \item[(2)] Since $\closed{(\theta\;(\mathit{drop}\;k\;vs))_0}{\domain{(\theta\;(\mathit{drop}\;k\;vs))_0}}$, and \\ $i \not\in \domain{(\theta\;(\mathit{drop}\;k\;vs))_0}$
      \item[(3)] Since $(\varsigma'\;vs)_n = \cellpos{o}{e}{(\mathit{switch}\;k\;f\;g\;vs)_n}{\setof{b}}$, and $i \not\in \setof{b}$
      \item[(4)] Since $\unready{(\sigma\;vs)_{n+1} \otimes (\theta\;(\mathit{drop}\;k\;vs))_0 \otimes (\varsigma'\;vs)_n}{b}$ 
      \item[(5)] Since $\unready{(\sigma\;vs)_{n+1}}{b}$ 
      \item[(6)] Since $\closed{(\theta\;(\mathit{drop}\;k\;vs))_0}{\domain{(\theta\;(\mathit{drop}\;k\;vs))_0}}$, and \\ $b \not\in \domain{(\theta\;(\mathit{drop}\;k\;vs))_0}$
  \end{itemize}

  Now, suppose $n \geq k$. Then 
  \begin{displaymath}
      \begin{array}{lcll}
        R(\setof{i}, (\phi'\;vs)_n) 
        & = & R(\setof{i}, (\sigma\;vs)_k \otimes (\theta'\;(\mathit{drop}\;k\;vs))_{n-k} \otimes (\varsigma'\;vs)_n)
        & \\
        & = & R(\setof{i}, (\sigma\;vs)_k) \otimes R(\setof{i}, (\theta'\;(\mathit{drop}\;k\;vs))_{n-k}) \otimes R(\setof{i}, (\varsigma'\;vs)_n)
        & \\
        & \dashv\vdash & (\sigma\;vs)_k \otimes R(\setof{i}, (\theta'\;(\mathit{drop}\;k\;vs))_{n-k}) \otimes R(\setof{i}, (\varsigma'\;vs)_n)
        & (1) \\
        & \dashv\vdash & (\sigma\;vs)_k \otimes (\theta\;(\mathit{drop}\;k\;vs))_{n-k+1} \otimes R(\setof{i}, (\varsigma'\;vs)_n)
        & (2) \\ 
        & = & (\sigma\;vs)_k \otimes (\theta\;(\mathit{drop}\;k\;vs))_{n-k+1} \otimes (\varsigma'\;vs)_n
        & (3) \\ 
        & \dashv\vdash & R(\setof{c}, (\sigma\;vs)_k \otimes (\theta\;(\mathit{drop}\;k\;vs))_{n-k+1} \otimes (\varsigma'\;vs)_n)
        & (4) \\ 
        & = & R(\setof{c}, (\sigma\;vs)_k) \otimes R(\setof{c}, (\theta\;(\mathit{drop}\;k\;vs))_{n-k+1}) \otimes R(\setof{c}, (\varsigma'\;vs)_n)
        & \\ 
        & = & (\sigma\;vs)_k \otimes R(\setof{c}, (\theta\;(\mathit{drop}\;k\;vs))_{n-k+1}) \otimes R(\setof{c}, (\varsigma'\;vs)_n)
        & (5) \\
        & \dashv\vdash & (\sigma\;vs)_k \otimes (\theta\;(\mathit{drop}\;k\;vs))_{n-k+1} \otimes R(\setof{c}, (\varsigma'\;vs)_n)
        & (6) \\ 
        & = & (\sigma\;vs)_k \otimes (\theta\;(\mathit{drop}\;k\;vs))_{n-k+1} \otimes \cellneg{o}{e} \otimes \localref{r}{n+1}
        & \\ 
        & = & (\sigma\;vs)_k \otimes (\theta\;(\mathit{drop}\;k\;vs))_{n-k+1} \otimes (\varsigma\;vs)_{n+1}
        & \\ 
        & = & (\phi\;vs)_{n+1}
        \end{array}
  \end{displaymath}

  \begin{itemize}
  \item[(1)] Since $\closed{(\sigma\;vs)_k}{\domain{(\sigma\;vs)_k}}$, and $i \not\in \domain{(\sigma\;vs)_k}$ 
  \item[(2)] Since $\Transducer(m, c, \theta, \theta', U'')$ 
  \item[(3)] Since $(\varsigma'\;vs)_n = \cellpos{o}{e}{(\mathit{switch}\;f\;g\;vs)_n}{\setof{c}}$ and $i \not\in \setof{c}$
  \item[(4)] Since $\unready{(\sigma\;vs)_k \otimes (\theta\;(\mathit{drop}\;k\;vs))_{n-k+1} \otimes (\varsigma'\;vs)_n}{c}$
  \item[(5)] Since $\closed{(\sigma\;vs)_k}{\domain{(\sigma\;vs)_k}}$, and $c\not\in\domain{(\sigma\;vs)_k}$
  \item[(6)] Since $\unready{(\theta\;(\mathit{drop}\;k\;vs))_{n-k+1}}{c}$
  \end{itemize}

\item $\forall n, vs.\; \unready{(\phi\;vs)_n}{o}$.

  Assume $n$ and $vs$, and note that $(\phi\;vs)_n = \ldots \otimes (\varsigma\;vs)_n$. Since 
  $(\varsigma\;vs)_n = \cellneg{o}{e} \otimes \localref{r}{n}$, it follows that $\unready{(\phi\;vs)_n}{o}$. 

\item $\forall n, vs.\; \closed{(\phi\;vs)_n}{\domain{(\phi\;vs)_n}}$

  Assume $n$ and $vs$, and consider whether $n < k$:
  \begin{itemize}
  \item If $n < k$: \\ 
    Then $(\phi\;vs)_n = (\sigma\;vs)_{n} \otimes (\theta\;(\mathit{drop}\;k\;vs))_0 \otimes (\varsigma\;vs)_{n}$. \\
    We know $\closed{(\sigma\;vs)_{n}}{\domain{(\sigma\;vs)_{n}}}$. \\
    We know $\closed{(\theta\;(\mathit{drop}\;k\;vs))_0}{\domain{(\theta\;(\mathit{drop}\;k\;vs))_0}}$. \\
    Since $(\varsigma\;vs)_n = \cellneg{o}{e} \otimes \localref{r}{n}$, \\
    it follows that $\closed{\cellneg{o}{e}}{\emptyset}$, and hence $\closed{(\phi\;vs)_n}{\domain{(\phi\;vs)_n}}$. 
  \item If $n \geq k$: \\ 
    Then $(\phi\;vs)_n = (\sigma\;vs)_k \otimes (\theta\;(\mathit{drop}\;k\;vs))_{n-k} \otimes (\varsigma\;vs)_{n}$. \\
    We know $\closed{(\sigma\;vs)_{k}}{\domain{(\sigma\;vs)_{k}}}$. \\
    We know $\closed{(\theta\;(\mathit{drop}\;k\;vs))_{n-k}}{\domain{(\theta\;(\mathit{drop}\;k\;vs))_{n-k}}}$. \\
    Since $(\varsigma\;vs)_n = \cellneg{o}{e} \otimes \localref{r}{n}$, \\
    it follows that $\closed{\cellneg{o}{e}}{\emptyset}$, and hence
    $\closed{(\phi\;vs)_n}{\domain{(\phi\;vs)_n}}$. 
  \end{itemize}

\item $\forall n, vs.\; \closed{(\phi'\;vs)_n}{\domain{(\phi'\;vs)_n} \cup \setof{i}}$ 
  Assume $n$ and $vs$, and consider whether $n < k$:
  \begin{itemize}
  \item If $n < k$: \\ 
    Then $(\phi'\;vs)_n = (\sigma'\;vs)_{n} \otimes (\theta\;(\mathit{drop}\;k\;vs))_0 \otimes (\varsigma'\;vs)_{n}$. \\
    We know $\closed{(\sigma'\;vs)_{n}}{\domain{(\sigma'\;vs)_{n}} \cup \setof{i}}$. \\
    We know $\closed{(\theta\;(\mathit{drop}\;k\;vs))_0}{\domain{(\theta\;(\mathit{drop}\;k\;vs))_0}}$. \\
    Since $(\varsigma'\;vs)_n = \cellpos{o}{e}{(\mathit{switch}\;k\;f\;g\;vs)_n}{\setof{b}} \otimes \localref{r}{n+1}$, it follows that $\closed{\cellneg{o}{e}}{\setof{b}}$. \\
    Since $b \in \domain{(\sigma'\;vs)_{n}}$,  it follows that $\closed{(\phi\;vs)_n}{\domain{(\phi\;vs)_n} \cup \setof{i}}$. 
  \item If $n \geq k$: \\ 
    Then $(\phi'\;vs)_n = (\sigma\;vs)_k \otimes (\theta'\;(\mathit{drop}\;k\;vs))_{n-k} \otimes (\varsigma'\;vs)_{n}$. \\
    We know $\closed{(\sigma\;vs)_{k}}{\domain{(\sigma\;vs)_{k}}}$. \\
    We know $\closed{(\theta'\;(\mathit{drop}\;k\;vs))_{n-k}}{\domain{(\theta\;(\mathit{drop}\;k\;vs))_{n-k}} \cup \setof{i}}$. \\
    Since $(\varsigma'\;vs)_n = \cellpos{o}{e}{(\mathit{switch}\;k\;f\;g\;vs)_n}{\setof{c}} \otimes \localref{r}{n+1}$, \\
    it follows that $\closed{\cellneg{o}{e}}{\setof{c}}$. \\
    Since $c \in \domain{(\theta'\;(\mathit{drop}\;k\;vs))_{n-k}}$, \\
    it follows that $\closed{(\phi\;vs)_n}{\domain{(\phi\;vs)_n} \cup \setof{i}}$. 
  \end{itemize}


\item For all $vs, I, O$, and $U$, if we have $\Stream(i, vs, I, O, U)$ then it follows that $\Stream(o, \mathit{switch}\;k\;f\;g\;vs, I \otimes (\phi\;vs), O \otimes (\phi'\;vs), U \cup U''')$
  \begin{tabbedproof}
  \oo Assume we have $vs, I, O$, and $U$, and that $\Stream(i, vs, I, O, U)$ holds. \\
  \oo Hence we know that $\Stream(b, f\;vs, I \otimes (\sigma\;vs), O \otimes (\sigma'\;vs), U \cup U')$ also holds. \\ 
  \oo Observe that $\Stream(i, \mathit{drop}\;k\;vs, \hat{I}, \hat{O}, \hat{U})$ also holds, \\
  \oox   where $\hat{I}\;n = I(n+k)$, $\hat{O}\;n = O(n+k)$, and $\hat{U}\;n = U(n+k)$. \\
  \oo Hence we know that \\
  \oox $\Stream(c, g\;(\mathit{drop}\;k\;vs), \hat{I} \otimes (\theta\;(\mathit{drop}\;k\;vs)), \hat{O} \otimes (\theta\;(\mathit{drop}\;k\;vs)), \hat{U} \cup U'')$. \\ 
  
  \\ \oo 1. We want for all $n$, that $o \in \domain{I_n \otimes (\phi\;vs)_n}$ \\
  \ooo Immediate, since $(\phi\;vs)_n = \ldots \otimes \cellneg{o}{e}$ \\

  \\ \oo 2. We want for all $n$, that $\domain{I_n \otimes (\phi\;vs)_n} = \domain{O_n \otimes (\phi'\;vs)_n}$ \\
  \ooo Suppose that $n < k$: \\
  \oooo Then $(\phi\;vs)_n = (\sigma\;vs)_n \otimes (\theta\;(\mathit{drop}\;k\;vs))_0 \otimes (\varsigma\;vs)_n$ \\
  \oooo Then $(\phi'\;vs)_n = (\sigma'\;vs)_n \otimes (\theta\;(\mathit{drop}\;k\;vs))_0 \otimes (\varsigma'\;vs)_n$ \\
  \oooo So $\domain{(\varsigma\;vs)_n} = \domain{(\varsigma'\;vs)_n}$, since they contain the same single cell $o$ \\
  \oooo So $\domain{I_n \otimes (\sigma\;vs)_n} = \domain{O_n \otimes (\sigma'\;vs)_n}$, \\
  \oooox since  $\Stream(b, f\;vs, I \otimes (\sigma\;vs), O \otimes (\sigma'\;vs), U \cup U')$ also holds. \\ 
  \oooo Hence $\domain{I_n \otimes (\phi\;vs)_n}  = \domain{O_n \otimes (\phi'\;vs)_n}$. \\ 
  \ooo Suppose that $n \geq k$: \\   
  \oooo Then $(\phi\;vs)_n  = (\sigma\;vs)_k \otimes (\theta\;(\mathit{drop}\;k\;vs))_{n-k} \otimes (\varsigma\;vs)_n$ \\
  \oooo Then $(\phi'\;vs)_n = (\sigma\;vs)_k \otimes (\theta\;(\mathit{drop}\;k\;vs))_{n-k} \otimes (\varsigma'\;vs)_n$ \\
  \oooo So $\domain{(\varsigma\;vs)_n} = \domain{(\varsigma'\;vs)_n}$, since they contain the same single cell $o$ \\
  \oooo So $\domain{\hat{I}_{n-k} \otimes (\theta\;(\mathit{drop}\;k\;vs))_{n-k}} = \domain{\hat{O}_{n-k} \otimes (\theta\;(\mathit{drop}\;k\;vs))_{n-k}}$, \\
  \oooox since  $\Stream(c, g\;(\mathit{drop}\;k\;vs), \hat{I} \otimes (\theta\;(\mathit{drop}\;k\;vs)), \hat{O} \otimes (\theta\;(\mathit{drop}\;k\;vs)), \hat{U} \cup U'')$ \\ 
  \oooo Since $\hat{I}_{n-k} = I_n$ and $\hat{O}_{n-k} = O_n$, so \\
  \oooo we see $\domain{I_n \otimes (\theta\;(\mathit{drop}\;k\;vs))_{n-k}} = \domain{O_n \otimes (\theta\;(\mathit{drop}\;k\;vs))_{n-k}}$, \\
  \oooo Hence $\domain{I_n \otimes (\phi\;vs)_n}  = \domain{O_n \otimes (\phi'\;vs)_n}$. \\ 

  \\ \oo 3. We want for all $n$, that $\closed{I_n \otimes (\phi\;vs)_n}{\domain{I_n \otimes (\phi\;vs)_n}}$\\
  \ooo We know that $\closed{I_n}{\domain{I_n}}$ and $\mathit{closed}{(\phi\;vs)_n}{\domain{(\phi\;vs)_n}}$. \\
  \ooo So $\closed{I_n \otimes (\phi\;vs)_n}{\domain{I_n \otimes (\phi\;vs)_n}}$\\

  \\ \oo 4. We want for all $n$, that $\closed{O_n \otimes (\phi'\;vs)_n}{\domain{O_n \otimes (\phi'\;vs)_n}}$\\
  \ooo We know that $\closed{O_n}{\domain{O_n}}$ and $\mathit{closed}{(\phi\;vs)_n}{\domain{(\phi\;vs)_n} \cup \setof{i}}$. \\
  \ooo Since $i \in \domain{O_n}$, it follows that $\closed{I_n \otimes (\phi\;vs)_n}{\domain{I_n \otimes (\phi\;vs)_n}}$\\

  \\ \oo 5. We want for all $n$, that $U_n \cup U'''_n \subseteq \domain{I_n \otimes (\phi\;vs)_n}$ \\
  \ooo Assume $n < k$: \\
  \oooo Then $U'''_n = U'_n \cup \setof{o}$. \\
  \oooo We know $U_n \cup U'_n \subseteq \domain{I_n \otimes (\sigma\;vs)_n}$, \\
  \oooox since  $\Stream(b, f\;vs, I \otimes (\sigma\;vs), O \otimes (\sigma'\;vs), U \cup U')$ holds. \\ 
  \oooo We know $o \in \domain{(\phi\;vs)_n}$, since $(\phi\;vs)_n = \ldots \otimes \cellneg{o}{e}$ \\ 
  \oooo Hence $U_n \cup U'''_n \cup \setof{o} \subseteq \domain{I_n \otimes (\phi\;vs)_n}$. \\
  \oooox since $\domain{(\sigma\;vs)_n} \subseteq \domain{(\phi\;vs)_n}$, and \\
  \oooox since $o \in  \domain{(\phi\;vs)_n}$ \\
  \ooo Assume $n \geq k$: \\
  \oooo Then $U'''_n = U''_{n-k} \cup \setof{o}$. \\
  \oooo We know $o \in \domain{(\phi\;vs)_n}$, since $(\phi\;vs)_n = \ldots \otimes \cellneg{o}{e}$ \\ 
  \oooo We know $\hat{U}_{n-k} \cup U''_{n-k} \subseteq \domain{\hat{I}_{n-k} \otimes (\theta\;(\mathit{drop}\;k\;vs))_{n-k}}$, since \\
  \oooox  $\Stream(c, g\;(\mathit{drop}\;k\;vs), \hat{I} \otimes (\theta\;(\mathit{drop}\;k\;vs)), \hat{O} \otimes (\theta\;(\mathit{drop}\;k\;vs)), \hat{U} \cup U'')$. \\ 
  \oooo Note that $\hat{U}_{n-k} = U_n$, and $\hat{I}_{n-k} = I_n$ \\ 
  \oooo Hence $U_n \cup U''_{n-k} \subseteq \domain{I_n \otimes (\theta\;(\mathit{drop}\;k\;vs))_{n-k}}$.  \\
  \oooox since $\domain{(\theta\;(\mathit{drop}\;k\;vs)_{n-k}} \subseteq \domain{(\phi\;vs)_n}$, and \\
  \oooox since $o \in  \domain{(\phi\;vs)_n}$ \\
  \\ \oo 6. We want for all $n$, that $\ready{O_n \otimes (\phi'\;vs)_n}{o}{(\mathit{pair}\;f\;g\;vs)_n}$ \\
  \ooo Assume $n < k$:\\
  \oooo Then $(\phi'\;vs)_n = (\sigma'\;vs)_n \otimes \ldots \otimes (\varsigma'\;vs)_n$ \\
  \oooo Since $\Stream(b, f\;vs, I \otimes (\sigma\;vs), O \otimes (\sigma'\;vs), U \cup U')$ holds, \\
  \oooo we know $\ready{O_n \otimes (\sigma'\;vs)_n}{b}{(f\;vs)_n}$. \\
  \oooo Since $(\varsigma'\;vs)_n = \cellpos{o}{e}{(\mathit{switch}\;k\;f\;g\;vs)_n}{\setof{b}}$, \\
  \oooo it follows that $\ready{(\phi'\;vs)_n}{o}{(\mathit{switch}\;k\;f\;g\;vs)_n}$ \\
  \ooo Assume $n \geq k$: \\
  \oooo Then $(\phi'\;vs)_n = \ldots \otimes (\theta'\;(\mathit{drop}\;k\;vs))_n \otimes (\varsigma'\;vs)_n$ \\
  \oooo Since $\Stream(c, g\;(\mathit{drop}\;k\;vs), \hat{I} \otimes (\theta\;(\mathit{drop}\;k\;vs)), \hat{O} \otimes (\theta\;(\mathit{drop}\;k\;vs)), \hat{U} \cup U'')$, \\ 
  \oooo we know $\ready{\hat{O}_{n-k} \otimes (\theta'\;(\mathit{drop}\;k\;vs))_{n-k}}{c}{(g\;(\mathit{drop}\;k\;vs))_{n-k}}$. \\
  \oooo Since $(\varsigma'\;vs)_n = \cellpos{o}{e}{(\mathit{switch}\;k\;f\;g\;vs)_n}{\setof{c}}$, \\
  \oooo it follows that $\ready{(\phi'\;vs)_n}{o}{(\mathit{switch}\;k\;f\;g\;vs)_n}$ \\

  \\ \oo 7. We want to show for all $n$ and $\psi$, \\
  \ooox $\setof{G(I_n \otimes (\phi\;vs)_n \otimes \psi)}$ \\
  \ooox $\readcell\;o$ \\
  \ooox $\setof{a.\;a = \pair{f\;vs_n}{\setof{o}} \land G(O_n \otimes (\phi'\;vs)_n \otimes R(U_n \cup U'''_n, \psi))}$ \\
  \ooo Suppose $n < k$: \\ 
  \oooo Assume we have the state $G(I_n \otimes (\phi\;vs)_n \otimes \psi)$ \\
  \oooo Then $(\phi\;vs)_n = (\sigma\;vs)_n \otimes (\theta\;(\mathit{drop}\;k\;vs))_0 \otimes (\varsigma\;vs)_n$ \\
  \oooo where $(\varsigma\;vs)_n = \cellneg{o}{e} \otimes \localref{r}{n}$ \\
  \oooo Since $o$ is unready, reading it uses the $\AUnready$ rule. \\
  \oooo We we consider the state without the $o$ cell, getting \\
  \oooo the state $G(I_n \otimes (\sigma\;vs)_n \otimes (\theta\;(\mathit{drop}\;k\;vs))_0 \otimes \localref{r}{n} \otimes \psi)$ \\ 
  \oooo and now evaluate $e$ \\ 
  \oooo We start with $\ABind$ and $\AGetRef$, which leaves the state \\
  \ooooo $G(I_n \otimes (\sigma\;vs)_n \otimes (\theta\;(\mathit{drop}\;k\;vs))_0 \otimes \localref{r}{n} \otimes \psi)$ \\ 
  \oooo gives the return value $\pair{n}{\emptyset}$. Substituting $n$ into the remaining expression: \\
  \ooooo $\bind\;(\setref\;r\;(n+1))\; (\semfun{\unit}{\IfThenElse{n < k}{\readcell\;b}{\readcell\;c}})$ \\
  \oooo Now we use $\ABind$ and $\ASetRef$, which changes the state to \\
  \oooo $G(I_n \otimes (\sigma\;vs)_n \otimes (\theta\;(\mathit{drop}\;k\;vs))_0 \otimes \localref{r}{n+1} \otimes \psi)$ \\ 
  \oooo and gives the return value $\pair{\unit}{\emptyset}$. Substituting the return value, we get \\
  \ooooo $\IfThenElse{n < k}{\readcell\;b}{\readcell\;c}$ \\
  \oooo Since $n < k$, this expression is equivalent to: \\
  \ooooo $\readcell\;b$ \\
  \oooo Since $\Stream(b, f\;vs, I \otimes (\sigma\;vs), O \otimes (\sigma'\;vs), U \cup U')$ holds, we can get \\ 
  \ooooo $G(O_n \otimes (\sigma'\;vs)_n \otimes R(U_n \cup U'_n, (\theta\;(\mathit{drop}\;k\;vs))_0 \otimes \localref{r}{n+1} \otimes \psi))$ \\ 
  \oooo Note that $R(U_n \cup U'_n, (\theta\;(\mathit{drop}\;k\;vs))_0) = (\theta\;(\mathit{drop}\;k\;vs))_0$, since \\
  \ooooo $\closed{(\theta\;(\mathit{drop}\;k\;vs))_0}{\domain{(\theta\;(\mathit{drop}\;k\;vs))_0}}$, and \\
  \ooooo $U_n \cup U'_n \subseteq \domain{O_n \otimes (\sigma'\;vs)_n}$. \\
  \oooo Therefore the state is equivalent to \\
  \ooooo $G(O_n \otimes (\sigma'\;vs)_n \otimes (\theta\;(\mathit{drop}\;k\;vs))_0 \otimes \localref{r}{n+1} \otimes R(U_n \cup U'_n, \psi))$ \\ 
  \oooo with a return value of $\pair{(f\;vs)_n}{\setof{b}}$ \\
  \oooo Then by the conclusion of the $\AUnready$ rule, we have the state: \\
  \ooooo $G(\cellpos{o}{e}{(f\;vs)_n}{\setof{b}} \otimes \localref{r}{n+1} $ \\
  \oooooo $\otimes\; R(\setof{o}, O_n \otimes (\sigma'\;vs)_n \otimes (\theta\;(\mathit{drop}\;k\;vs))_0 \otimes R(U_n \cup U'_n, \psi)))$ \\ 
  \oooo with a return value of $\pair{(f\;vs)_n}{\setof{o}}$ \\ 
  \oooo Note that $R(\setof{o}, O_n \otimes (\sigma'\;vs)_n) = O_n \otimes (\sigma'\;vs)_n$, \\
  \ooooo since $\closed{O_n}{\domain{O_n} \otimes (\sigma'\;vs)_n}$ and $o\not\in\domain{O_n} \otimes (\sigma'\;vs)_n$ \\
  \oooo Note that $R(\setof{o}, (\theta\;(\mathit{drop}\;k\;vs))_0) = (\theta\;(\mathit{drop}\;k\;vs))_0$, \\
  \ooooo since $\closed{(\theta\;(\mathit{drop}\;k\;vs))_0}{\domain{(\theta\;(\mathit{drop}\;k\;vs))_0}}$ \\
  \ooooo and $o\not\in\domain{(\theta\;(\mathit{drop}\;k\;vs))_0}$\\
  \oooo Hence the final state is equivalent to \\
  \ooooo $G(O_n \otimes (\sigma'\;vs)_n \otimes (\theta\;(\mathit{drop}\;k\;vs))_0 \otimes (\varsigma'\;vs)_n \otimes R(U_n \cup U'_n \cup \setof{o}, \psi)$ \\
  \oooo Note that $U'''_n = U'_n \cup \setof{o}$, so the state is \\
  \ooooo $G(O_n \otimes (\phi'\;vs)_n \otimes R(U_n \cup U'''_n, \psi))$ \\ 
  \oooo with a return value of $\pair{(f\;vs)_n}{\setof{o}}$ \\ 
  \oooo For $n < k$, we know $(\mathit{switch}\;k\;f\;g\;vs)_n = (f\;vs)_n$, so we have our goal. \\
  \ooo Otherwise $n \geq k$: \\
  \oooo Assume we have the state $G(I_n \otimes (\phi\;vs)_n \otimes \psi)$ \\
  \oooo Then $(\phi\;vs)_n = (\sigma\;vs)_k \otimes (\theta'\;(\mathit{drop}\;k\;vs))_{n-k} \otimes (\varsigma\;vs)_n$ \\
  \oooo where $(\varsigma\;vs)_n = \cellneg{o}{e} \otimes \localref{r}{n}$ \\
  \oooo Since $o$ is unready, reading it uses the $\AUnready$ rule. \\
  \oooo We we consider the state without the $o$ cell, getting \\
  \oooo the state $G(I_n \otimes (\sigma\;vs)_k \otimes (\theta\;(\mathit{drop}\;k\;vs))_{n-k} \otimes \localref{r}{n} \otimes \psi)$ \\ 
  \oooo and now evaluate $e$ \\ 
  \oooo We start with $\ABind$ and $\AGetRef$, which leaves the state \\
  \ooooo $G(I_n \otimes (\sigma\;vs)_k \otimes (\theta\;(\mathit{drop}\;k\;vs))_{n-k} \otimes \localref{r}{n} \otimes \psi)$ \\ 
  \oooo returning the value $\pair{n}{\emptyset}$. Substituting $n$ into the remaining code, we get: \\
  \ooooo $\bind\;(\setref\;r\;(n+1))\; (\semfun{\unit}{\IfThenElse{n < k}{\readcell\;b}{\readcell\;c}})$ \\
  \oooo Now we use $\ABind$ and $\ASetRef$, which changes the state to \\
  \ooooo $G(I_n \otimes (\sigma\;vs)_k \otimes (\theta\;(\mathit{drop}\;k\;vs))_{n-k} \otimes \localref{r}{n+1} \otimes \psi)$ \\ 
  \oooo and gives the return value $\pair{\unit}{\emptyset}$. Substituting the return value, we get \\
  \ooooo $\IfThenElse{n < k}{\readcell\;b}{\readcell\;c}$ \\
  \oooo Since $n \geq k$, this expression is equivalent to: \\
  \ooooo $\readcell\;c$ \\
  \oooo Recall $\Stream(c, g\;(\mathit{drop}\;k\;vs), \hat{I} \otimes (\theta\;(\mathit{drop}\;k\;vs)), \hat{O} \otimes (\theta'\;(\mathit{drop}\;k\;vs)), \hat{U} \cup U'')$ \\
  \oooo Since $\hat{I}_n = I_{n+k}$, we can apply the $\readcell\;c$ spec at $n - k$, yielding the state \\
  \ooooo $G(O_n \otimes (\theta'\;(\mathit{drop}\;k\;vs))_{n-k} \otimes R(U_n \cup U''_n, (\sigma\;vs)_k\otimes \localref{r}{n+1} \otimes \psi))$ \\ 
  \oooo with the return value $\pair{(g\;(\mathit{drop}\;k\;vs))_{n-k}}{\setof{c}}$ \\
  \oooo Note that $R(U_n \cup U''_n, (\sigma\;vs)_k) = (\sigma\;vs)_k$, since \\
  \ooooo $\closed{(\sigma\;vs)_k}{\domain{(\sigma\;vs)_k}}$, and since \\
  \ooooo $\domain{U_n \cup U''_n} \subseteq \domain{O_n \otimes (\theta'\;(\mathit{drop}\;k\;vs))_n}$ \\ 
  \oooo Hence the state is equivalent to \\
  \ooooo $G(O_n \otimes (\theta'\;(\mathit{drop}\;k\;vs))_{n-k} \otimes (\sigma\;vs)_k\otimes \localref{r}{n+1} \otimes R(U_n \cup U''_n, \psi))$ \\ 
  \oooo Completing the $\AUnready$ rule, our state is: \\
  \ooooo $G(\cellpos{o}{e}{(g\;(\mathit{drop}\;k\;vs))_{n-k}}{\setof{c}} \otimes \localref{r}{n+1}$ \\
  \oooooo $R(\setof{o}, O_n \otimes (\theta'\;(\mathit{drop}\;k\;vs))_{n-k} \otimes (\sigma\;vs)_k \otimes R(U_n \cup U''_n, \psi))$ \\ 
  \oooo with a return value of $\pair{(g\;(\mathit{drop}\;k\;vs))_{n-k}}{\setof{o}}$ \\
  \oooo Note that $R(\setof{o}, O_n \otimes (\theta'\;(\mathit{drop}\;k\;vs))_{n-k}) = O_n \otimes (\theta'\;(\mathit{drop}\;k\;vs))_{n-k}$, \\
  \ooooo since $\closed{O_n \otimes (\theta'\;(\mathit{drop}\;k\;vs))_{n-k}}{\domain{O_n \otimes (\theta'\;(\mathit{drop}\;k\;vs))_{n-k}}}$ and \\
  \ooooo since $o \not\in \domain{O_n \otimes (\theta'\;(\mathit{drop}\;k\;vs))_{n-k}}$ \\
  \oooo Note that $R(\setof{o}, (\sigma\;vs)_k) = (\sigma\;vs)_k$, \\
  \ooooo since $\closed{(\sigma\;vs)_k}{\domain{(\sigma\;vs)_k}}$ and \\
  \ooooo since $o \not\in \domain{(\sigma\;vs)_k}$ \\
  \ooooo $G(\cellpos{o}{e}{(g\;(\mathit{drop}\;k\;vs))_{n-k}}{\setof{c}} \otimes \localref{r}{n+1}$ \\
  \oooooo $O_n \otimes (\theta'\;(\mathit{drop}\;k\;vs))_{n-k} \otimes (\sigma\;vs)_k \otimes R(U_n \cup U''_n \cup \setof{o}, \psi))$ \\ 
  \oooo Since $(g\;(\mathit{drop}\;k\;vs))_{n-k} = (\mathit{switch}\;k\;f\;g\;vs)_n$, this is equivalent to:\\
  \ooooo $G((\phi'\;vs)_n \otimes R(U_n \cup U''_n \cup \setof{o}, \psi))$ \\
  \oooo with a return value of $\pair{(\mathit{switch}\;k\;f\;g\;vs)_n}{\setof{o}}$ \\ 
  \end{tabbedproof}
\end{enumerate}
\end{proof}


\subsubsection{The $\loopop$ transducer}
\begin{lemma}{(The $\ctext{loop}$ network)}
If we have that $\Transducer(ab, ac, f, \sigma, \sigma', U')$ 
then it follows that $\Transducer(i, o, \mathit{loop}\;a_0\;f, \phi, \phi', U''')$, where 

\begin{itemize}
\item $\phi\;vs\;n = (\sigma\;vs)_n \otimes (\varsigma\;vs)_n $
\item $\phi'\;vs\;n = (\sigma'\;vs)_n \otimes (\varsigma'\;vs)_n$
\item $\varsigma\;vs\;n = \localref{r}{(aseq\;vs)_n} \otimes \cellneg{ab}{e_1} \otimes \cellneg{o}{e_2}$ 
\item $\varsigma'\;vs\;n = {\small \localref{r}{(aseq\;vs)_{n+1}} \otimes \cellpos{ab}{e_1}{(abseq\;vs)_n}{\setof{b}} \otimes \cellpos{o}{e_2}{(cseq\;vs)_n}{\setof{ac}}}$ 
\item $acseq\;vs = \mathit{cycle}\;a_0\;f\;vs$
\item $aseq\;vs = \mathit{map}\;\pi_1\;(acseq\;vs)$
\item $abseq\;vs = \mathit{zip}\;(aseq\;vs)\;vs$
\item $e_1 = \bind (\getref\;r)\;(\semfun{a}{\bind\;(\readcell\;i)\; (\semfun{b}{\return\pair{a}{b}})})$
\item $e_2 = \bind (\readcell\;ac)\;(\semfun{(a,c)}{\bind (\setref\;r\;a)\; (\semfun{\unit}{\return\;c})})$
\item $U''_n = U'_n \cup \setof{ab,o}$
\end{itemize}
\end{lemma}
\begin{proof}
Assume have that $\Transducer(i, x, f, \sigma, \sigma', U')$. 
\begin{enumerate}
\item $\forall n, vs.\; o \in \domain{(\phi\;vs)_n}$ 


\item $\forall n, vs.\; R(\setof{i}, (\phi'\;vs)_n) \dashv\vdash (\phi\;vs)_{n+1}$


\item $\forall n, vs.\; \unready{(\phi\;vs)_n}{o}$.

\item $\forall n, vs.\; \closed{(\phi\;vs)_n}{\domain{(\phi\;vs)_n}}$


\item $\forall n, vs.\; \closed{(\phi'\;vs)_n}{\domain{(\phi'\;vs)_n} \cup \setof{i}}$ 

\item For all $vs, I, O$, and $U$, if we have $\Stream(i, vs, I, O, U)$ then it follows that $\Stream(o, \mathit{switch}\;k\;f\;g\;vs, I \otimes (\phi\;vs), O \otimes (\phi'\;vs), U \cup U''')$
  \begin{tabbedproof}
  Assume we have $vs, I, O$, and $U$, and that $\Stream(i, vs, I, O, U)$ holds. \\

  \\ \oo 1. We want for all $n$, that $o \in \domain{I_n \otimes (\phi\;vs)_n}$ \\

  \\ \oo 2. We want for all $n$, that $\domain{I_n \otimes (\phi\;vs)_n} = \domain{O_n \otimes (\phi'\;vs)_n}$ \\

  \\ \oo 3. We want for all $n$, that $\closed{I_n \otimes (\phi\;vs)_n}{\domain{I_n \otimes (\phi\;vs)_n}}$\\

  \\ \oo 4. We want for all $n$, that $\closed{O_n \otimes (\phi'\;vs)_n}{\domain{O_n \otimes (\phi'\;vs)_n}}$\\

  \\ \oo 5. We want for all $n$, that $U_n \cup U'''_n \subseteq \domain{I_n \otimes (\phi\;vs)_n}$ \\

  \\ \oo 6. We want for all $n$, that $\ready{O_n \otimes (\phi'\;vs)_n}{o}{(\mathit{pair}\;f\;g\;vs)_n}$ \\

  \\ \oo 7. We want to show for all $n$ and $\psi$, \\
  \ooox $\setof{G(I_n \otimes (\phi\;vs)_n \otimes \psi)}$ \\
  \ooox $\readcell\;o$ \\
  \ooox $\setof{a.\;a = \pair{f\;vs_n}{\setof{o}} \land G(O_n \otimes (\phi'\;vs)_n \otimes R(U_n \cup U'''_n, \psi))}$ \\

  \end{tabbedproof}
\end{enumerate}
\end{proof}

\section{Future Work}

Now that we have introduced the idea of ramifications and seen two
different applications for them we see many possible further uses.  It
would be interesting to investigate the relationship between
ramification operators and methods based on
rely-guarantee~\cite{rely-guarantee-jones}. Rely-guarantee works by
imposing a mutual contract between a piece of code and the rest of the
world, which is at least conceptually similar to the idea of a
ramification, though we see no obvious direct relationship.

Third, so far we have presented ramifications as a style of
specification useful for verifying a particular library.  Might it be
sensible or useful to bake ramification operators into the basic
logical framework?  If so, what are their logical properties --- $R(u,
\phi)$ looks like a family of modal operators on the formula $\phi$.
However, our first two examples exhibited a number of different
auxiliary interaction lemmas, which is what made them truly useful, 
and the common features are still unclear. 

\section{Related Work}

Prior work on verifying callbacks using separation logic includes both
\citet{tldi09,ftfjp07} work as well as by
\citet{parkinson-iwaco-07}. The approach in these papers was similar;
each subject predicate was equipped with a list of observers, rather
than maintaining them implicitly in the invariant. These approaches
were not modular, because the observers had to be explicitly
named. Worse still, this approach broke down when faced with chains of
subjects and observers, because separation logic is a resource-based
logic, and the existence of multiple paths to an object meant that
ownership of observer state became ambiguous.

\citet{shaner-leavens-naumann} studied using gray-box model programs
to model higher-order method calls (which can be understood as a a
variant of refinement calculus-based methods) in JML, and
\citet{history-invariants} have applied Liskov and Wing's idea of
history invariants~\cite{liskov-wing} to model observers. As before,
both of these methods are also non-modular, since they require knowing
what all of the observers are, and furthermore both of these methods
sharply restrict the kinds of invariants that can be used, making it
very difficult to model the code-update-based protocol seen in our FRP
example.

\citet{self-adjusting} have proposed
\emph{self-adjusting computation} as a technique for using change
propagation to write programs that incrementally
recompute answers as the inputs are adjusted. It would be worth 
studying if our techniques could help verifying implementations of this
idea.

Functional reactive programming (FRP) was proposed by \citet{frp} as a
declarative formalism for interactive programming. The API in our
paper differs from theirs in two ways. First, our interface is a
variation of the \emph{arrowized FRP} interface proposed in
\cite{afrp}, and secondly, we use a discrete model of time, rather
than a continuous model of time --- though we found the core idea of
using a declarative semantics as a specification for the interface an
inspiring one.

Furthermore, our work could also serve as a bridge between the work on
purely functional reactive programming, and more imperative
implementations, such as the work done by \citet{superglue} on
SuperGlue and by \citet{frtime} on the FrTime system.


\section{Appendix: The $\cellset$ Interface}

In this section, we will describe the interface to the $\cellset$ type,
which is intended to be used to represent pure collections of
existentially quantified cells. Specifying this interface is not
entirely trivial, because of the way equality works for this
type. Ordinarily, we would simply give a two-place predicate $set(v,
\elts)$ relating a value $v$, and the mathematical set of elements
$\elts$ it represents.

However, this approach is not sufficient in our case. In order to
manage dependencies, we need to be able to test cells of
\emph{different} concrete type for equality, and the natural equality
test for references only permits testing references of the same
type. As a result, we cannot unpack an existentially-quantified cell
and compare the elements in its tuple, because we do not know that the
two cells are of the same type (and indeed, they might not be).

To get around this problem, we generate a unique integer identifier
for each cell we create, and then compare those identifiers to
establish equality. Since these identifiers are all generated
dynamically along with the cells, this means that the precise partial
equivalence relation we need to use is determined dynamically as
well. So we add an additional index to the set predicate $set(W, v,
\elts)$. The extra parameter $W$ is the \emph{world}, the set of all
the cells allocated so far, which must collectively satisfy the
constraint that two elements of the world are equal if and only if their
identifier fields match.

All of the usual set operations exist. We have an $\ctext{emptyset}$,
representing an empty set of cells, as well as singleton
($\ctext{singleton}$) and union ($\ctext{union}$) operations.  We have
$\ctext{addset}\;v\;x$, which adds the element $x$ to the set $v$
represents, and $\ctext{removeset}\;v\;x$, which removes $x$ from the
set $v$ represents. We also have $\ctext{iterset}\;f\;v$, which
iterates over the elements of $v$'s set and applies $f$ to each
element in some sequential order. (Observe that the specification
makes use of two auxiliary predicates: $matches$, which assert that a
set and a list have the same elements; and $iterseq$, which constructs
a command representing the sequential execution of those elements.)

We have three axioms that our implementation must satisfy. First, if a
$\cellset$ value $v$ represents a set in a world $W$, it will also
represent a set in any larger world $W'$. Second, the values in a set
are always a subset of the world $W$. Finally, we require that
$set(W,v,\elts)$ is a pure predicate (i.e., is not heap-dependent),
which implies that it have a purely functional implementation (for
example, as a binary tree). 

\begin{figure}
\begin{specification}
\nextline
$World = $ \nextline
\qquad\=$\{D \in \powersetfin{\ecell}\;|\;\forall (\pack{\alpha}{c_0} \; \mathrm{as}\; c),(\pack{\beta}{d_0} \;\mathrm{as}\; d) \in D.\;c_0.id = d_0.id \iff c = d\}$\nextline[1em]

$\exists \cellset : \star.$ \nextline
$\exists set : World \To \cellset \To \powersetfin{\ecell} \To \assert.$ \nextline
$\exists \ctext{emptyset}    : cellset.$ \nextline
$\exists \ctext{singleton}   : \ecell \to \cellset.$ \nextline
$\exists \ctext{union}      : \cellset \to \cellset \to \cellset.$ \nextline
$\exists \ctext{addset}      : \cellset \to \ecell \to \cellset.$ \nextline
$\exists \ctext{removeset}   : \cellset \to \ecell \to \cellset.$ \nextline
$\exists \ctext{iterset}     : (\ecell \to \monad{\unittype}) \to \cellset \to \monad{\unittype}.$\nextline[1em]

$\forall W \in World.\; set(W, \ctext{emptyset}, \emptyset)$ \nextline[1em]

$\forall W \in World, c \in W.\; set(W, \ctext{singleton}\;c, \setof{c})$ \nextline[1em]

$\forall W \in World, c_1 : \cellset, \elts_1 \in \powersetfin{W}, c_2 : \cellset, \elts_2 \in \powersetfin{W}.$ \nextline
\>$set(W, c_1, \elts_1) \land set(W, c_2, \elts_2) \implies set(W, \ctext{union}\;c_1\;c_2, \elts_1 \cup \elts_2)$ \nextline[1em]


$\forall W \in World, v : \cellset, x : \ecell, \elts \in \powersetfin{\ecell}.$ \nextline 
\> $set(W, v, \elts) \land x \in W \implies set(W, \ctext{addset}\;v\;x, \elts \cup \setof{x})$ \nextline[1em]


$\forall W \in World, v : \cellset, x : \ecell, \elts \in \powersetfin{\ecell}.$ \nextline 
\> $set(W, v, \elts) \land x \in W \implies set(W, \ctext{removeset}\;v\;x, \elts - \setof{x})$ \nextline[1em]


$\forall W \in World, v : \cellset, \elts \in \powersetfin{\ecell}, 
         f : (\ecell \to \monad{\unittype}).$ \nextline 
\> $set(W, v, \elts) \implies \exists L : \seqsort{\ecell}.\;$\=$matches\;\elts\;L\; \land \ctext{iterset}\;f\;v = iterseq\;f\;L$ \nextline[1em]


$\forall W, W' \in World, v, \elts.$ \nextline
\>$set(W,v,\elts) \land W \subseteq W' \implies set(W',v, \elts)$\nextline[1em]

$\forall W \in World, v, \elts.$ \nextline
\>$set(W, v, \elts) \implies \elts \subseteq W$ \nextline[1em]

$\forall W, v, \elts.\; \mathrm{Pure}(set(W,v,\elts))$ \nextline[1em]
  
$matches : \powerset{\ecell} \to \seqsort{\ecell} \to \assert$ \nextline
$matches\;\elts\;[] \qquad\;\;\; = \elts = \emptyset$ \nextline
$matches\;\elts\;(v :: vs) = v \in \elts \land matches\;(\elts - \setof{v})\;vs$\nextline[1em]

$iterseq : (\ecell \to \monad{\unittype}) \to \seqsort{\ecell} \to \monad{\unittype}$ \nextline
$iterseq\; f\; [] \qquad\;\;\;\;$\=$= \comp{\unit}$ \nextline
$iterseq\; f\; (v :: vs)$\>$= \comp{\letv{\unit}{f\;v}{\ctext{run}\;iterseq\;f\;vs}}$
\end{specification}
\caption{The Cell Set Specification}
\label{cellset-spec}
\end{figure}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
