\chapter{Verifying Interactive Programs}

\section{Introduction}

In many interactive programs, there are mutable data structures which
change over time, and which must maintain some relationships with one
another. For example, in a web browser, we need to present a web page
both as a tree data structure for scripts to manipulate, and display a
graphical image for the human user to view. Any change made to the
tree by a script must be reflected in a change to the image that the
human sees --- the two structures must remain synchronized.

Likewise, in a spreadsheet, each cell contains a formula, which may
refer to other cells, and whenever the user changes a cell, all of the
cells which transitively depend upon it must be updated. Since
spreadsheets can get very large, this should ideally be done in a lazy
way, so that only the cells visible on the screen, and the cells
necessary to compute them, are themselves recomputed.

Typically, these dependencies are written using what is called the
\emph{subject-observer} pattern. A mutable data structure (the
subject) maintains a list of all of the data structures whose
invariants depend upon it (the observers), and whenever it changes, it
calls a function on each of those observers to update them in response
to the change. (And in turn, the observers of the subject may be
subjects of still other observers, ultimately forming DAGs of
notifications.)

While natural, these programs are very challenging to verify in a
modular way. The reason is that there are two directions of
dependency, both of which matter for program proof. First, our program
invariant must have ownership over the subject's data (its
\emph{footprint}) in order to prove the correctness of code modifying
the subject. This direction of ownership is natural to verify with
separation logic.

In addition, these programs must also explicitly maintain the
\emph{other} direction of dependency as well --- we track everything
which depends upon the subject, and modify them appropriately whenever
the subject changes.  The natural program invariant now becomes a
global property: we need to know the full dependency graph covering
all subjects and observers, so that we can say that the reads and
is-read-by relations are relational transposes of one another. The
global nature of this invariant means that a naive correctness proof
will not respect the modular structure of the program --- if we modify
the dependency graph in any way, we now have to re-verify the entire
program!

However, the intention of the subject-observer pattern is precisely to
allow the program to remain oblivious to the exact number and nature
of the observers, which allows the programmer to add new observers
without disturbing the behavior of the rest of the program.  Our goal,
then, is to find a way of taking this piece of practical software
engineering wisdom, and casting it into formal terms amenable to
proof.

Concretely, this chapter's contributions are as follows: 

\begin{itemize}
  \item I define a library with a monadic API for writing
    demand-driven computations with dynamic dependencies and local
    state, and which is implemented as higher-order functions
    dynamically creating networks of imperative callbacks.

    I give an ``abstract semantics'' for this library, structured as a
    set of separation logic lemmas about our dataflow library. These
    lemmas permit \emph{modular} correctness proofs about programs
    using this API, even in the face of the fact that the program
    invariants must be defined globally upon the whole callback
    network.

    The key idea is to distinguish between the direct footprint of a
    command, and the program state which can depends upon that
    footprint. The lemmas are then phrased so that they refer only to
    the direct footprint of each command in the API. In addition, we
    structure our lemmas to justify a ramified frame property for our
    abstract semantics, which we can use to verify different parts of
    an imperative dataflow network separately.

    To do this, I follow the recipe laid out in the previous chapter,
    only now in a more complicated setting. I introduce a
    domain-specific separation logic of dataflow cells, and show how
    to specify cells in such a way that they only mention their
    footprint, and use a ramification operator to specify their effect
    on the rest of the heap. In addition to the ramification operator
    itself, we also need to specify several predicates and operators
    to let us reason about the state of the dataflow heap.

  \item To show that this is actually a good technique for specifying
    libraries, I use this specification to verify an imperative
    implementation of combinators implementing stream transducers in
    the style of functional reactive programming. This proof does not
    need to know about the implementation of the dataflow library; it
    works entirely in terms of the specification of dataflow cells.

    Ultimately, clients can reason about the behavior of the
    imperative implementation ``as if'' it were purely functional,
    even though it is implemented using local state and imperative
    callback procedures.
\end{itemize}

\section{Demand-Driven Notification Networks}

A simple intuition for a ``demand-driven notification network'' is to
think of it as a generalized spreadsheet. We have a collection of
cells, each of which contain program expressions whose evaluation may
refer to other cells. When a cell is read, the expression within the
cell is evaluated, possibly triggering the evaluation of other cells
in a cascade. Furthermore, each cell memoizes its expression, so that
repeated reads won't trigger re-evaluation. Each cell also maintains a
set of dependencies, so that if its code is changed, it and its
transitively reachable dependencies all invalidate their memoized
values.

\subsection{Implementing Notification Networks}

\begin{figure}
\mbox{}
\begin{specification}
\nextline $\codetype{\alpha} = \monad{(\alpha \times \cellset)}$ \nextline[1em]
$\celltype{\alpha} = \{$\=$code: \reftype{(\codetype{\alpha})};$ \nextline
                   \>$value: \reftype{(\opttype{\;\alpha})};$ \nextline
                   \>$reads: \reftype{\cellset};$ \nextline
                   \>$obs:   \reftype{\cellset};$ \nextline
                   \>$id:    \N\}$ \nextline[1em]

$\ecell = \exists \alpha:\star.\; \celltype{\alpha}$ \nextline[1em]

$\ctext{return} : \forall \alpha:\star.\; \alpha \to \codetype{\alpha}$ \nextline
$\ctext{return}\;x = \comp{\pair{x}{\ctext{emptyset}}}$ \nextline[1em]

$\ctext{bind} : \forall \alpha,\beta:\star.\; \codetype{\alpha} \to (\alpha \to \codetype{\beta}) \to \codetype{\beta}$ \nextline
$\ctext{bind}\;\cmd\;f = [$\=$\letv{(v,r_1)}{\cmd}{}$ \nextline
                        \>$\letv{(v',r_2)}{f\;v}{}$ \nextline
                        \>$\;\pair{v'}{\ctext{union}\;r_1\;r_2}]$\nextline[1em]

$\ctext{read} : \forall \alpha:\star.\; \celltype{\alpha} \to \codetype{\alpha}$ \nextline
$\ctext{read}\;a = [$\=$\letv{o}{\comp{!a.value}}{}$ \nextline
                     \>$\ctext{run}\;\ctext{case}(o,$ \nextline
                     \>\qquad\= $\ctext{Some}\;v \to \comp{\pair{v}{\ctext{singleton}\;a}},$ \nextline
                     \>      \> $\ctext{None} \to [$\=$\letv{\cmd}{\comp{!a.code}}{}$ \nextline
                     \>      \>                     \>$\letv{(v,r)}{\cmd}{}$ \nextline
                     \>      \>                     \>$\letv{\_}{\comp{a.value := \Some(v)}}{}$\nextline
                     \>      \>                     \>$\letv{\_}{\comp{a.reads := r}}{}$ \nextline
                     \>      \>                     \>$\letv{\_}{\ctext{iterset}\;(\ctext{add\_observer}\;\pack{\alpha}{a})\;r}{}$ \nextline
                     \>      \>                     \>$\;\pair{v}{\ctext{singleton}\;\pack{\alpha}{a}}])]$ \nextline[1em]

$\getref : \forall \alpha : \reftype{\alpha} \to \codetype{\alpha}$ \nextline
$\getref r = \comp{\letv{v}{\comp{!r}}{\pair{v}{\ctext{emptyset}}}}$ \nextline[1em]

$\setref : \forall \alpha : \reftype{\alpha} \to \alpha \to \codetype{\unittype}$ \nextline
$\setref r\;v = \comp{\letv{\_}{\comp{r := v}}{\pair{\unit}{\ctext{emptyset}}}}$ \nextline[1em]

$\newcell : \forall \alpha:\star.\; \codetype{\alpha} \to \monad{\celltype{\alpha}}$ \nextline
$\newcell\;\cmd = [$\=$\letv{id}{!counter}{}$ \nextline
                    \>$\letv{\_}{\comp{counter := id + 1}}{}$ \nextline
                    \>$\letv{code}{\newref{\codetype{\alpha}}{\cmd}}{}$ \nextline
                    \>$\letv{value}{\newref{\opttype{\;\alpha}}{\ctext{None}}}{}$ \nextline
                    \>$\letv{reads}{\newref{\cellset}{\ctext{emptyset}}}{}$ \nextline
                    \>$\letv{obs}{\newref{\cellset}{\ctext{emptyset}}}{}$ \nextline
                    \>$\; (code, value, reads, obs, id)]$ 
\end{specification}
\caption{Implementation of Notification Networks}
\label{notification-implementation}
\end{figure}

\begin{figure}
\mbox{}
\begin{specification}
\nextline
$\updatecell : \forall \alpha:\star.\; \celltype{\alpha} \to \codetype{\alpha} \to \monad{\unittype}$\nextline
$\updatecell\;\alpha\;\mathit{cell}\;\cmd = 
     [$\=$\letv{\_}{\ctext{mark\_unready}\;\pack{\alpha}{\mathit{cell}}}{}$ \nextline
       \>$\mathit{cell}.code := \cmd]$ \nextline[1em]

$\ctext{mark\_unready} : \ecell \to \monad{\unittype}$ \nextline
$\ctext{mark\_unready}\;cell =\; $\=$\ctext{unpack}(\alpha, a) = cell\; \ctext{in}$\nextline
\>  $[$\=$\letv{os}{\comp{!a.obs}}{}$ \nextline
\>     \>$\letv{rs}{\comp{!a.reads}}{}$ \nextline
\>     \>$\letv{\_}{\ctext{iterset}\;\ctext{mark\_unready}\;os}{}$ \nextline
\>     \>$\letv{\_}{\ctext{iterset}\;(\ctext{remove\_obs}\;cell)\;rs}{}$ \nextline
\>     \>$\letv{\_}{\comp{a.value := \ctext{None}}}{}$ \nextline
\>     \>$\letv{\_}{\comp{a.reads := \ctext{emptyset}}}{}$ \nextline
\>     \>$a.obs   := \ctext{emptyset}]$ 
\nextline[1em]
$\ctext{add\_observer} : \ecell \to \ecell \to \monad{1}$ \nextline
$\ctext{add\_observer} \;o \;\pack{\beta}{c} = [$\=$\letv{os}{[!(c.\mathit{obs})]}{}$ \nextline
                                                  \>$\letv{os}{[\ctext{addset}\;os\;o]}{}$ \nextline
                                                  \>$c.\mathit{obs} := os]$
\nextline[1em]
$\ctext{remove\_obs} : \ecell \to \ecell \to \monad{1}$ \nextline
$\ctext{remove\_obs} \;o \;\pack{\beta}{c} = [$\=$\letv{os}{[!(c.\mathit{obs})]}{}$ \nextline
                                             \>$\letv{os}{[\ctext{removeset}\;os\;o]}{}$ \nextline
                                             \>$c.\mathit{obs} := os]$

\end{specification}
\caption{Implementation of Notification Networks}
\label{notification-implementation-update}
\end{figure}

Our API for creating notification networks is given in
Figure~\ref{notification-implementation} and
Figure~\ref{notification-implementation-update}. First, we'll describe
the interface, and then discuss its implementation.

The interface exposes two basic abstract data type constructors, $\ctext{cell}$
and $\ctext{code}$.

The type $\celltype{\alpha}$ is the type of dynamic data values. A
cell contains a reference to a piece of code, a possible memoized
value, and enough information to correctly invalidate its memoized
value when the cell's dependencies change. We can create a new cell by
calling $\newcell \cmd$, which returns a brand new cell with the code
expression $\cmd$ inside it. We can also modify a cell with the
command $\updatecell\;cell\;\cmd$, which modifies the cell $cell$ by
installing the new expression $\cmd$ in it.

The type $\codetype{\alpha}$ is a monadic type, representing the type of
computations that can read cells. It supports the usual operations
$\return e$ and $\bind \cmd\; (\semfun{x}{e'})$, which embed a pure value
into the $\ctext{code}$ type and implement sequential composition,
respectively. In addition, the primitive operations on this monad
include reading a cell with the $\readcell cell$ function call, and
reading and modifying local state with the $\getref r$ and $\setref
r\;v$ operations.

The difference between $\readcell$ and $\getref$ or $\setref$ is that
the first operation reads a cell, possibly further executing the code
in that cell. In contrast, $\getref$ and $\setref$ are just the
operations to update primitive pointers, lifted to live within the
$\codetype{\alpha}$ monad.
 
The actual implementation is also given in
Figures~\ref{notification-implementation} and~\ref{notification-implementation-update}. 
The abstract type of code is
implemented using the underlying monad of imperative commands, so that
$\codetype{\alpha}$ is implemented with the type $\monad{(\alpha
  \times \cellset)}$.  The intuition is that when we evaluate a term
we are allowed to read some cells along the way, and so must return a
set of all the cells that we read in order to do proper dependency
management. So, $\cellset$ is a type representing sets of
(existentially-quantified) cells.  (The precise specification of
$\cellset$ is given in Appendix A, since describing it is a
distraction from the main development.)

Cells are represented with a 5-tuple. For readability, we use a
record-style notation for them, even though our formal language has
only binary tuples, since records can be translated into nested
tuples.

There is a reference pointing to the code expression, as well as a
value field pointing to an optional value. The value field will be set
to $\ctext{None}$ if the cell is in an unready, un-memoized state, and
will be $\ctext{Some}\;v$ if the cell's code has already been
evaluated to a value $v$. In addition there are two fields
representing the dependencies. If the code expression has been
evaluated and a memoized value generated, then the $reads$ field will
point to the set of cells that the computation directly read while
computing its value. Otherwise it will point to the empty
set. Conversely, the field $obs$ contains the cell's observers --- the
set of cells that have read the current cell as part of their own
computations. Obviously, this is only non-empty when the cell has been
evaluated. Finally, each cell also has an integer id field, which is a
unique numeric identifier for every cell that is created by the
library. This permits us to compare cells (even of different type) for
equality, which is needed for dependency management.

The $\return$ operation for the library simply returns its argument
value and the empty set, since it doesn't read any cells. Likewise,
$\bind \cmd\;f$ will evaluate the first argument and pass the returned
value to the function $f$. It will return the function's return value,
together with the union of the two read sets. $\getref r$ and $\setref
r\;v$ simply read and update the reference, and return empty read
sets, since neither of them read any cells. The only reason we need 
these operations in our interface is for typing reasons; we are defining
a user-defined monad, and $\getref$ and $\setref$ lift the read and
write operations of the underlying language into this monad, adding 
the extra plumbing associated with it.

Interesting things first happen with the $\readcell e$ operation. This
function will first check to see if the cell has a memoized value
ready. If it does, we return that immediately. Otherwise, we evaluate
the cell's code, and update the current cell's value and read set. In
addition, each cell that was read in the evaluation of the code (i.e.,
the set returned as the second component of the monadic type's return
value) also has its observer set updated with the newly-ready current
cell. Now, if any of the dependencies change, they will be able to
invalidate the current cell, which observes them. Note that the
dependencies between cells are all dynamic --- we cannot examine the
inside of a code expression to find its ``free cells'', and so we rely
upon the invariant that a code expression will return every cell it
read, in addition to its return value.

Further interesting things happen with the $\newcell\;\cmd$
operation.  It creates a new cell value, setting the code field with
the argument $\cmd$, and generating an id by dereferencing and
incrementing the variable $counter$. The $counter$ variable occurs
freely in this definition, because it is a piece of state global to
this module, and must be initialized by whatever initialization
routine first constructs the whole module as an existential package.
Since $counter$ is otherwise private, we can generate unique
identifiers by incrementing it as we create new cells. 

Finally, the $\updatecell\;cell\;\cmd$ operation updates a cell
$cell$ with a new code expression $\cmd$. (As an aside, it's worth
noting that this is a genuine, unavoidable, use of higher-order store:
we make use of pointers to code, including the ability to dynamically
modify them.) Once we modify a cell, any memoized value it has is no
longer necessarily correct.

Therefore, we have to drop the memoized value of the cell, and any
cell that transitively observes the cell. This is what the
$\ctext{mark\_unready}$ function does. Given a cell, it takes all of the
observers of the current cell and recursively makes all of
them unready. Then it removes the current cell from the observer sets of
all the cells it reads, and then it nulls out the current cell's
memoized value, as well as setting its read and observer sets to
empty. Notice that there is no explicit base case to the recursive
call; if there are any cycles in the dependency graph, invalidation
could go into an infinite loop. 

So far, we have described the implementation invariants incrementally
and informally. Before proceeding to the formal description, we will
state them again informally, all in one place:

\begin{itemize}
  \item Every cell must have a unique numeric identifier.
  \item Every cell is either ready, or unready. 
  \item Every ready cell has a memoized value, and maintains 
    two sets, one containing every cell that it reads, and the
    other containing every cell it is observed by. 
  \item Every unready cell has no memoized value, and has 
    both an empty read set and an empty observer set. 
  \item The overall dependency graph among the valid cells must form a
    directed acyclic graph. 
  \item The reads and the observers must be the same, only 
    pointing in opposite directions.
\end{itemize}

Formalizing these constraints is relatively straightforward, but we
have the problem that these constraints are global in nature:
we can't be sure that the dependency graph is acyclic without having
it all available to examine, and likewise we can't in general know
that a cell is in the read set of everything in its observed set
without knowing the whole graph. Handling this difficultly is one of
the primary contributions of this work. 

\section{The Abstract Semantics of Notifications}

\subsection{The Structure of the Global Invariant}

The key to getting around our difficulties lies in the difference
between the implementation of $\updatecell$, and of $\ctext{read}$.
$\updatecell$ calls $\ctext{mark\_unready}$, which recursively follows
the observers. The $\ctext{read}$ function, on the other hand,
proceeds in the opposite direction --- it evaluates code expressions,
recursively descending into the footprint of its command. The opposite
direction these two functions look is why we end up needing a global
invariant: we need to know that these two directions are in harmony
with one another.

Now, note that the type of $\ctext{update}$ is simply the monadic type
$\monad{\unittype}$, which precludes clients from constructing
expressions of type $\codetype{\alpha}$ which invoke it. The reason
for this is that the $\codetype{\alpha}$ is an abstract type, and
clients can construct terms of this type only by using the
$\ctext{return}, \ctext{bind}, \ctext{read}, \ctext{getref}$ and
$\ctext{setref}$ operations. Since none of these operations themselves
invoke $\ctext{update}$, no client code can put a code expression in a
cell which can invoke it. (Making this argument completely airtight
would require a parametric model of our language, which we do not
have, but`the intuition is sufficient to guide the design of the
program invariant.)

As a result, when we evaluate a code expression, we will never
actually follow the observer fields -- we'll only patch them as
needed, whenever we evaluate a cell and change it from unready to
ready.  As a result, an abstract description of the heap which
\emph{does not explicitly mention the observer sets} will prove
sufficient for reasoning about the behavior of $\codetype{\alpha}$
expressions.

With this plan, we introduce \emph{abstract heap formulas}, which are
syntactic descriptions of the state of part of the cell heap. These
syntactic expressions are given by the following grammar:
\begin{displaymath}
  \begin{array}{lcl}
    \phi & ::= & I \bnfalt \phi \otimes \psi \bnfalt \cellpos{a}{\cmd}{v}{r} \bnfalt \cellneg{a}{\cmd}\\
         &  |  & \localref{r}{v} 
  \end{array}
\end{displaymath}

Informally, a formula $I$ represents an empty abstract heap, and a
formula $\phi \otimes \psi$ represents an abstract heap that can be
broken into two disjoint parts $\phi$ and $\psi$. We will only
consider formulas modulo the associativity and commutativity of
$\otimes$, and take $I$ to be the unit of this binary operator.

The atomic form $\localref{r}{v}$ says that $r$ is a piece of local
state owned by the network, currently with value $v$. There are two
atomic forms representing cells. $\cellneg{a}{\cmd}$ says that $a$ is a
cell with code $\cmd$, which is unready to deliver a value --- it needs
to be re-evaluated before it can yield a value. $\cellpos{a}{\cmd}{v}{r}$
says that $a$ is a cell with code $\cmd$ that will deliver the value $v$,
under the condition that all the cells in its read set $r$ are
themselves ready. If anything it reads is known to be unready, then it
is unready itself. (We will sometimes write $\celleither{a}{\cmd}$ when
we do not care whether $a$ is ready or not.)

First, notice the must/may flavor of this reading. The formula
$\cellneg{a}{\cmd}$ says that $a$ \emph{must} be unready.  The formula
$\cellpos{a}{\cmd}{v}{r}$ says that $a$ \emph{may} have be ready,
conditional on the readiness of the elements of its read set
$r$. Second, notice that the backwards dependencies are entirely
missing from these formulas. We have simply left out the other half of
the dependency graph from this description. Forgetting this
information will be critical for local reasoning.

We have emphasized that the straightforward invariant is not obviously
modular. Before we can elaborate any further on this point, we will
need to look at the formal statement of the heap invariant. We
introduce the predicate $G(\phi)$, which describes the entire heap of
cells allocated by our library, and which satisfy both the conditions
described in the previous section, and the additional constraint that
the cell heap agree with $\phi$.\footnote{This is why we insisted that
  the abstract heap formulas are syntactic objects --- this permits us
  to define predicates on them by induction over the structure of the
formula.}


\begin{tabbing}
    $G(\phi) \triangleq \exists H \in CellHeap.\; Inv(H, \phi)$ \\ [1em]

$Inv(H, \phi) \triangleq $ \\
\;\;\= $$\=$ R_H^\dagger = O_H \land R_H^+ \mbox{ strict partial order }$ \\
    \> \> $\land\; R_H \subseteq V_H \times V_H \land unique(H)$ \\
    \> \> $\land\; \satisfies{H}{\phi} \land heap(H) * \mathit{refs}(\phi)$ \\
\end{tabbing}

The auxiliary definitions we used in this definition are all given in
Figure~\ref{heap-invariant}. 

We first assert the existence of a cell heap $H$, which is a
collection of cells, together with a function mapping each cell to a
code expression, a possible value, a read set, an observed set, and an
identifier, which satisfies the overall invariant $Inv$.


In the first two lines of $Inv(H, \phi)$, we assert all of the global 
conditions in terms of the mathematical cell heap $H$. First, we assert that 
the relational transpose $(\cdot)^\dagger$ of the reads relation $R_H$ is the
observes relation $O_H$, which enforces the condition that the reads
and observe relations be the same, only pointing in opposite
directions (i.e., if $a$ reads $b$, then $b$ is observed by
$a$). Then, we require that the transitive (but not reflexive) closure
of the reads relation, $R^+_H$ form a strict partial order. Strictness
enforces the condition that there be no cycles in the dependence graph
(because otherwise there would be elements $a$, such that $(a, a) \in
R^+_H$).  Next, we require that the reads relation $R_H$ is a subset of
the Cartesian product $V_H \times V_H$ of the set of cells with values
$V_H$. This ensures that a) there are no dependencies on unready
cells, and b) all unready cells have empty read and observe
sets. Finally, we ask that all of the cells in $H$ have unique
identifiers --- $unique(H)$ asserts that the identifier field is one
half of an isomorphism between the cells in $H$, and the natural
numbers from 0 to the size of $H$.

In the third line, we begin by requiring that the cell heap $H$ satisfy
the abstract heap formula $\phi$, which formalizes the informal
reading of the abstract heap formulas given earlier. This satisfaction
relation follows the general style of separation logic quite closely; 
in a sense, our abstract heap formulas are giving a domain-specific
version of separation logic.

The last clause $heap(H)$ finally connects the cell heap, which is a
purely mathematical object, to the actual low-level heap the
implementation uses. We ask that the global counter reference
$counter$ point to an integer field equal to the size of the cell
heap, and then use the iterated separating conjunction $\forall^*$ to
require that for each cell in the cell heap, we have pointers to the
appropriate code, value, read and observer fields. The read and
observer fields point to values of type $\cellset$, each of which
represent the appropriate sets of cells.  Since none of the prior
clauses say anything about the local state, we also use the
$\mathit{refs}(\phi)$ function to take a formula, and assemble a
collection of points-to assertions $r \pointsto v$ from each
$\localref{r}{v}$ in our formula. (As a reminder, the specifications
of the set operations are given in Appendix A of this chapter.)

Note that the separation requirements in $\mathit{heap}(H)$ ensure
that every cell value $c$ in set of cells $D$ has a disjoint set of
pointer values. As a result, we do not have to specify this condition
explicitly, since its failure would falsify the precondition.

\begin{figure}
\mbox{}
\begin{tabbing}
$CellHeap = \Sigma$\=$ D \in \powersetfin{\ecell}.$ \\
               \>$(\Pi (\pack{\alpha}{\_}) \in D. ($\=${\codetype{\alpha}} \;\times$
                                         ${\opttype{\;\alpha}} \;\times$ 
                                         ${\powersetfin{\ecell}} \;\times$ 
                                         ${\powersetfin{\ecell}} \;\times$ 
                                         $\N)$ \\[1em]
       

$code = \pi_1$ \\
$value = \pi_2$ \\
$reads = \pi_3$ \\
$obs = \pi_4$ \\
$identity = \pi_5$ \\[1em]

$V_{(D, h)} = \comprehend{c \in D}{\exists v.\; value(h(c)) = \ctext{Some}(v)}$ \\
$R_{(D, h)} = \comprehend{(c,c') \in D}{ c' \in reads(h(c)) }$ \\
$O_{(D, h)} = \comprehend{(c,c') \in D}{ c' \in obs(h(c)) }$ \\[1em]

$\mathit{Fin}(n) = \comprehend{ i \in \N }{ i < n }$ \\[1em]

$unique(D,h) = \exists$\=$i : Fin(|D|) \to D.\; i \circ (identity \circ h) = id \; \land (identity \circ h) \circ i = id$ \\[1em]

$\satisfies{(D,h)}{\phi} = (D,h), D \models \phi$ \\[1em]

$H, D \models \localref{r}{v} \qquad \qquad$\=$\iff \top$ \\
$H, D \models I$                            \>$\iff \top$ \\
$H, D \models \phi \otimes \psi$            \>$\iff \exists D_1, D_2.\;$\=$D = D_1 \uplus D_2 
                                                      \land H, D_1 \models \phi
                                                      \land H, D_2 \models \psi$ \\
$H, D \models \cellneg{a}{\cmd}$               \>$\iff a \in D \land code(h(a)) = \cmd \land a \not \in V_H$ \\
$H, D \models \cellpos{a}{\cmd}{v}{r}$         \>$\iff $\=$ a \in D \land code(h(a)) = \cmd \;\land$ \\
\>      \>$\mathrm{if}\;r \subseteq V_H$ \\
\>      \>$\mathrm{then}\;value(h(a)) = \ctext{Some}\;v \land reads(h(a)) = r$ \\
\>      \>$\mathrm{else}\;a \not\in V_H$\\[1em]
 

$heap(D,h) = $ \\
\;\;$counter \pointsto |D| \;* $ \\
\;\;$\forall^* (\pack{\tau}{c}\mbox{ as }cell) \in D.\;$\=$\exists v_r, v_o : \cellset.\;$ \\
                         \>$c.code \pointsto code(h(cell))   \;* $ \\
                         \>$c.value \pointsto value(h(cell)) \;* $ \\
                         \>$c.reads \pointsto v_r \;* $ \\
                         \>$c.obs   \pointsto v_o \;* $ \\
                         \>$c.id    = identity(h(cell)) \;\land$ \\
                         \>$set(D, v_r, reads(h(cell))) \;\land$ \\
                         \>$set(D, v_o, obs(h(cell)))$ \\[1em]

$\mathit{refs}(I) \qquad\qquad\qquad$\=$= \emp$ \\
$\mathit{refs}(\phi \otimes \psi) $\>$= \mathit{refs}(\phi) * \mathit{refs}(\psi)$ \\
$\mathit{refs}(\cellneg{c}{\cmd}) $\>$= \emp$ \\
$\mathit{refs}(\cellpos{c}{\cmd}{v}{r}) $\>$= \emp$ \\
$\mathit{refs}(\localref{r}{v}) $\>$= r \pointsto v$ \\
\end{tabbing}

\caption{Definitions for Heap Invariant}
\label{heap-invariant}
\end{figure}

The global character of this invariant should be evident; we need to
talk about \emph{all} of the cells in the heap in order to state our
invariants. So it is not immediately clear that we have made much
progress towards a modular proof technique. However, we are actually
very close: with just two more ideas, we will be able to give a
solution to this problem.

\subsection{Frame Properties via Polymorphism}

As we mentioned earlier, our abstract heap formulas essentially give
us a small domain-specific separation logic. This means that in order
to reason locally over cell heaps, we need to find an
application-specific version of the frame rule for our library. 

To do this, we will adapt some ideas proposed by
Benton~\cite{benton}, and Birkedal and Yang~\cite{birkedal-yang}. They
suggested interpreting the frame rule of separation logic as a form of
quantification --- instead of having a separate frame rule that allows
adding a frame to any triple, they proposed that all of the atomic
rules of the program logic be replaced with rules possessing an extra
quantifier ranging over ``the rest of the heap'':

\begin{mathpar}
  \inferrule*[right=Example]
          { }
          { \forall R.\; \setof{ (e \pointsto v) * R } \;e := v'\; \setof{ (e \pointsto v') * R}}
\end{mathpar}

This quantifier is propagated through the proof, and any use of the
frame rule can be interpreted as instantiating the universal
quantifier appropriately. The reason this idea is fruitful for us is
that it will allow us to give a frame rule, even though the underlying
semantics of our library does not actually satisfy any analogues of
the traditional safety monotonicity and frame lemmas. For example, the
$\updatecell$ operation certainly does not act locally --- it
recursively traverses the observers set, possibly mutating a very
large part of the cell graph.

\subsection{Correctness of $\newcell$ and $\updatecell$}

In this subsection, I will prove the correctness of the two operations
in our interface which lie outside the $\codetype{\alpha}$
monad. Specifications and proofs of the operations in the monad will
follow, afterwards.

\subsubsection{Correctness of $\updatecell$}

We will now prove the soundness of the following triple specifying
$\updatecell$.

\begin{prop}{(Update Rule)}
For all cells $o$ and code expressions $\cmd$ and $\cmd'$, the following
triple is provable: 

\begin{tabbing}
$\forall \psi:\formula.\; $\=$\setof{G(\celleither{o}{\cmd'} \otimes \psi)}$ \\
                           \>$\run {\updatecell\;o\;\cmd}$ \\
                           \>$\setof{a:1.\; G(\cellneg{o}{\cmd} \otimes \psi)}$
\end{tabbing}
\end{prop}

\textbf{Proof Strategy.} The key to this proof is the conditional
interpretation of the $\cellpos{c}{\cmd}{v}{r}$ formula. When we evaluate
the $\updatecell$ command, we recursively find every cell which
depends on $o$, and modify it to be unready.

Now consider any positive cell formula in $\psi$ which reads $o$,
directly or indirectly. The satisfaction relation for $\phi$ tells us
that a positive formula must have everything in its read set be ready,
in order to represent a ready cell. So by changing $o$'s formula to
the unready state, we no longer require that positive formula
represent a ready cell. As a result, we can leave the entire frame
$\psi$ untouched, even though the physical heap it represents may have
been (quite drastically) modified.

However, before we can give a proper proof of this theorem, we need to
specify and prove correct the $\ctext{mark\_unready(c)}$ procedure,
which does the bulk of the work of the update function. The purpose of
this function is to set every cell transitively reachable from $c$ to
the unready state.

As with the proofs in the previous chapter, these follow the pattern 
of a lemma about partial orders, a lemma connecting it to the satisfaction
relation, and finally a correctness proof of the procedure. 

First, we will prove the fact that the order in which we delete
reachable subtrees doesn't matter. This is necessary since the 
algorithm will sequentially delete reachable sub-DAGs, and we
need to know that the effect of sequential deletion is equivalent
to a parallel one.  

\begin{lemma}{(Reachability in Deleted Graphs)}
Suppose we have $H = (D,h)$ such that $R^+_H$ is a strict partial
order, $R_H \subseteq V_H \times V_H$, $R^\dagger_H = O_H$, and
$\mathit{unique}(H)$.  Now, for any $X \subseteq D$, define $U^H_X =
\comprehend{d \in D}{(d, c) \in R^*_H \land c \in X}$ to be the set
of cells which transitively read any cell in $X$, and also define
$h|_X$ so that:
\begin{itemize}
\item $\mathit{code}(h|_X(c')) = \mathit{code}(h(c'))$
\item $\mathit{value}(h|_X(c')) = \IfThenElse{c' \in U^H_X}{\None}{\mathit{value}(h(c'))}$
\item $\mathit{reads}(h|_X(c')) = \IfThenElse{c' \in U^H_X}{\emptyset}{\mathit{reads}(h(c'))}$
\item $\mathit{obs}(h|_X(c')) = \IfThenElse{c' \in U^H_X}{\emptyset}{\mathit{obs}(h(c')) - U^H_X}$
\item $\mathit{identity}(h|_X(c')) = \mathit{identity}(h(c'))$
\end{itemize}

It is the case that $(d,c) \in R^*_{H|_X}$ if and only if $(d,c) \in R^*_H \land c \not\in U^H_X \land d \not\in U^H_X$. 
\end{lemma}

\begin{proof}

\begin{tabbedproof}
\oo $\Rightarrow$: \\
\ooo Assume $(d,c) \in R^*_{H|_X}$ \\
\ooo Therefore we have a sequence $(d, \ldots, c)$ in $R_{H|_X}$ \\
\ooo Now, we proceed by induction on the length of the sequence. \\
\ooo Case $n = 0$: \\
\oooo Then $c = d \in V_{H|_X}$.\\
\oooo Since $\mathit{value}(h|_{X}(c')) = \IfThenElse{c' \in U^H_X}{\None}{\mathit{value}(h(c'))}$, we know $c \not\in U^H_X$ \\
\ooo Case $n = k+1$: \\
\oooo Hence we have a sequence $(d, \ldots, c_k, c) \in R_{H|_X}$, such that \\
\oooo $(d, c_k) \in R^*_H$ and $d \not \in U^H_X$ and $c_k \not \in U^H_x$ \\ 
\oooo We know $c \in \mathit{reads}(h|_X(c_k)) = \IfThenElse{c_k \in U^H_X}{\emptyset}{\mathit{reads}(h(c_k))}$ \\
\oooo Since $c_k \not \in U^H_X$, we know $c \in \mathit{reads}(h(c_k))$, so $(c_k, c) \in R_H$ \\
\oooo Hence $(d, c) \in R^*_H$ \\
\oooo We know $c \not \in U^H_X$, since if it were then $c_k \in U^H_X$, which is contradictory \\
% 
% \ooo Each consecutive pair $(c_i, c_{i+1})$ satisfies $c_{i+1} \in \mathit{reads}(h|_X(c_i))$ \\
% \ooo We know $\mathit{reads}(h|_X(c_i) = \IfThenElse{c' \in U^H_X}{\emptyset}{\mathit{reads}(h(c_i))}$ \\
% \ooo Hence each $c_{i+1} \not\in U^H_X$ and $(c_i, c_{i+1}) \in R_H$ \\ 
% \ooo Hence $(d,c) \in R^*_H$ and $d \not \in U^H_X$ and $c \not \in U^H_X$ \\ 
\oo $\Leftarrow$: \\
\ooo Asssume $(d,c) \in R^*_H \land c \not\in U^H_X \land d \not\in U^H_X$. \\
\ooo So we have a sequence $(d, \ldots, c)$ with each pair in $R_H$ \\
% \ooo Suppose an intermediate element $c_i$ between $d$ and $c$ is in $U^H_X$ \\
% \oooo Then we have a sequence $(c, \ldots, c_i) \in R^*_H$ and a sequence $(c_i,x) \in R^*_X$ for some $x \in X$ \\ 
% \oooo Concatenating, we have a sequence $(c, \ldots, x) \in R^*_H$ with $x \in X$ \\
% \oooo This implies that $c \in U^H_X$, which is a contradiction \\
% \ooo Hence no element in the sequence $(d, \ldots, c)$ is in $U^H_X$ \\ 
\ooo Now, we will show $(d, \ldots, c) \in R^*_X$ by induction on the length \\
\ooo Case $n = 0$: \\
\oooo So $d = c \in V_{H|_X}$. \\
\oooo Since $d \not\in U^H_X$, we know $d \in V_H$ \\
\oooo Hence $(d,c) \in R^*_H$ \\
\ooo Case $n = k+1$: \\
\oooo We have $(d, \ldots, c_k, c) \in R^*_H \land c \not\in U^H_X \land d \not\in U^H_X$. \\
\oooo If $c_k \in U^H_X$ then $d \in U^H_X$, which is a contradiction \\
\oooo Hence $c_k \not\in U^H_X$ \\
\oooo By induction, $(d, \ldots, c_k) \in R^*_H$ \\
\oooo We know $c \in \mathit{reads}(h|_X(c_k))$ \\ 
\oooo Hence $c \in \IfThenElse{c_k \in U^H_X}{\emptyset}{\mathit{reads}(h(c_k))}$ \\
\oooo Hence $c \in \mathit{reads }(h(c_k))$ \\
\oooo Hence $(d, c) \in R^*_H$ \\ 
% \ooo For every $(c_k, c_{k+1}) \in (d, \ldots, c)$, we know $c_{k+1} \in \mathit{reads}(h(c_k))$ \\
% \ooo So we know $c_{k+1} \in \IfThenElse{c_k \in U^H_X}{\emptyset}{\mathit{reads}(h(c_k))}$ \\
% \ooo Hence for every $(c_k, c_{k+1}) \in (d, \ldots, c)$, we know $c_{k+1} \in \mathit{reads}(h|_X(c_k))$ \\
% \ooo Hence $(d,c) \in R^*_{H|_X}$ \\
\end{tabbedproof}
\end{proof}

\begin{lemma}{(Path Union)}
Suppose we have $H = (D,h)$ such that $R^+_H$ is a strict partial
order, $R_H \subseteq V_H \times V_H$, $R^\dagger_H = O_H$, and
$\mathit{unique}(H)$. Then $c \in U^{H|_{X}}_{\setof{z}} \vee
(c \not\in U^{H|_{X}}_{\setof{z}} \land c \in U^H_{X})$
is logically equivalent to $c \in U^H_{\setof{z}} \vee c \in U^H_{X}$.
\end{lemma}


\begin{proof}
\begin{tabbedproof}
\oo Note $c \in U^{H|_{X}}_{\setof{z}}$ is equivalent to $(c,z) \in R^*_{H|_{X}}$, \\
\oo which is equivalent to  $(c, z) \in R^*_H \land c \not\in U^H_{X} \land z \not\in U^H_{X}$, \\
\oo which is equivalent to  $c \in U^H_{\setof{z}} \land c \not\in U^H_{X} \land z \not\in U^H_{X}$, \\
\oo Hence this condition is equivalent to  \\
\oox $c \in U^H_{\setof{z}} \land c \not\in U^H_{X} \land z \not\in U^H_{X} \vee $ \\
\oox $(\lnot(c \in U^H_{\setof{z}} \land c \not\in U^H_{X} \land z \not\in U^H_{X}) \land c \in U^H_{X})$   \\
\oo Simplifying the second clause gives us \\
\oox $(c \in U^H_{\setof{z}} \land c \not\in U^H_{X} \land z \not\in U^H_{X}) \vee c \in U^H_{X}$ \\
\oo We want to show this is equivalent to $c \in U^H_{\setof{z}} \vee c \in U^H_{X}$ \\
\oo One direction of the equivalence trivial. To prove the other, assume $c \in U^H_{\setof{z}} \vee c \in U^H_{X}$ \\
\ooo Now branch on this assumption \\
\ooo Case $c \in U^H_{X}$: \\
\oooo Then $c \in U^H_{X}$ \\
\ooo Case $c \in U^H_{\setof{z}}$: \\ 
\oooo Branch on whether $c \in U^H_{X}$ \\
\oooo Case $c \in U^H_{X}$: \\
\ooooo Then $c \in U^H_{X}$ \\
\oooo Case $c \not\in U^H_{X}$: \\
\ooooo Branch on whether $z \in U^H_{X}$ \\
\ooooo Case $z \in U^H_{X}$: \\
\oooooo Since $c \in U^H_{\setof{z}}$, there is a sequence $(c, \ldots, z) \in R^*_H$ \\
\oooooo Since $z \in U^H_{X}$, there is a sequence $(z, \ldots, x) \in R^*_H$ for some $x \in X$ \\
\oooooo By concatenation, there is a sequence $(c, \ldots, x) \in R^*_H$ for some  $x \in X$ \\
\oooooo Hence $c \in U^H_{X}$, which is a contradiction \\
\ooooo Case $z \in U^H_{X}$: \\
\oooooo Hence $c \in U^H_{\setof{z}} \land c \not\in U^H_{X} \land z \not\in U^H_{X}$ \\
\end{tabbedproof}
\end{proof}

\begin{lemma}{(Sequentialization)}
Suppose we have $H = (D,h)$ such that $R^+_H$ is a strict partial
order, $R_H \subseteq V_H \times V_H$, $R^\dagger_H = O_H$, and
$\mathit{unique}(H)$.

Then $H|_X|_Y = H|_{X \cup Y}$.
\end{lemma}

\begin{proof}
We prove this by induction on the size of $Y$. 
\begin{tabbedproof}
\oo Case $Y = \emptyset$: \\
\ooo Immediate \\
\oo Case $Y = Z \uplus \setof{z}$: \\
\ooo By induction, we know that $H|_X|_Z = H|_{X \cup Z}$ \\
\ooo Consider whether $z \in X \cup Z$ \\
\ooo Case $z \in X \cup Z$: \\
\oooo Then $U^{H|_{X \cup Z}}_{\setof{z}} = \emptyset$ \\
\oooo Therefore $H|_{X \cup Z}|_{\setof{z}} = H|_{X \cup Z} = H|_{X \cup Y}$  \\ 
\ooo Case $z \not\in X \cup Z$: \\
\oooo To show that $H|_{X \cup Z}|_{\setof{z}} = H|_{\setof X \cup Z \cup \setof{z}} $, we need to show $h|_{X \cup Z}|_{\setof{z}} = h|_{\setof X \cup Z \cup \setof{z}}$ \\
\oooo 1. Consider $\mathit{reads}(h|_{X \cup Z}|_{\setof{z}}(c))$ \\
\ooooo $\mathit{reads}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^{H|_{X \cup Z}}_{\setof{z}}}{\emptyset}{\mathit{reads}(h|_{X \cup Z}(c))}$ \\
\ooooo $\mathit{reads}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^{H|_{X \cup Z}}_{\setof{z}}}{\emptyset}{\IfThenElse{c \in U^H_{X \cup Z}}{\emptyset}{\mathit{reads}(h(c))}}$ \\
\ooooo $\mathit{reads}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^{H|_{X \cup Z}}_{\setof{z}} \vee (c \not\in U^{H|_{X \cup Z}}_{\setof{z}} \land c \in U^H_{X \cup Z})}{\emptyset}{\mathit{reads}(h(c))}$ \\
\ooooo By the path union lemma, \\
\ooooox $\mathit{reads}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^H_{X \cup Z \setof{z}}}{\emptyset}{\mathit{reads}(h(c))}$ \\
\ooooo Hence $\mathit{reads}(h|_{X \cup Z}|_{\setof{z}}(c)) = \mathit{reads}(h|_{X \cup Z \cup \setof{z}})$ \\
\oooo 2. Consider $\mathit{value}(h|_{X \cup Z}|_{\setof{z}}(c))$ \\
\ooooo $\mathit{value}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^{H|_{X \cup Z}}_{\setof{z}}}{\None}{\mathit{value}(h|_{X \cup Z}(c))}$ \\
\ooooo $\mathit{value}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^{H|_{X \cup Z}}_{\setof{z}}}{\None}{\IfThenElse{c \in U^H_{X \cup Z}}{\None}{\mathit{value}(h(c))}}$ \\
\ooooo $\mathit{value}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^{H|_{X \cup Z}}_{\setof{z}} \vee (c \not\in U^{H|_{X \cup Z}}_{\setof{z}} \land c \in U^H_{X \cup Z})}{\None}{\mathit{value}(h(c))}$ \\
\ooooo By the path union lemma, \\
\ooooox $\mathit{value}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^H_{X \cup Z \setof{z}}}{\None}{\mathit{value}(h(c))}$ \\
\ooooo Hence $\mathit{value}(h|_{X \cup Z}|_{\setof{z}}(c)) = \mathit{value}(h|_{X \cup Z \cup \setof{z}})$ \\
\oooo 3. Consider $\mathit{obs}(h|_{X \cup Z}|_{\setof{z}}(c))$ \\
\ooooo $\mathit{obs}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^{H|_{X \cup Z}}_{\setof{z}}}{\emptyset}{\mathit{obs}(h|_{X \cup Z}(c)) - U^{H|_{X \cup Z}}_{\setof{z}}}$ \\
\ooooo $\mathit{obs}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^{H|_{X \cup Z}}_{\setof{z}}}{\emptyset}{\IfThenElse{c \in U^H_{X \cup Z}}{\emptyset}{\mathit{obs}(h|_{X \cup Z}(c)) - U^{H|_{X \cup Z}}_{\setof{z}}}}$ \\
\ooooo $\mathit{obs}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^{H|_{X \cup Z}}_{\setof{z}} \vee (c \not\in U^{H|_{X \cup Z}}_{\setof{z}} \land c \in U^H_{X \cup Z})}{\emptyset}{\mathit{obs}(h|_{X \cup Z}(c)) - U^{H|_{X \cup Z}}_{\setof{z}}}$ \\
\ooooo By the path union lemma, \\
\ooooox $\mathit{obs}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^H_{X \cup Z \setof{z}}}{\emptyset}{\mathit{obs}(h|_{X \cup Z}(c)) - U^{H|_{X \cup Z}}_{\setof{z}}}$ \\
\ooooo So $\mathit{obs}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^H_{X \cup Z \setof{z}}}{\emptyset}{\mathit{obs}(h(c)) - U^H_{X \cup Z} - U^{H|_{X \cup Z}}_{\setof{z}}}$ \\
\ooooo So $\mathit{obs}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^H_{X \cup Z \setof{z}}}{\emptyset}{\mathit{obs}(h|_{X \cup Z}(c)) - (U^H_{X \cup Z} \cup U^{H|_{X \cup Z}}_{\setof{z}})}$ \\
\ooooo By the path union lemma, \\
\ooooo $\mathit{obs}(h|_{X \cup Z}|_{\setof{z}}(c)) = \IfThenElse{c \in U^H_{X \cup Z \setof{z}}}{\emptyset}{\mathit{obs}(h|_{X \cup Z}(c)) - U^H_{X \cup Z \cup \setof{z}}}$\\
\ooooo Hence $\mathit{obs}(h|_{X \cup Z}|_{\setof{z}}(c)) = \mathit{obs}(h|_{X \cup Z \cup \setof{z}})$ \\
\end{tabbedproof}
\end{proof}

\begin{lemma}{(Transitive Invalidation Preserves Order Structure)}
Suppose we have $H = (D,h)$ such that 
\begin{enumerate}
\item $R^+_H$ is a strict partial order 
\item $R_H \subseteq V_H \times V_H$
\item $R^\dagger_H = O_H$ 
\item $\mathit{unique}(H)$
\end{enumerate}
\noindent For any cell $c \in D$, it is the case that for $H' = (D, h') = H|_{\setof{c}}$, we have
\begin{enumerate}
\item $R^+_{H'}$ is a strict partial order 
\item $V_{H'} = V_H - U$
\item $R_{H'} \subseteq V_{H'} \times V_{H'}$
\item $R^\dagger_{H'} = O_{H'}$ 
\item $\mathit{unique}(H')$
\end{enumerate}
\end{lemma}

\begin{proof}
\begin{enumerate}
\item $R^+_{H'}$ is a strict partial order 
  \begin{tabbedproof}
    \oo This follows if $R^+_{H'}$ is transitive relation without any $(a,a) \in R^+_H$ \\
    \oo Since it is a transitive closure, it is a transitive relation \\
    \oo To show that there is no $a \in D$ such that $(a,a) \in R^+_{H'}$, \\
    \ox we will show that $R^+_{H'} \subseteq R^+_H$ \\
    \oo Assume that $(a_0,b) \in R^+_{H'}$ \\
    \oo Then there is a sequence $a_0, \ldots, a_k$ such that $b = a_k$ and each $a_{i+1} \in \mathit{reads}(h'(a_i))$ \\
    \oo Suppose we have an arbitrary $a_i, a_{i+1}$, such that $a_{i+1} \in \mathit{reads}(h'(a_i))$ \\
    \oo Hence it follows that $a_i \not\in U$, since otherwise $\mathit{reads}(h'(a_i)) = \emptyset$ \\
    \oo Hence it follows that $\mathit{reads}(h'(a_i)) = \mathit{reads}(h(a_i))$ for $i < k$ \\
    \oo Hence $a_0, \ldots, a_k$ such that $b = a_k$ and each $a_{i+1} \in \mathit{reads}(h(a_i))$ \\
    \oo Hence $(a_0, b) \in R^+_H$ \\
    \oo Hence $a_0 \not= b$, since $R^+_H$ strict partial order 
  \end{tabbedproof}

\item $V_{H'} = V_H - U$
  \begin{tabbedproof}
    \oo Suppose $a \in V_{H'}$ \\
    \ooo Then $\mathit{value}(h'(a)) = \Some(v)$ for some $v$ \\
    \ooo Hence $a \not\in U$ \\
    \ooo Hence $\mathit{value}(h'(a)) = \mathit{value}(h(a))$  \\
    \ooo Hence $a \in V_H$ \\
    \ooo Hence $a \in V_{H} - U$ \\
    \oo Conversely, suppose $a \in V_{H} - U$ \\
    \ooo Then $\mathit{value}(h(a)) = \Some(v)$ for some $v$ \\
    \ooo But since $a \not\in U$, we know $\mathit{value}(h'(a)) = \mathit{value}(h(a)) = \Some(v)$ \\
    \ooo Hence $a \in V_{H'}$ 
  \end{tabbedproof}

\item $R_{H'} \subseteq V_{H'} \times V_{H'}$
  \begin{tabbedproof}
    \oo Assume $(a,b) \in R_{H'}$ \\
    \oo Hence $b \in \mathit{reads}(h'(a))$ \\
    \oo Hence we know that $a \not\in U$ \\
    \oo Hence we know that $b \in \mathit{reads}(h(a))$ and $(a,b) \in R_H$\\
    \oo Hence we know that $a \in V_H$ and $b \in V_H$\\
    \oo Hence we know that $a \in V_H - U$ \\
    \oo Hence we know that $a \in V_{H'}$ \\
    \oo Since $U$ is transitively-closed, we know that if $b \in U$, then $a \in U$ \\
    \oo Since $a \not\in U$, we know that $b \not\in U$ \\
    \oo Hence we know that $b \in V_H - U$ \\
    \oo Hence we know that $b \in V_{H'}$ 
  \end{tabbedproof}

\item $R^\dagger_{H'} = O_{H'}$ 
  \begin{tabbedproof}
    \oo Suppose that $(a, b) \in R^\dagger_{H'}$. \\
    \ooo We want to show that $(a, b) \in O_{H'}$ \\
    \ooo We know that $(b, a) \in R_{H'}$ \\
    \ooo We know that $a \in \mathit{reads}(h'(b))$ \\
    \ooo Since $R_{H'} \subseteq V_{H'} \times V_{H'}$, we know $a \not\in U$ and $b \not \in U$ \\
    \ooo Hence $a \in \mathit{reads}(h(b))$ \\ 
    \ooo Hence $b \in \mathit{obs}(h(a))$ \\
    \ooo Hence $b \in \mathit{obs}(h'(a))$ \\
    \ooo Hence $(a,b) \in O_{H'}$ \\
    \oo Suppose that $(a, b) \in O_{H'}$. \\
    \ooo We want to show that $(a,b) \in R^\dagger_{H'}$, so we want $(b,a) \in R_{H'}$ \\
    \ooo Since $(a,b) \in O_{H'}$, we know $b \in \mathit{obs}(h'(a))$ \\
    \ooo Hence $a \not\in U$ and $b \in \mathit{obs}(h(a)) - U$ \\
    \ooo So $b \in \mathit{obs}(h(a))$ and $b \not \in U$ \\
    \ooo So $(a,b) \in O_H$ \\
    \ooo So $(b,a) \in R_H$, and so $a \in \mathit{reads}(h(b))$ \\
    \ooo Since $b \not\in U$, $\mathit{reads}(h'(b)) = \mathit{reads}(h(b))$ \\
    \ooo Therefore $a \in \mathit{reads}(h'(a))$, and so $(b,a) \in R_{H'}$ \\
    \ooo Therefore $(a,b) \in R^\dagger_{H'}$ 
  \end{tabbedproof}

\item $\mathit{unique}(h) = \mathit{unique}(h')$.

This is immediate, since $\mathit{identity}(h) = \mathit{identity}(h')$ 
\end{enumerate}
\end{proof}


\begin{lemma}{(Updating the Abstract Heap)}
Suppose we have $H = (D,h)$ and $H, D', \models \phi \otimes
\celleither{c}{\cmd}$ and $c \in D$. Then for $H' = (D, h') = H|_{\setof{c}}$, we
have $H', D' \models \phi \otimes \cellneg{c}{\cmd}$.
\end{lemma}

\begin{proof}
\begin{tabbedproof}
\oo Assume we have $H, D' \models \phi \otimes \celleither{c}{\cmd}$ \\
\oo Then we have $D_1, D_2$ such that $D_1 \uplus D_2 = D'$ and $H, D_1 \models \phi$ and $H, D_2 \models \celleither{c}{\cmd}$ \\
\oo Note that this means $c$ is not in the domain of $\phi$ \\
\oo First, consider $(D,h), D_1 \models \phi$ \\
\ooo We will show by induction that $(D,h'), D_1 \models \phi$ \\
\ooo Case $\phi = I$ or $\phi = \localref{r}{v}$: \\
\oooo In this case, by the definition of satisfaction, $(D,h), D_1 \models I$ or $(D,h), D_1 \models \localref{r}{v}$\\
\ooo Case $\phi = \psi \otimes \theta$: \\
\oooo In this case, we have $D'_1, D'_2$ such that $D_1 = D'_1 \uplus D'_2$ and \\
\oooox $(D,h), D'_1 \models \psi$ \\
\oooox $(D,h), D'_2 \models \theta$ \\
\oooo By induction, we know that \\
\oooox $(D,h'), D'_1 \models \psi$ \\
\oooox $(D,h'), D'_2 \models \theta$ \\
\oooo Hence by the definition of satisfaction, $(D,h'), D_1 \models \psi \otimes \theta$ \\
\ooo Case $\phi = \cellneg{a}{\cmd}$: \\
\oooo In this case, we know $a \in D_1$ and $\mathit{code}(h(a)) = \cmd$ and $a \not\in V_{(D,h)}$ \\
\oooo Hence $\mathit{value}(h(a)) = \None$, and so $\mathit{value}(h'(a)) = \None$ \\
\oooo Since $R_H \subseteq V_H \times V_H$, it follows  $U = \emptyset$ \\
\oooo Hence $h' = h$ \\
\oooo Hence $(D,h'), D_1 \models \cellneg{a}{\cmd}$ \\
\ooo Case $\phi = \cellpos{a}{\cmd}{v}{r}$: \\
\oooo Now, consider whether $r \subseteq V_H$ \\
\oooo If $r \subseteq V_H$: \\
\ooooo We know $a \in D_1$ and $\mathit{code}(h(a)) = \cmd$ and 
       $\mathit{value}(h(a)) = \Some(v)$ and $\mathit{reads}(h(a)) = r$ \\
\ooooo So $a \in V_H$. \\
\ooooo Now consider whether $a \in U$ \\
\ooooo If $a \in U$: \\
\oooooo First, note $a \not\in V_{(D,h')}$ \\
\oooooo Then $(a, c) \in R^*_H$ \\
\oooooo Since $c \not= a$ (since $c$ is not in the domain of $\phi$), we know $(a, c) \in R^+_H$ \\
\oooooo Hence there is a $d \in r$ such that $(a,d) \in R_H$ and $(d, c) \in R^*_H$  \\
\oooooo Hence $d \in r$ and $d \in U$ and $\mathit{value}(h'(d)) = \None$, and so $d \not\in V_{(D,h')}$\\
\oooooo Hence $r \not\subseteq V_{(D, h')}$ \\
\oooooo Hence $(D,h'), D_1 \models \cellpos{a}{\cmd}{v}{r}$ \\
\ooooo If $a \not\in U$: \\
\oooooo Then note $a \in V_{(D,h')}$ \\
\oooooo Furthermore, $(c, a) \not\in R^*_H$ \\
\oooooo Hence there is no $d \in r$ such that $(c, d) \in R^*_H$  \\
\oooooo Hence $r \cap U = \emptyset$ \\
\oooooo Hence $r \subseteq V_{(D,h')}$ \\
\oooooo Hence $(D,h'), D_1 \models \cellpos{a}{\cmd}{v}{r}$ \\
\oooo If $r \not\subseteq V_H$: \\
\ooooo Then we know $a \in D_1$ and $\mathit{code}(h(a)) = \cmd$ and $a \not\in V_H$  \\
\ooooo Since $R_H \subseteq V_H \times V_H$, it follows that $\comprehend{c'\in D}{(a,c') \in R} = \emptyset$. \\
\ooooo Hence $U = \emptyset$ \\
\ooooo Hence $h' = h$ \\
\ooooo Hence $(D,h'), D_1 \models \cellpos{a}{\cmd}{v}{r}$ \\
\oo Next, consider $(D,h), D_2 \models \celleither{c}{\cmd}$: \\
\ooo Since $(c, c) \in R^*_H$,  we know $c \in U$ \\
\ooo Hence it follows $c \not\in V_{(D, h')}$ \\
\ooo Hence $(D,h'), D_2 \models \cellneg{c}{\cmd}$ \\
\oo Therefore, it follows that $(D,h'), D' \models \phi \otimes \cellneg{c}{\cmd}$ \\ 
\end{tabbedproof}
\end{proof}


\begin{lemma}{(The $\ctext{mark\_unready}$ procedure preserves order structure)}
Suppose $H = (D,h)$ where $R^+_H$ is a strict partial order,
$O^\dagger_H = R_H$, $R_H \subseteq V_H \times V_H$ and
$\mathit{unique}(H)$. Then for any $c \in D$ and $H' = (D, h') =
H|_{\setof{c}}$, the $\ctext{mark\_unready}$ function satisfies the following specification:

\begin{displaymath}
\mspec{\mathit{heap}(H)}{\ctext{mark\_unready}(c)}{a:\unittype}{\mathit{heap}(D,h')}
\end{displaymath}
  
\end{lemma}

\begin{proof}
We will be to prove this function using the fixed point induction
rule, using precisely this specification. (In fact, the function is
totally correct, since it is always called on arguments higher up in
the partial ordering on cells, but tracking the termination metric in
detail obscures the key ideas.)

Now we'll proceed line-by-line through the function body of $\ctext{mark\_unready}(c)$: 

\begin{tabbedproof}
\oo We know \\
\oox $R^\dagger_H = O_H$ \\
\oox $R^+_H$ strict partial order \\
\oox $R_H \subseteq V_H \times V_H$ \\
\oox $\mathit{unique}(H)$ \\
\oox $\mathit{heap}(H)$ \\
\ooo Consider whether $c$ is in $V_H$ \\
\ooo Suppose $c \not\in V_H$: \\
\oooo Then $U = \emptyset$, since $R_H \subseteq V_H \times V_H$ \\ 
\oooo Therefore $H'$ is equal to $H$ \\
\oooo Since $R_H \subseteq V_H \times V_H$, we know $\mathit{reads}(h'(c)) = \mathit{obs}(h'(c)) = \emptyset$ \\
\oooo $[\unpack{\alpha}{a}{c}{}$ \\
\oooo Now, we know that $c = \pack{\alpha}{a}$ \\
\oooo $\letv{os}{[!(a.obs)]}{}$ \\
\oooo $\letv{rs}{[!(a.reads)]}{}$ \\
\oooo From the definition of $\mathit{heap}(H)$, we know that  \\
\oooo $\mathit{set}(D, os, \emptyset)$ and $\mathit{set}(D, rs, \emptyset)$ \\
\oooo Simplifying using the axioms for sets, lines 8 and 9 of Figure~\ref{notification-implementation-update} are no-ops \\
\oooo $\letv{\_}{[a.value := \None]}{}$ \\
\oooo $\letv{\_}{[a.reads := \emptyset]}{}$ \\
\oooo $a.obs := \emptyset]$ \\
\oooo None of these assignments have any effect on the validity of $\mathit{heap}(H')$ \\
\ooo Suppose whether $c \in V_H$: \\
\oooo $[\unpack{\alpha}{a}{c}{}$ \\
\oooo Now, we know that $c = \pack{\alpha}{a}$ \\
\oooo $\letv{os}{[!(a.obs)]}{}$ \\
\oooo $\letv{rs}{[!(a.reads)]}{}$ \\
\oooo From the definition of $\mathit{heap}(H)$, we know that  \\
\oooo $\mathit{set}(D, os, \mathit{obs}(h(c)))$ and $\mathit{set}(D, rs, \mathit{reads}(h(c)))$ \\
\oooo Now, by the equational axioms in the cellset interface, $\ctext{iterseq\;mark\_unready}\;os$ \\
\ooox is equal to a sequence of calls to $\ctext{mark\_unready}$, once for each element of $\mathit{obs}(h(c))$\\
\oooo By induction on the size of $\mathit{obs}(h(c))$, we end in a logical state $(D, h|_{os})$, \\
\ooox which also preserves the order structure, and a physical state $\mathit{heap}(D, h|_{\setof{os}})$  \\
\oooo Hence in $H' = (D,h|_{\setof{os}})$, every $c'$ which read $c$ in $H$ is no longer in $V_{H'}$ \\ 
\oooo As a result $U^{H'}_{\setof{c}} = \setof{c}$ \\ 
\oooo Since $R_H$ was a strict partial order, $c$ is still in $V_{H'}$ \\
\oooo Therefore consider $h'' = h'|_{\setof{c}}$, which is equivalent to   \\
\oooox $\mathit{value}(h'') = \semfun{c'}{\IfThenElse{c' = c}{\None}{\mathit{value}(h'(c'))}}$ \\
\oooox $\mathit{reads}(h'') = \semfun{c'}{\IfThenElse{c' = c}{\emptyset}{\mathit{reads}(h'(c'))}}$ \\
\oooox $\mathit{obs}(h'') = \semfun{c'}{\IfThenElse{c'\in \mathit{obs}(h(c))}{\emptyset}{\mathit{obs}(h'(c')) - \setof{c}}}$ \\
\oooo Likewise, by the equational axiom in the cellset interface, $\ctext{iterseq}\;(\ctext{remove\_obs}\;cell)\;rs$ \\
\ooox is equal to a sequence of calls to $\ctext{remove\_obs}$, once for each element of $\mathit{reads}(h'(c))$\\
\oooo $\letv{\_}{[a.value := \None]}{}$ \\
\oooo $\letv{\_}{[a.reads := \emptyset]}{}$ \\
\oooo $a.obs := \emptyset]$ \\
\oooo These updates then ensure that $\mathit{heap}(D, h'')$ is satisfied. \\
\end{tabbedproof}
\end{proof}

\begin{lemma}{(Correctness of $\ctext{mark\_unready}$)}
The $\ctext{mark\_unready}$ function satisfies the following specification:   
\begin{displaymath}
\mspec{G(H, \phi \otimes \celleither{c}{\cmd})}{\ctext{mark\_unready}}{a:\unittype}{\exists H'.\;G(H', \phi \otimes \cellneg{c}{\cmd})}
\end{displaymath}
\end{lemma}

\begin{proof}
  This follows immediately from the previous lemma, together with the lemma about updating the 
abstract heap. 
\end{proof}


\begin{lemma}{(Updating Negative Formulas)}
Suppose we have  $H = (D,h)$ and $H, D' \models \phi \otimes \cellneg{c}{\cmd}$. Then, if
we define $h'$ such that $\mathit{code}(h'(c)) = \cmd'$ and is equal to $h$ otherwise, 
it follows that with $H' = (D,h')$, we have $H', D' \models \phi \otimes \cellneg{c}{\cmd'}$. 
\end{lemma}

\begin{proof}
  \begin{tabbedproof}
    \oo Assume $H, D' \models \phi \otimes \cellneg{c}{\cmd}$. \\
    \ooo So we have $D_1, D_2$ such that $D' = D_1 \uplus D_2$ and $H, D_1 models \phi$ and $H, D_2 \models \cellneg{c}{\cmd}$ \\
    \ooo Since $H, D_2 \models \cellneg{c}{\cmd}$, we know that $c \in D_2$ and $c \not\in D_1$ \\
    \ooo Now proceed by induction on $\phi$: \\
    \ooo Case $\phi = I$: \\
    \oooo In this case, it is immediate that $H', D_1 \models I$ \\
    \ooo Case $\phi = \psi \otimes \theta$: \\
    \oooo In this case, we have $D_3, D_4$ such that $D_1 = D_3 \uplus D_4$ and  \\
    \oooox $H, D_3 \models \psi$ and $H, D_4 \models \theta$ \\
    \oooo So by induction we have $H', D_3 \models \psi$ and $H', D_4 \models \theta$ \\
    \oooo Hence $H', D_1 \models \phi$\\
    \ooo Case $\phi = \cellneg{c'}{\cmd}$: \\
    \oooo We know $c' \in D_1$ \\
    \oooo We know that $c' \not= c$. Hence $\mathit{code}(h'(c')) = \mathit{code}(h(c))$ \\
    \oooo Hence $H', D_1 \models \cellneg{c'}{\cmd}$ \\
    \ooo Case $\phi = \cellpos{c'}{\cmd}{v}{r}$: \\
    \oooo We know that $c' \in D_1$ and hence $c \not= c'$ \\
    \oooo Hence $\mathit{code}(h'(c')) = \mathit{code}(h(c))$ \\
    \oooo Furthermore, $V_{H'} = V_H$ since $\mathit{value} \circ h' = \mathit{value} \circ h$\\
    \oooo Also $\mathit{reads} \circ h' = \mathit{reads} \circ h$ \\
    \oooo Hence $H', D_1 \models \cellpos{c'}{\cmd}{v}{r}$: \\
    \ooo Therefore $H', D_1 \models \phi$ \\
    \ooo Now, we want to show $H', D_2 \models \cellneg{c}{\cmd'}$ \\
    \oooo We know $c \in D_2$ \\
    \oooo Furthermore, $\mathit{code}(h'(c)) = \cmd'$ \\
    \oooo Hence $H', D_2 \models \cellneg{c}{\cmd'}$ \\
    \ooo Hence $H', D' \models \phi \otimes \cellneg{c}{\cmd'}$ 
  \end{tabbedproof}
\end{proof}

\begin{lemma}{(Update Rule)}
For all cells $o$ and code expressions $\cmd$ and $\cmd'$, the following
triple is provable: 

\begin{tabbing}
$\forall \psi:\formula.\; $\=$\setof{G(\celleither{o}{\cmd'} \otimes \psi)}$ \\
                           \>$\run {\updatecell\;o\;\cmd}$ \\
                           \>$\setof{a:1.\; G(\cellneg{o}{\cmd} \otimes \psi)}$
\end{tabbing}
\end{lemma}

\begin{proof}
This follows immediately from first applying the specification of $\ctext{mark\_unready}$, 
and then using the lemma that updating negative lemmas works as expected. 
\end{proof}


\subsubsection{Correctness of $\newcell$}

We can prove the soundness of a similar specification for $\newcell$ as
well:

\begin{prop}{(New Cell Rule)}
For all code expressions $\cmd$ of type $\alpha$, the following specification is provable: 
\begin{tabbing}
$\forall \psi:\formula.\; $\=$\setof{G(\psi)}$ \\
                           \>$\run {\newcell\;\cmd}$ \\
                           \>$\setof{a:\celltype{\alpha}.\; G(\cellneg{a}{\cmd} \otimes \psi)}$
\end{tabbing}
\end{prop}

\begin{proof}
This is much easier than $\updatecell$: we just need to allocate a new
numeric id for the new cell, and show that the extended cell heap
continues to satisfy all of the expected properties.

Concretely, suppose that $G(\psi) = \mathit{Inv}{(H, \psi)}$ for some
$H = (D,h)$. Now, by the invariant, we know that each cell in $D$ has
a unique numeric id somewhere in the range from $0$ to $|D|-1$. Then,
on lines 29-30 of Figure~\ref{notification-implementation}, we
increment the global counter by 1, and let $id = |D|$.  Then, on lines
31-34, we allocate a pointer $\mathit{code}$ to the code $\cmd$, a
pointer $\mathit{value}$ to $\None$ (to indicate the unitialized
state), as well as pointers to $\mathit{read}$ and $\mathit{obs}$ to
empty read and observer sets.

At line 35, all of these values are bound to variables in scope, so we
can define $H' = (D',h')$, where $\mathit{ec} = \pack{\tau}{\mathit{(code, value, read, obs, id)}}$, 
and 
\begin{displaymath}
(D',h') = (D \cup \setof{\mathit{ec}}, h' = [h|\mathit{ec}: (\cmd, \None, \emptyset, \emptyset, id)])
\end{displaymath}

Then, it is easy to show that the modified heap realizes $H'$ --- the
only fact that does not carry over immediately are the predicates
establishing the the read and observer sets are implemented
correctly. This is because they held for world $D$, and we are now in
world $D'$. Happily, we required as an axiom that $(W \subseteq W')
\implies \mathit{set}(W, v, S) \implies \mathit{set}(W', v, S)$.

Finally, we need to show that $\cellneg{a}{\cmd} \otimes \psi$ is
satisfied by $H'$. This follows from an easy induction on $\psi$:
since $h'$ is just an extension of $h$ with $V_{H'} = V_H$, none
of the conditionals or function calls in the cell predicates have
different results, which means that the truth-values they define
are unchanged. 

Then we can hide $H'$ behind an existential to establish the postcondition. 
\end{proof}

\begin{figure}
\mbox{}
\begin{mathpar}
  \inferrule*[right=Ready]
            {\forall a' \in r.\; \exists v.\; \ready{\phi}{a'}{v}}
            {\ready{\phi \otimes \cellpos{a}{\cmd}{v}{r}}{a}{v}}
  \\
  \\
  \inferrule*[right=UnreadyPos]
            {\exists a' \in r.\; \unready{\phi}{a'}}
            {\unready{\phi \otimes \cellpos{a}{\cmd}{v}{r}}
                     {a}}
  \and
  \inferrule*[right=UnreadyNeg]
            { }
            {\unready{\phi \otimes \cellneg{a}{\cmd}}{a}}
\end{mathpar}
\caption{Ready and Unready Judgments}
\label{readiness}
\end{figure}

\begin{figure}
\mbox{}
  \begin{displaymath}
    \begin{array}{lcl}
      \closed{I}{s} & = & \top \\
      \closed{\phi \otimes \psi}{s} & = & \closed{\phi}{s} \land \closed{\psi}{s} \\ 
      \closed{\localref{r}{v}}{s} & = & \top \\
      \closed{\cellneg{a}{\cmd}}{s} & = & \top \\
      \closed{\cellpos{a}{\cmd}{v}{r}}{s} & = & r \subseteq s \\
    \end{array}
  \end{displaymath}
\caption{Closedness predicate}
\label{closedness}  
\end{figure}

\begin{figure}
\mbox{}
  \begin{displaymath}
    \begin{array}{lcl}
      R(s, I)                 & = & I \\
      R(s, \phi \otimes \psi) & = & R(s, \phi) \otimes R(s, \psi) \\
      R(s, \localref{r}{v})   & = & \localref{r}{v} \\
      R(s, \cellneg{a}{\cmd})    & = & \cellneg{a}{\cmd} \\
      R(s, \cellpos{a}{\cmd}{v}{r}) & = & \left\{\begin{array}{ll}
                                                \cellpos{a}{\cmd}{v}{r} 
                                              & \mbox{if } s \cap r = \emptyset \\
                                                \cellneg{a}{\cmd}
                                              & \mbox{otherwise}
                                              \end{array}
                                       \right.
    \end{array}
  \end{displaymath}
\caption{Definition of the Ramification Operator $R$}
\label{ramify-def}
\end{figure}

\section{Ramified Frame Properties}

The proof strategy of the previous section is sufficient for
$\newcell$ and $\updatecell$, but is not adequate for defining a frame
property for $\codetype{\alpha}$ expressions.

As an example, suppose that we want to evaluate the formula $\readcell
a$, in a cell heap described by $\cellneg{a}{\return 5}$.  Clearly,
this is a sufficient footprint, and we expect to a) get the return
value 5, and b) see the cell formula change to $\cellpos{a}{\return
  5}{5}{\emptyset}$.  However, the fact that we are now changing cells
from negative to positive means that the conditional character of
readiness, which worked in our favor with $\updatecell$ and
$\newcell\!\!$, now works against us.

In particular, suppose that we run this command with a framed abstract heap
formula $\psi = \cellpos{b}{\readcell a}{17}{\setof{a}}$. Now, the
whole starting heap will be:
\begin{displaymath}
\cellneg{a}{\return 5} \otimes \cellpos{b}{\readcell a}{17}{\setof{a}}  
\end{displaymath}
In any heap satisfying this formula, $b$ will be unready, because it depends 
on an unready cell. But when we execute $\readcell a$, simply copying $\psi$ 
into the post-state will give us the cell formula:
\begin{displaymath}
\cellpos{a}{\return 5}{5}{\emptyset} \otimes \cellpos{b}{\readcell a}{17}{\setof{a}}
\end{displaymath}
That is, our satisfaction relation now expects $b$ to be ready and have the 
value 17, even though $\readcell a$ never touches $b$ at all!

Clearly, we cannot simply copy the same frame formula into the pre-
and the post-condition states in the specification of commands like
$\readcell a$.

To deal with this problem, we will return to the idea of
ramifications, introduced in the previous chapter. We can understand
our difficulty as an instance of the ramification problem as
follows. 

When we evaluate a code expression, we may read some unready cells and
send them from an unready state in the precondition to a ready state
in the postcondition. However, we may have had some cell formulas in
our frame which claimed their corresponding cells were unready purely
because one of the cells in our footprint was unready. Therefore, when
we update the footprint, we must modify the frame formula to account
for the ramifications of our update in the footprint. So even though
the actual physical storage representing the frame doesn't change at
all, we need to modify our abstract formula to reflect our updated
state of knowledge.

In our case, \emph{all} of the effects on the frame will arise from
the cells we flip from unready to ready. Thus, given the set of cells
which became ready, we can repair the framing formula by taking each
positive cell formula, and setting it to a negative state if its read
set includes anything that went from unready to ready. We define the
ramification operator $R(s, \psi)$ in Figure~\ref{ramify-def}.  It is
a simple structural induction over a framing formula, whose only
action is to replace the positive cell formulas in $\psi$ whose read
sets intersect with $s$ with a corresponding negative cell formula.
The ramification operator has a number of useful properties, which are
most easily expressed after we have introduced a few auxiliary
judgments and predicates.

In Figure~\ref{readiness} we define the two judgments $\unready{\phi}{o}$
and $\ready{\phi}{o}{v}$, which establish whether a cell is ready or
unready, from the syntactic structure of $\phi$. 

\begin{prop}{(Soundness of $\ready{\phi}{o}{v}$ and $\unready{\phi}{o}$)}
For all $\phi, o,$ and $H$ such that $H = (D,h)$:

\begin{enumerate}
\item $(Inv((D,h), \phi) \land \ready{\phi}{o}{v}) \implies \mathit{value}(h(o)) = \ctext{Some}\;v$
\item $(Inv((D,h), \phi) \land \unready{\phi}{o}) \implies o \not\in V_H$
\end{enumerate}
\end{prop}

\begin{proof}
\begin{enumerate}
\item $(Inv((D,h), \phi) \land \ready{\phi}{o}{v}) \implies \mathit{value}(h(o)) = \ctext{Some}\;v$

We prove this by induction on the derivation of
$\ready{\phi}{o}{v}$. By inversion, we know that $\phi = \psi \otimes
\cellpos{o}{\cmd}{v}{r}$, and for each $c' \in r$, we have a derivation
of $\ready{\psi}{c'}{v'}$ for some $v'$. By induction, we know that
for each $c' \in r$, $c' \in V_H$. By the fact that $(D,h), D \models
\psi \otimes cellpos{c}{\cmd}{v}{r}$, we know that $c \in V_H$ and
$\mathit{value}(h(o)) = \ctext{Some}(v)$. Hence the conclusion follows. 

\item $(Inv((D,h), \phi) \land \unready{\phi}{o}) \implies o \not\in V_H$

We prove this by induction on the derivation of $\unready{\phi}{o}$.
First, consider the case where $\phi = \psi \otimes \cellneg{o}{\cmd}$. 
Then, the fact that $(D,h), D \models \psi \otimes \cellneg{o}{\cmd}$
implies that $o \not\in V_H$. Now, consider the other case, where 
$\phi = \psi \otimes \cellpos{o}{\cmd}{v}{r}$. We know that there is
some $a \in r$ such that $\unready{\psi}{a}$ holds, and by induction
we know that $a \not\in V_H$. Hence, it follows that $a \not\subseteq V_H$,
and so the fact that $(D,h), D \models \psi \otimes \cellneg{o}{\cmd}$ implies
that $o \not\in V_H$. 
\end{enumerate}
\end{proof}


In Figure~\ref{closedness}, we define the $\closed{\phi}{s}$ predicate,
which asserts that every cell formula in $\phi$ reads at most the
cells in $s$. Now, we can summarize the interactions between the 
ramification operator $R$ and abstract heap formulas as follows: 

\begin{prop}{(Interaction Properties)}
Given sets of cells $s$ and $u$, cell $o$, value $v$, and formula $\phi$, we have
that:
\begin{itemize}
\item $R(s, R(u, \phi)) = R(s \cup u, \phi)$
\item If $\unready{\phi}{o}$, then $\unready{R(u, \phi)}{o}$ 
\item If $\ready{R(u, \phi)}{o}{v}$, then $\ready{\phi}{o}{v}$ 
\item If $R(u, \phi)$ and $\closed{\phi}{s}$, then $R(u, \phi) = R(u \cap s, \phi)$ 
\end{itemize}
\end{prop}

All of these facts can be proved with simple inductive arguments. 

The first property means that if we evaluate two expressions, we can
simply combine their ramification effects without having to worry
about the order that they were evaluated in. The second and third let
us know that a ramification cannot make us forget a cell is unready,
nor can it make anything ready that was not ready before. The last
property permits us to constrain the effect of a ramification --- if we
know that two parts of the abstract heap formula do not read each
other at all, we can deduce that ramifications from one will not
affect the other.

\begin{prop}{(Entailments)}
Define $\phi \vdash \theta$ to mean that for all $H$ and $D$, that if $H, D \models \phi$ then 
$H, D \models \theta$. 

\begin{itemize}
\item For all $\phi, \theta$, we have $\phi \otimes \theta \vdash \phi$
\item For all $\phi, \phi', \psi$, if $\phi \vdash \phi'$ then $\phi \otimes \psi \vdash \phi' \otimes \psi$  
\item If $\unready{\phi}{c}$ then $\phi \dashv\vdash R(\setof{c}, \phi)$
\item If $\unready{\phi \otimes \celleither{c}{\cmd}}{c}$ then $\phi \otimes \celleither{c}{\cmd} \dashv\vdash \phi \otimes \cellneg{c}{\cmd}$
\end{itemize}
\end{prop}

\begin{proof}
\begin{itemize}
\item For all $\phi, \theta$, we have $\phi \otimes \theta \vdash \phi$
\begin{tabbedproof}
\oo Assume we have $\phi, \theta$ and $H, D \models \phi \otimes \theta$ \\
\oo Now we inductively show that for all $D' \supseteq D$, we have $H, D \models \phi$ implies $H, D' \models \phi$ \\
\ooo Case $\phi = I$: \\
\oooo Immediate \\
\ooo Case $\phi = \localref{r}{v}$: \\
\oooo Immediate\\
\ooo Case $\phi = \psi \otimes \theta$: \\
\oooo If $D' \supseteq D$, then there is a $D''$ such that $D' = D \uplus D''$ \\
\oooo By inversion, we have $D_1$ and $D_2$ with $D = D_1 \uplus D_2$ such that \\
\ooox $H, D_1 \models \psi$ and $H, D_2 \models \theta$ \\
\oooo By induction, we know that $H, D_1 \uplus D'' \models \psi$ \\
\oooo Since $D''$ is disjoint from $D$, we know it is disjoint from $D_1$ and $D_2$ \\
\oooo Hence $D_1 \uplus D''$ is disjoint from $D_2$ \\
\oooo Hence $H, D_1 \uplus D'' \uplus D_2 \models \psi \otimes \theta$ \\
\oooo Hence $H, D' \models \phi$ \\
\ooo Case $\phi = \cellneg{c}{\cmd}$: \\
\oooo Since $c \in D$, we know $c \in D'$ \\
\oooo Hence $H, D' \models \cellneg{c}{\cmd}$ \\
\ooo Case $\phi = \cellpos{c}{\cmd}{v}{r}$: \\
\oooo Since $c \in D$, we know $c \in D'$ \\
\oooo Hence $H, D' \models \cellneg{c}{\cmd}$ \\
\oo Now note that we have $D_1, D_2$ such that $D = D_1 \uplus D_2$ and \\
\ox $H, D_1 \models \phi$ and $H, D_2 \models \theta$ \\
\oo Since $D \supseteq D_1$, we know that $H, D \models \phi$ \\
\end{tabbedproof}

\item For all $\phi, \phi', \psi$, if $\phi \vdash \phi'$ then $\phi \otimes \psi \vdash \phi' \otimes \psi$  
\begin{tabbedproof}
\oo Assume we have $\phi \vdash \phi'$ \\
\oo Now, assume we have $H, D$ such that $H,D \models \phi \otimes \psi$ \\
\ooo So we know that there are $D_1, D_2$ such that $D = D_1 \uplus D_2$ and \\
\oox $H, D_1 \models \phi$ and $H, D_2 \models \psi$ \\
\ooo Since $\phi \vdash \phi'$, we know $H, D_1 \models \phi'$ \\
\ooo Hence $H, D_1 \uplus D_2 \models \phi' \otimes \psi$ \\
\ooo Hence $H, D \models \phi' \otimes \psi$ \\
\end{tabbedproof}


\item If $\unready{\phi}{c}$ then $\phi \dashv\vdash R(\setof{c}, \phi)$
\begin{tabbedproof}
\oo Assume $\unready{\phi}{c}$, and that we have $H$ and $D$. \\
\oo We want to show that $H, D \models \phi$ iff $H, D \models R(\setof{c}, \phi)$ \\
\oo $\Rightarrow$: Assume $H, D \models \phi$ \\
\ooo Now, we proceed by induction on $\phi$: \\
\ooo Case $\phi = I$: \\
\oooo Since $R(\setof{c}, I) = I$, this case is immediate \\
\ooo Case $\phi = \localref{r}{v}$: \\
\oooo Since $R(\setof{c}, \localref{r}{v}) = \localref{r}{v}$, this case is immediate \\
\ooo Case $\phi = \sigma \otimes \theta$: \\
\oooo By definition, we know there are $D_1, D_2$ such that $D = D_1 \uplus D_2$ and \\
\ooox $H, D_1 \models \sigma$ and $H, D_2 \models \theta$ \\
\oooo By induction $H, D_1 \models R(\setof{c}, \sigma)$ and $H, D_2 \models R(\setof{c}, \theta)$ \\
\oooo Hence $H, D \models R(\setof{c}, \sigma) \otimes R(\setof{c}, \theta)$ \\
\oooo Hence $H, D \models R(\setof{c}, \sigma \otimes \theta)$ \\
\ooo Case $\phi = \cellneg{c'}{\cmd}$: \\
\oooo Since $R(\setof{c}, \cellneg{c'}{\cmd}) = \cellneg{c'}{\cmd}$, this case is immediate \\
\ooo Case $\phi = \cellpos{c'}{e'}{v'}{r'}$: \\
\oooo Consider whether $c \in r'$: \\
\oooo If $c \not\in r'$: \\
\ooooo Then $R(\setof{c}, \cellpos{c'}{e'}{v'}{r'}) = \cellpos{c'}{e'}{v'}{r'}$ and this case is immediate \\
\oooo If $c \in r'$: \\
\ooooo Since $\unready{c}{\cmd}$ is sound, we know that $c \not\in V_H$. \\ 
\ooooo Hence $r' \not\subseteq V_H$, and so we know that $c' \not\in V_H$ \\
\ooooo Furthermore, we know that $c' \in D$, and $\mathit{code}(h(c')) = e'$, \\
\oooox so we know $H, D \models \cellneg{c'}{e'}$ \\
\ooooo Since $c \in r'$, we know $R(\setof{c}, \cellpos{c'}{e'}{v'}{r'}) = \cellneg{c'}{e'}$ \\
\ooooo Hence $H, D \models R(\setof{c}, \cellpos{c'}{e'}{v'}{r'})$ \\
\oo $\Leftarrow$: Assume $H, D \models R(\setof{c}, \phi)$ \\
\ooo Now proceed by induction on $\phi$: \\
\ooo Case $\phi = I$: \\
\oooo Since $R(\setof{c}, I) = I$, this case is immediate \\
\ooo Case $\phi = \localref{r}{v}$: \\
\oooo Since $R(\setof{c}, \localref{r}{v}) = \localref{r}{v}$, this case is immediate \\
\ooo Case $\phi = \sigma \otimes S\theta$: \\
\oooo We know $R(\setof{c}, \sigma \otimes \theta) = R(\setof{c}, \sigma) \otimes R(\setof{c}, \theta)$ \\
\oooo Hence we know there are $D_1, D_2$ such that $D = D_1 \uplus D_2$ and \\
\ooox $H, D_1 \models R(\setof{c}, \sigma)$ and $H, D_2 \models R(\setof{c}, \theta)$ \\
\oooo By induction $H, D_1 \models \sigma$ and $H, D_2 \models \theta$ \\
\oooo Hence $H, D \models \sigma \otimes \theta$ \\
\ooo Case $\phi = \cellneg{c'}{\cmd}$: \\
\oooo Since $R(\setof{c}, \cellneg{c'}{\cmd}) = \cellneg{c'}{\cmd}$, this case is immediate \\
\ooo Case $\phi = \cellpos{c'}{e'}{v'}{r'}$: \\
\oooo Consider whether $c \in r'$: \\
\oooo If $c \not\in r'$: \\
\ooooo Then $R(\setof{c}, \cellpos{c'}{e'}{v'}{r'}) = \cellpos{c'}{e'}{v'}{r'}$ and this case is immediate \\
\oooo If $c \in r'$: \\
\ooooo Since $\unready{c}{\cmd}$ is sound, we know that $c \not\in V_H$. \\ 
\ooooo We know $H, D \models R(\setof{c}, \cellpos{c'}{e'}{v'}{r'}) = \cellneg{c'}{e'}$ \\
\ooooo Hence $c' \not\in V_H$ \\
\ooooo But since $c \in r'$, we know $H, D \models \cellpos{c'}{e'}{v'}{r'}$ \\
\end{tabbedproof}



\item If $\unready{\phi \otimes \cellpos{c}{\cmd}{v}{r}}{c}$ then $\phi \otimes \cellpos{c}{\cmd}{v}{r} \dashv\vdash \phi \otimes \cellneg{c}{\cmd}$
\begin{tabbedproof}
\oo Assume $\unready{\phi \otimes \cellpos{c}{\cmd}{v}{r}}{c}$  and $H, D$ \\
\oo Now we want to show $H, D \models \phi \otimes \cellpos{c}{\cmd}{v}{r}$ if and only if \\
\ox $H, D \models \phi \otimes \cellneg{c}{\cmd}$ \\
\oo $\Rightarrow$: Assume $H, D \models \phi \otimes \cellpos{c}{\cmd}{v}{r}$ \\
\ooo So we have $D_1, D_2$ such that $D = D_1 \uplus D_2$ and \\
\oox $H, D_1 \models \phi$ and $H, D_2 \models \cellpos{c}{\cmd}{v}{r}$ \\
\ooo From the soundness of $\unready{\phi \otimes \cellpos{c}{\cmd}{v}{r}}{c}$, we know that $c \not \in V_H$ \\
\ooo Hence we know that $H, D_2 \models cellneg{c}{\cmd}$ \\
\ooo Hence we know that $H, D \models \phi \otimes \cellneg{c}{\cmd}$ \\
\oo $\Leftarrow$: Assume $H, D \models \phi \otimes \cellneg{c}{\cmd}$ \\
\ooo So we have $D_1, D_2$ such that $D = D_1 \uplus D_2$ and \\
\oox $H, D_1 \models \phi$ and $H, D_2 \models \cellpos{c}{\cmd}{v}{r}$ \\
\ooo We want to show $H, D \models \phi \otimes \cellpos{c}{\cmd}{v}{r}$ \\
\ooo By inversion on $\unready{\phi \otimes \cellpos{c}{\cmd}{v}{r}}{c}$ we know $\unready{\phi}{d}$ for some $d \in r$ \\
\ooo By soundness of $\unready{\phi}{d}$, we know that $d \not\in V_H$ \\
\ooo Hence we know that $H, D_2 \models \cellpos{c}{\cmd}{v}{r}$ \\
\ooo Hence we know that $H, D \models \phi \otimes \cellpos{c}{\cmd}{v}{r}$ \\
\end{tabbedproof}
\end{itemize}
\end{proof}



\subsection{The Abstract Semantics of Expressions}

Now we can finally define the abstract semantics of the code
expression monad, which we give in Figure~\ref{abs-semantics}.

As before, we describe the effect of an expression $\cmd$ with a Hoare
triple, prefixed with a quantification over all possible frames
$\psi$. Then we assert that from a state $G(\phi \otimes \psi)$,
running $\cmd$ will give us a state $G(\phi' \otimes R(u, \psi))$ ---
that is, we must update the frame with the ramification $u$. Note in
particular that the framing formulas may \emph{differ} in the pre- and
the post-conditions. For composite commands (such as $\bind \cmd\;f$) we
give their specifications as implications over the specifications of
their subcomponents.

In the specification \textsc{AUnit}, we give a specification for the
$\return v$ command, which simply returns its argument and neither
reads nor updates any cells or state. 

The \textsc{ABind} rule explains how sequential composition works for
an expression $\bind \cmd\;f$ --- as expected, we evaluate the first
monadic argument, and pass the result to the functional argument, and
evaluate that. The read and update sets are simply the union of the
two executions. Reading a cell comes in two variants, \textsc{AReady}
and \textsc{AUnready}. If a cell is ready (using the
$\ready{\phi}{c}{v}$ judgment), we simply return its memoized value
without any further computation, and do not need to use a ramification
to update the frame. On the other hand, if a cell is unready (from the
$\unready{\phi}{c}$ judgment), we need to evaluate its code body, and
then update the cell with its new value. So we need to know what the
evaluation of its body can do. Note that we have to apply the
ramification operator to $\phi'$ in the postcondition in the
consequence of \textsc{AUnready}, because the cell we are reading goes
from unready to ready itself. 

We can also read and write local state (with the \textsc{AGetRef} and
\textsc{ASetRef} specifications), which do not have any effect on the
cells. Finally, we have the \textsc{AConseq} rule, which gives us a
version of the rule of consequence from ordinary Hoare logic.

Note that the use of the ready and unready judgments, together with
the entailment relation on abstract heaps, means that we can reason
``syntactically'' about the behavior of cell-manipulating programs: we
do not need to know what the concrete model (or concrete
implementation) when we are proving the correctness of client
programs. We will see this in the next section, which illustrates that
this interface really does give us a genuinely modular way of
reasoning about dataflow networks.

\begin{prop}{(Soundness of Abstract Semantics)}

All of the rules of the abstract semantics in Figure~\ref{abs-semantics} are
provable within our specification logic. 
\end{prop}

At this point, we can now reason about the behavior of the imperative
notification library in terms of its action on the abstract heap. The
combination of quantification and ramification give us a domain-specific 
frame property, which allow us to modularly prove the correctness of programs 
that construct and produce notifications.


\begin{figure}
\mbox{}
\begin{mathpar}
\begin{array}{ll}  
\mbox{\textsc{AUnit}} & 
\forall \psi.\; \mspec{G(\psi)}
                     {\return v}
                     {a}{G(\psi) \land \exists z.\; a = (v, z) \land \mathit{set}(\emptyset, z, \emptyset)} 
\\[1em]

\mbox{\textsc{ABind}} & 
\forall \psi.\; \mspec{G(\phi \otimes \psi)}
                     {\cmd}
                     {a}{G(\phi' \otimes R(u', \psi)) \land \exists z.\;a = (v', r') \land \mathit{set}(r', z, r')} 
                \specand \\
&  \forall \psi.\; \mspec{G(\phi' \otimes \psi)}
                        {f\;v'}
                        {a}{G(\phi'' \otimes R(u'', \psi)) \land \exists z.\; a = (v'', z) \land \mathit{set}(r'', z, r'')}\\
&  \specimp \\
&  \begin{array}{ll}
     \forall \psi. & \left<G(\phi \otimes \psi)\right> \\
                   & \bind \cmd\;f \\
                   &  \left<a.\;G(\phi'' \otimes R(u' \cup u'', \psi)) \land \exists z.\;a = (v'', z) \land \mathit{set}(r' \cup r'', z, r' \cup r'')\right> \\
   \end{array}
\\[2em]

\mbox{\textsc{AReady}} & 
  \setof{\ready{\phi}{c}{v}} \specimp \\
& \forall \psi.\; \mspec{G(\phi \otimes \psi)}
                       {\readcell c}
                       {a}{G(\phi \otimes \psi) \land \exists z.\;a = (v, z) \land \mathit{set}(\setof{c}, z, \setof{c})} 
\\[1em]

\mbox{\textsc{AUnready}} & 
  \setof{\unready{\phi \otimes \celleither{c}{\cmd}}{c}} \specand \\
& \forall \psi.\; \mspec{G(\phi \otimes \psi)}
                       {\cmd}
                       {a}{G(\phi' \otimes R(u, \psi)) \land \exists z.\; a = (v, z) \land \mathit{set}(r, z, r)} \\
& \specimp \\
& \begin{array}{ll}
   \forall \psi. & \left<G(\phi \otimes \celleither{c}{\cmd} \otimes \psi)\right> \\
                 & \readcell c \\
                 & \left<a.\; 
                     \begin{array}{l}
                       G(R(\setof{c}, \phi') \otimes \cellpos{c}{\cmd}{v}{r} \otimes R(u \cup \setof{c}, \psi)) 
                        \;\land \\
                        \exists z.\;a = (v, z) \land \mathit{set}(\setof{c}, z, \setof{c})
                     \end{array}\right> 
  \end{array}
\\[3em]

\mbox{\textsc{AGetRef}}
& \begin{array}{ll}
    \forall \psi.\; 
    &  \left<G(\localref{r}{v} \otimes \psi)\right> \\
    &  \getref r \\
    &  \left<a.\; G(\localref{r}{v} \otimes \psi) 
                  \land  \exists z.\;a = (v,z) \land \mathit{set}(\emptyset, z, \emptyset)
       \right> \\
     \end{array}
\\[2em]

\mbox{\textsc{ASetRef}}
& \begin{array}{ll}
    \forall \psi.\; 
    &  \left<G(\localref{r}{v'} \otimes \psi)\right> \\
    &  \setref r\;v \\
    &  \left<a.\; G(\localref{r}{v} \otimes \psi) 
                  \land  \exists z.\;a = (v,z) \land \mathit{set}(\emptyset, z, \emptyset)
       \right> \\
     \end{array}
\\[2em]

% \mbox{\textsc{ANewCell}}
% & \forall \psi.\; \mspec{G(\psi)}{\newcell \cmd}{(c,z)}{G(\cellneg{c}{\cmd} \otimes \psi) \land \mathit{set}(\emptyset, z, \emptyset)}
% \\[1em]

\mbox{\textsc{AConseq}}
& \setof{\phi' \vdash \phi} \specand \setof{\theta \vdash \theta'} \specand \\
& \forall \psi.\; \mspec{G(\phi \otimes \psi) \land P}{\cmd}{(x,z)}{G(\theta\otimes R(u, \psi)) \land Q} \\
& \specimp \\
& \forall \psi.\; \mspec{G(\phi' \otimes \psi) \land P}{\cmd}{(x,z)}{G(\theta'\otimes R(u, \psi)) \land Q} \specand \\

\end{array}
\end{mathpar}
\caption{Abstract Semantics of Notifications}
\label{abs-semantics}
\end{figure}


\subsection{Proving the correctness of \textsc{AUnit}}
\begin{prop*}{(The \textsc{AUnit} specification is sound)}
The following triple is derivable:
\begin{displaymath}
\forall \psi.\; \mspec{G(\psi)}
                     {\return v}
                     {a}{G(\psi) \land \exists z.\; a = (v, z) \land \mathit{set}(\emptyset, z, \emptyset)} 
\end{displaymath}
\end{prop*}

\begin{proof}
\begin{tabbedproof}
\oo Assume we have $\psi$ and a prestate $G(\psi)$ \\
\oo Now consider the body of $\return v$ \\
\oo $[(v, \mathsf{emptyset})]$ \\
\oo Hence we know that $\exists z.\; a = (v, z) \land \mathit{set}(\emptyset, z, \emptyset)$ \\
\ox and $G(\psi)$ \\
\end{tabbedproof}
\end{proof}

\subsection{Proving the correctness of \textsc{ABind}}

\begin{prop*}{(The \textsc{ABind} specification is sound)}
The following specification is derivable:
\begin{displaymath}
\begin{array}{l}
\forall \psi.\; \mspec{G(\phi \otimes \psi)}
                     {\cmd}
                     {a}{G(\phi' \otimes R(u', \psi)) \land \exists z.\;a = (v', r') \land \mathit{set}(r', z, r')} 
                \specand \\
\forall \psi.\; \mspec{G(\phi' \otimes \psi)}
                        {f\;v'}
                        {a}{G(\phi'' \otimes R(u'', \psi)) \land \exists z.\; a = (v'', z) \land \mathit{set}(r'', z, r'')}\\
\specimp \\
\begin{array}{ll}
     \forall \psi. & \left<G(\phi \otimes \psi)\right> \\
                   & \bind \cmd\;f \\
                   &  \left<a.\;G(\phi'' \otimes R(u' \cup u'', \psi)) \land \exists z.\;a = (v'', z) \land \mathit{set}(r' \cup r'', z, r' \cup r'')\right> \\
   \end{array}
\end{array}
\end{displaymath}
\end{prop*}

\begin{proof}
\begin{tabbedproof}
\oo Assume $\forall \psi.\; \mspec{G(\phi \otimes \psi)}
                     {\cmd}
                     {a}{G(\phi' \otimes R(u', \psi)) \land \exists z.\;a = (v', r') \land \mathit{set}(r', z, r')}$ \\
\oo Assume $\forall \psi.\; \mspec{G(\phi' \otimes \psi)}
                        {f\;v'}
                        {a}{G(\phi'' \otimes R(u'', \psi)) \land \exists z.\; a = (v'', z) \land \mathit{set}(r'', z, r'')}$ \\
\oo Assume we have $\psi$, and a prestate $G(\phi \otimes \psi)$ \\
\ooo Now consider the body of $\bind$ \\
\ooo $[\letv{(v, z_1)}{\cmd}{}$ \\
\ooo So we know $G(\phi' \otimes R(u', \psi)) \land v = v' \land \mathit{set}(r', z_1, r')$ \\
\ooo Simplifying $v$ away, we continue with \\
\ooo $\letv{(v, z_2)}{f\;v'}{}$ \\
\ooo Now we know $G(\phi'' \otimes R(u'', R(u', \psi))) \land v = v'' \land \mathit{set}(r', z_1, r') \land \mathit{set}(r'', z_2, r'')$ \\
\ooo Hence with $z = \mathsf{union}\;z_1\;z_2$ we know $\mathit{set}(r' \cup r'', z, r' \cup r'')$ \\
\ooo $(v, \mathsf{union}\;z_1\;z_2)]$ \\
\ooo Hence $G(\phi'' \otimes R(u' \cup u'', \psi)) \land \exists z.\; a = (v'', z) \land \mathit{set}(r' \cup r'', z, r' \cup r'')$ 
\end{tabbedproof}
\end{proof}

\subsection{Proving the correctness of \textsc{AReady}}

In this subsection, we will prove the following proposition: 

\begin{prop*}{(The \textsc{AReady} specification is sound)}
The following specification holds: 
\begin{displaymath}
\begin{array}{l}
\setof{\ready{\phi}{c}{v}} \specimp \\
\;\;\;\forall \psi.\; \mspec{G(\phi \otimes \psi)}
                       {\readcell c}
                       {a}{G(\phi \otimes \psi) \land \exists z.\;a = (v, z) \land \mathit{set}(\setof{c}, z, \setof{c})} 
\end{array}
\end{displaymath}
\end{prop*}

\begin{proof}
\begin{tabbedproof}
\oo Assume $\ready{\phi}{c}{v}$ and a $\psi$ \\
\ooo Now assume we have a precondition $G(\phi \otimes \psi)$ \\
\ooo So there is an $H = (D,h)$ such that $\mathit{Inv}(H, \phi \otimes \psi)$ holds \\
\ooo So we know that $H, D \models \phi \otimes \psi$ and $\mathit{heap}(H)$ \\
\ooo So we know that $c.\mathit{value} \pointsto \mathit{value}(h(c))$ \\
\ooo From soundness of $\ready{\phi}{c}{v}$, we know that $\mathit{value}(h(c)) = \Some(v)$ \\
\ooo $[\letv{o}{[!c.value]}{}$ \\
\ooo So we know that $o = \Some(v)$ \\
\ooo Now we can simplify the case statement and continue \\
\ooo $(v, \mathsf{singleton}\;c)]$ \\
\ooo So we know that $\exists z.\;a = (v, z) \land \mathit{set}(\setof{c}, z, \setof{c})$ \\
\oox and $\mathit{Inv}(H, \phi \otimes \psi)$ holds \\
\ooo So $G(H, \phi \otimes \psi)$ and $\exists z.\;a = (v, z) \land \mathit{set}(\setof{c}, z, \setof{c})$ hold
\end{tabbedproof}
\end{proof}

\subsection{Proving the correctness of \textsc{AUnready}}

In this subsection, we will prove the following proposition:

\begin{prop*}{(Soundness of the \text{AUnready} specification)}
The following triple holds:
\begin{displaymath}
\begin{array}{l}
\setof{\unready{\phi \otimes \celleither{c}{\cmd}}{c}} \specand \\
\forall \psi.\; \mspec{G(\phi \otimes \psi)}
                     {\cmd}
                     {a}{G(\phi' \otimes R(u, \psi)) \land \exists z.\; a = (v, z) \land \mathit{set}(r, z, r)} \\
\specimp \\
\begin{array}{ll}
 \forall \psi. & \left<G(\phi \otimes \celleither{c}{\cmd} \otimes \psi)\right> \\
               & \readcell c \\
               & \left<a.\; 
                   \begin{array}{l}
                     G(R(\setof{c}, \phi') \otimes \cellpos{c}{\cmd}{v}{r} \otimes R(u \cup \setof{c}, \psi)) 
                      \;\land \\
                      \exists z.\;a = (v, z) \land \mathit{set}(\setof{c}, z, \setof{c})
                   \end{array}\right> 
\end{array}
\end{array}
\end{displaymath}
\end{prop*}

This follows the standard pattern of (1) proving that the update
preserves the relevant order structure, (2) proving the new abstract
formula continues to model the updated abstract heap, and finally (3)
showing the code actually implements this update. 


\begin{lemma}{(Reading an Unready Cell Preserves Order Structure)}
Suppose that $H = (D,h)$ and $c \in D - V_H$. Then for any subset $r
\subseteq V_H$ and value $v$, define $h'$ so that
\begin{itemize}
\item $\mathit{code} \circ h' = \mathit{code} \circ h$ 
\item $\mathit{value} \circ h' = \semfun{c'}{\IfThenElse{c' = c}{\Some(v)}{\mathit{value}(h(c'))}}$ 
\item $\mathit{reads} \circ h' = \semfun{c'}{\IfThenElse{c' = c}{r}{\mathit{reads}(h(c'))}}$ 
\item $\mathit{obs} \circ h' = \semfun{c'}{\IfThenElse{c' \in r}{\mathit{obs}(h(c')) \cup \setof{c}}{\mathit{obs}(h(c'))}}$ 
\item $\mathit{identity} \circ h' = \mathit{identity} \circ h$
\end{itemize}
\noindent Then it is the case that $H' = (D,h')$ satisfies the five properties below. 
\begin{enumerate}
\item $V_{H'} = V_H \cup \setof{c}$
\item $R^+_{H'}$ is a strict partial order 
\item $R_{H'} \subseteq V_{H'} \times V_{H'}$
\item $R^\dagger_{H'} = O_{H'}$ 
\item $\mathit{unique}(H') = \mathit{unique}(H)$
\end{enumerate}
\end{lemma}

\begin{proof}
\begin{enumerate}
\item $V_{H'} = V_H \cup \setof{c}$ 
  \begin{tabbedproof}
    \oo So we want to show that $a \in V_{H'}$ iff $a \in V_H \cup \setof{c}$ \\
    \oo Assume that $a \in V_{H'}$ \\
    \ooo So we know that $\mathit{value}(h'(a)) = \Some(u)$ for some $u$ \\
    \ooo Now consider whether $a$ is $c$ \\
    \ooo Suppose $a = c$: \\
    \oooo Then $a \in \setof{c}$, and hence $a \in V_H \cup \setof{c}$ \\
    \ooo Suppose $a \not= c$: \\
    \oooo Then we know that $\mathit{value}(h'(a)) = \mathit{value}(h(a))$ \\
    \oooo Since $\mathit{value}(h'(a)) = \Some(u)$, we know $a \in V_H$ \\
    \oooo Hence $a \in V_H \cup \setof{c}$ \\
    \oo Assume that $a \in V_H \cup \setof{c}$ \\
    \ooo Now consider whether $a$ is $c$ \\
    \ooo Suppose $a = c$: \\
    \oooo Then $\mathit{value}(h'(a)) = \Some(v)$ \\
    \oooo Therefore $a \in V_{H'}$ \\
    \ooo Suppose $a \not= c$: \\
    \oooo Then $a \in V_H$ \\
    \oooo Also, $\mathit{value}(h'(a)) = \mathit{value}(h(a))$ \\
    \oooo Therefore there is a $u$ such that $\mathit{value}(h'(a)) = \Some(u)$ \\
    \oooo Hence $a \in V_{H'}$ \\
  \end{tabbedproof}

\item $R^+_{H'}$ is a strict partial order 
  \begin{tabbedproof}
    \oo This follows if $R^+_{H'}$ is a transitive, irreflexive relation \\
    \oo Since it is a transitive closure, it is a transitive relation \\
    \oo So we want to show there is no $a \in D$ such that $(a,a) \in R^+_{H'}$ \\
    \oo Consider an arbitrary $(a_0, b) \in R^+_{H'}$ \\
    \oo Hence there is a sequence $a_0, \ldots, a_{k+1}$ such that $b = a_{k+1}$ \\
    \ox and for each $i \leq k$, $a_{i+1} \in \mathit{reads}(h'(a_i))$ \\
    \oo Now consider whether $c$ is equal to any of the $a_i$ \\
    \oo Suppose $a_i \not= c$ for all $0 \leq i \leq k+1$: \\
    \ooo Then in this case, it follows that $\mathit{reads}(h'(a_i)) = \mathit{reads}(h(a_i))$ for all $i$\\
    \ooo Then $(a_0, a_{k+1}) \in R^+_H$ \\
    \ooo Then $a_0 \not= a_{k+1}$ since $R^+_H$ is irreflexive \\
    \oo Suppose $a_i = c$ for some $0 \leq i \leq k+1$: \\
    \ooo Note $\mathit{reads}(h'(a)) \subseteq V_H$ for all $a$  \\
    \ooo Since $c \not\in V_H$, it follows $c \not\in \mathit{reads}(h'(a))$ for any $a_i$ \\
    \ooo Hence $i = 0$, and $c \not= a_j$ for any $j > 0$ \\
    \ooo Then $c \not= a_{k+1}$
  \end{tabbedproof}

\item $R_{H'} \subseteq V_{H'} \times V_{H'}$ 
  \begin{tabbedproof}
    \oo We want to show that for all $(a,b)$, if $b \in \mathit{reads}(h'(a))$, then $a \in V_{H'}$ and $b \in V_{H'}$ \\
    \oo Assume $b \in \mathit{reads}(h'(a))$ \\
    \ooo Now consider whether $a = c$  \\
    \ooo Suppose $a = c$: \\
    \oooo Then $a \in V_{H'}$ \\
    \oooo Since $\mathit{reads}(h'(c)) = r$, we know $r \subseteq V_H$ \\
    \oooo Since $V_{H} \subseteq V_{H'}$, it follows $b \in V_{H'}$ \\
    \ooo Suppose $a \not= c$: \\
    \oooo Then $\mathit{reads}(h'(a)) = \mathit{reads}(h(a))$ \\
    \oooo Then $b \in \mathit{reads}(h(a))$, and so $(a,b) \in R_H$ \\
    \oooo Since $R_H \subseteq V_H \times V_H$, we know $a \in V_H$ and $b \in V_H$ \\
    \oooo Since $V_{H} \subseteq V_{H'}$, we know $a \in V_{H'}$ and $b \in V_{H'}$ \\
  \end{tabbedproof}

\item $R^\dagger_{H'} = O_{H'}$ 
  \begin{tabbedproof}
    \oo We want to show that for all $(a,b)$, we have $(a,b) \in R^\dagger_{H'}$ iff $(a,b) \in O_{H'}$ \\
    \oo Assume $(a,b) \in R^\dagger_{H'}$ \\
    \ooo Then $(b, a) \in R_{H'}$ \\
    \ooo So $a \in \mathit{reads}(h'(b))$ \\
    \ooo We want to show that $b \in \mathit{obs}(h'(a))$ \\
    \ooo Consider whether $b = c$ \\
    \ooo Suppose $b = c$: \\
    \oooo Then $a \in r$, since $\mathit{reads}(h'(b)) = r$ \\
    \oooo Therefore $\mathit{obs}(h'(a)) = \mathit{obs}(h(a)) \cup \setof{c}$ \\
    \oooo Hence $b \in \mathit{obs}(h'(a))$ \\
    \ooo Suppose $b \not= c$: \\
    \oooo Then $\mathit{reads}(h'(b)) = \mathit{reads}(h(b))$ \\
    \oooo So $a \in \mathit{reads}(h(b))$ \\
    \oooo Hence $b \in \mathit{obs}(h(a))$ \\
    \oooo Since $\mathit{obs}(h(x)) \subseteq \mathit{obs}(h(x))$ for all $x$, $b \in \mathit{obs}(h'(a))$ \\
    \oo Assume $(a,b) \in O_{H'}$ \\
    \ooo Then $b \in \mathit{obs}(h'(a))$ \\
    \ooo We want to show that $a \in \mathit{reads}(h'(b))$ \\
    \ooo Consider whether $b = c$ \\
    \ooo Suppose $b = c$: \\
    \oooo Now consider whether $a \in r$ \\
    \oooo Suppose $a \in r$: \\
    \ooooo Then by definition $a \in \mathit{reads}(h'(b))$ \\
    \oooo Suppose $a \not\in r$: \\
    \ooooo Then $\mathit{obs}(h'(a)) = \mathit{obs}(h(a)) = \emptyset$ \\
    \ooooo This is a contradiction, since we assumed $b \in \mathit{obs}(h'(a))$ \\
    \ooo Suppose $b \not= c$: \\
    \oooo Consider whether $a = c$: \\
    \oooo Suppose $a = c$: \\
    \ooooo This case is impossible since $c \not\in V_H$ and $\mathit{obs}(h'(x)) = \emptyset$ for any $x \not\in V_H$ \\
    \oooo Suppose $a \not= c$: \\
    \ooooo Then it follows that $b \in \mathit{obs}(h(a))$ \\
    \ooooo Then it follows that $a \in \mathit{reads}(h(b))$ \\
    \ooooo Therefore $a \in \mathit{reads}(h'(b))$ 
  \end{tabbedproof}

\item $\mathit{unique}(H') = \mathit{unique}(H)$

This is immediate since $\mathit{identity} \circ h' = \mathit{identity} \circ h$.
\end{enumerate}
\end{proof}

\begin{lemma}{(Reading an Unready Cell, Semantically)}
Suppose that $H = (D,h)$ and $H, D' \models \phi \otimes
\celleither{c}{\cmd}$ and $c \in D' - V_H$. Then for any subset $r
\subseteq V_H$ and value $v$, define $h'$ so that
\begin{itemize}
\item $\mathit{code} \circ h' = \mathit{code} \circ h$ 
\item $\mathit{value} \circ h' = \semfun{c'}{\IfThenElse{c' = c}{\Some(v)}{\mathit{value}(h(c'))}}$ 
\item $\mathit{reads} \circ h' = \semfun{c'}{\IfThenElse{c' = c}{r}{\mathit{reads}(h(c'))}}$ 
\item $\mathit{obs} \circ h' = \semfun{c'}{\IfThenElse{c' \in r}{\mathit{obs}(h(c')) \cup \setof{c}}{\mathit{obs}(h(c'))}}$ 
\item $\mathit{identity} \circ h' = \mathit{identity} \circ h$
\end{itemize}
Then it follows that for $H' = (D,h')$, we have $H', D' \models R(\setof{c}, \phi) \otimes \cellpos{c}{\cmd}{v}{r}$.
\end{lemma}

\begin{proof}
  \begin{tabbedproof}
    \oo Assume $H, D' \models \phi \otimes \celleither{c}{\cmd}$ and $c \in D' - V_H$ \\
    \ooo Then there are $D_1, D_2$ with $D' = D_1 \uplus D_2$ and $H, D_1 \models \phi$ and $H, D_2 \models \celleither{c}{\cmd}$ \\
    \ooo Then $c \in D_2$ and $c \not \in D_1$, and $\mathit{value}(h(c)) = \None$ \\
    \ooo By assumption, $\mathit{value}(h'(c)) = \Some(v)$ and $\mathit{reads}(h'(c)) = r$ \\
    \ooo Hence $H', D_2 \models \cellpos{c}{\cmd}{v}{r}$ \\
    \ooo Now proceed by induction on $\phi$, letting the support $D_1$ be a parameter \\
    \ooo Case $\phi = I$: \\
    \oooo By definition $H', D_1 \models I$ \\
    \ooo Case $\phi = \psi \otimes \theta$: \\
    \oooo So we know there are $D_3, D_4$ such that $D_1 = D_3 \uplus D_4$ and \\
    \oooox $H, D_3 \models \psi$ and \\
    \oooox $H, D_4 \models \theta$ \\
    \oooo By induction, we know that \\
    \oooox $H', D_3 \models R(\setof{c}, \psi)$ and \\
    \oooox $H', D_4 \models R(\setof{c}, \theta)$ \\
    \oooo Hence $H', D_1 \models R(\setof{c}, \psi) \otimes R(\setof{c}, \theta)$ \\
    \oooo Hence $H', D_1 \models R(\setof{c}, \psi \otimes \theta)$ \\

    \ooo Case $\phi = \cellneg{c'}{e'}$: \\
    \oooo So we know that $c' \not\in V_H$ and $c' \not= c$ and $\mathit{code}(h(c')) = e'$ and $c' \in D_1$\\
    \oooo Hence $c' \not\in V_{H'}$ \\
    \oooo Hence $H', D_1 \models \cellneg{c'}{e'}$ \\
    \oooo Hence $H', D_1 \models R(\setof{c}, \cellneg{c'}{e'})$ \\

    \ooo Case $\phi = \cellpos{c'}{e'}{v'}{r'}$: \\
    \oooo Now consider whether $r' \subseteq V_H$ \\
    \oooo Suppose $r' \subseteq V_{H}$: \\
    \ooooo So $\mathit{value}(h(c')) = \Some(v')$ and $\mathit{reads}(h(c')) = r'$ and
           $\mathit{code}(h(c')) = e'$ and $a \in D$ \\
    \ooooo Since $c \not \in D_1$, we know $c' \not= c$ \\
    \ooooo Therefore $\mathit{value}(h'(c')) = \Some(v')$ \\
    \ooooo Therefore $\mathit{reads}(h'(c')) = r'$ \\
    \ooooo Since $V_{H'} \supseteq V_H$, it follows that $r' \cap V_{H'} = r'$ \\
    \ooooo Therefore $H', D_1 \models \cellpos{c'}{e'}{v'}{r'}$ \\
    \ooooo Furthermore, since $r' \subseteq V_H$, we know $c \not\in r'$ \\
    \ooooo Hence $R(\setof{c}, \cellpos{c'}{e'}{v'}{r'}) = \cellpos{c'}{e'}{v'}{r'}$ \\
    \oooo Suppose $r' \not\subseteq V_{H}$: \\
    \ooooo Then $c' \not\in V_H$ and $c' \not= c$\\
    \ooooo So $c' \not \in V_{H'}$ \\
    \ooooo Now, consider whether $c \in r'$: \\
    \ooooo Suppose $c \in r'$: \\
    \oooooo Since $c' \not \in V_{H'}$, we know $H', D_1 \models \cellneg{c'}{e'}$ \\
    \oooooo Hence $H', D_1 \models R(\setof{c}, \cellpos{c'}{e'}{v'}{r'})$ \\
    \ooooo Suppose $c \not\in r'$: \\
    \oooooo Then since $r' \not\subseteq V_H$, there is $x \in r'$ such that $x \not \in V_H$ and $x \not= c$ \\
    \oooooo Therefore $r' \not\subseteq V_{H'}$ \\
    \oooooo Therefore $H', D_1 \models \cellpos{c'}{e'}{v'}{r'}$ \\
    \oooooo Therefore $H', D_1 \models R(\setof{c}, \cellpos{c'}{e'}{v'}{r'})$ 
  \end{tabbedproof}
\end{proof}

\begin{prop*}{(Soundness of the \text{AUnready} specification)}
The following triple holds:
\begin{displaymath}
\begin{array}{l}
\setof{\unready{\phi \otimes \celleither{c}{\cmd}}{c}} \specand \\
\forall \psi.\; \mspec{G(\phi \otimes \psi)}
                     {\cmd}
                     {a}{G(\phi' \otimes R(u, \psi)) \land \exists z.\; a = (v, z) \land \mathit{set}(r, z, r)} \\
\specimp \\
\begin{array}{ll}
 \forall \psi. & \left<G(\phi \otimes \celleither{c}{\cmd} \otimes \psi)\right> \\
               & \readcell c \\
               & \left<a.\; 
                   \begin{array}{l}
                     G(R(\setof{c}, \phi') \otimes \cellpos{c}{\cmd}{v}{r} \otimes R(u \cup \setof{c}, \psi)) 
                      \;\land \\
                      \exists z.\;a = (v, z) \land \mathit{set}(\setof{c}, z, \setof{c})
                   \end{array}\right> 
\end{array}
\end{array}
\end{displaymath}
\end{prop*}

\begin{proof}
\begin{tabbedproof}
\oo Assume $\unready{\phi \otimes \celleither{c}{\cmd}}{c}$ \\
\oo Assume $\forall \psi.\; 
       \mspec{G(\phi \otimes \psi)}
            {\cmd}
            {a}{G(\phi' \otimes R(u, \psi)) \land \exists z.\; a = (v, z) \land \mathit{set}(r, z, r)} $ \\
\oo Assume we have some $\psi$ \\
\ooo Assume we are in a prestate $G(\phi \otimes \psi)$ \\
\ooo So there is an $H = (D,h)$ such that $\mathit{Inv}(H, \phi \otimes \psi)$ holds \\
\ooo Hence we know that \\
\ooox $R^\dagger_H = O_H$ \\
\ooox $R^+_H$ strict partial order \\
\ooox $R_H \subseteq V_H \times V_H$ \\
\ooox $\mathit{unique}(H)$ \\
\ooox $H, D \models \phi \otimes \psi$ \\
\ooox $\mathit{heap}(H)$ \\
\ooo Since $\mathsf{unready}$ is sound, we know that $\mathit{value}(h'(c)) = \None$ \\
\ooo Hence we also know that $H, D \models \phi \otimes \cellneg{c}{\cmd} \otimes \psi$ \\
\ooo We also know that $c.\mathit{value} \pointsto \None$ \\
\ooo $[\letv{o}{!a.\mathit{value}}{}$ \\
\ooo Now we additionally know that $o = \None$ \\
\ooo Hence we can simplify the remaining program to eliminate the case \\
\ooo $\letv{\cmd}{!a.code}{}$ \\
\ooo From the definition of $\mathit{heap}$, we know that $\cmd = \mathit{code}(h(c))$ \\
\ooo From the fact that $H, D \models \phi \otimes \cellneg{c}{\cmd} \otimes \psi$, \\
\oox we know $\mathit{code}(h(c)) = \cmd$ \\
\ooo $\letv{(v',z)}{\cmd}{}$ \\
\ooo Using our assumption about $\cmd$, and setting $\psi$ to $\cellneg{c}{\cmd} \otimes \psi$, \\
\ooo our poststate is $G(\phi' \otimes R(u, \cellneg{c}{\cmd} \otimes \psi)) \land v = v' \land \mathit{set}(r, z, r)$ \\
\ooo Simplifying away the $v'$, we get $\mathit{set}(r, z, r)$ and $G(\phi' \otimes \cellneg{c}{\cmd} \otimes R(u, \psi))$ \\
\ooo So there is a shadowing $H = (D,h)$ such that $\mathit{Inv}((D, h), \phi' \otimes R(u, \cellneg{c}{\cmd} \otimes \psi))$ \\
\ooo Now take $H' = (D,h')$ and $h'$ as in the semantic update lemma \\
\ooo We know $H', D \models R(\setof{a}, \phi' \otimes \cellpos{c}{\cmd}{v}{r} \otimes R(u, \psi))$\\
\ooo So we know $H', D \models R(\setof{a}, \phi') \otimes \cellpos{c}{\cmd}{v}{r} \otimes R(u \cup \setof{a}, \psi))$ \\
\ooo Furthermore we know that this $H'$ preserves the relevant order structure \\
\ooo $\letv{\_}{[a.value := v']}{}$ \\
\ooo $\letv{\_}{[a.reads := z]}{}$ \\
\ooo $\letv{\_}{\mathsf{iterset}\;(\mathsf{add\_observer}\;a)\;z}{}$ \\
\ooo These commands establish $\mathit{heap}(H')$ \\
\ooo The last requires an induction based on the size of $r$ \\ 
\oox and the unfolding axiom in the cellset interface \\
\ooo Now we know $\mathit{Inv}(H', R(\setof{a}, \phi') \otimes \cellpos{c}{\cmd}{v}{r} \otimes R(u \cup \setof{a}, \psi))$ \\
\ooo So we know $G(R(\setof{a}, \phi') \otimes \cellpos{c}{\cmd}{v}{r} \otimes R(u \cup \setof{a}, \psi))$ \\
\ooo $(v, z)]$ \\
\ooo So $\exists z.\;a = (v,z) \land \mathit{set}(\setof{c}, z, \setof{c})$ 
\end{tabbedproof}
\end{proof}

\subsection{Proving the correctness of \textsc{AConseq}}

\begin{prop*}{(The correctness of the \textsc{AConseq} specification)}
The following specification is valid:
\begin{displaymath}
\begin{array}{l}
\setof{\phi' \vdash \phi} \specand \setof{\theta \vdash \theta'} \specand \\
\forall \psi.\; \mspec{G(\phi \otimes \psi) \land P}{\cmd}{(x,z)}{G(\theta\otimes R(u, \psi)) \land Q} \\
\specimp \\
\forall \psi.\; \mspec{G(\phi' \otimes \psi) \land P}{\cmd}{(x,z)}{G(\theta'\otimes R(u, \psi)) \land Q}  \\
\end{array}
\end{displaymath}
\end{prop*}

\begin{proof}
\begin{tabbedproof}
\oo Assume we know $\phi' \vdash \phi$ and $\psi \vdash \psi'$ \\
\oo Furthermore assume $\forall \psi.\; \spec{G(\phi \otimes \psi) \land P}{\cmd}{(x,z)}{G(\theta\otimes R(u, \psi)) \land Q}$ \\
\ooo Now assume $\psi$, and that we are in a prestate $G(\phi' \otimes \psi) \land P$ \\
\ooo So we know there is an $H$ such that $\mathit{Inv}(H, \phi' \otimes \psi)$ \\
\ooo Since $\phi' \models \phi$, we know that $H, D \models \phi \otimes \psi$ \\
\ooo Hiding the existential again, we know that $G(\phi \otimes \psi) \land P$ \\
\ooo $\cmd$
\ooo Now by assumption we know $G(\theta \otimes R(u, \psi)) \land Q$ \\
\ooo So we know there is an $H$ such that $\mathit{Inv}(H, \theta \otimes \psi)$ \\
\ooo Since $\theta \vdash \theta'$, we know that $\mathit{Inv}(H, \theta' \otimes \psi)$ \\
\ooo Hiding the existential, we get the poststate $G(\theta'\otimes R(u, \psi)) \land Q$ \\
\end{tabbedproof}
\end{proof}

\subsection{Proving the correctness of \textsc{AGetRef}}
\begin{prop*}
The following specification is valid: 
\begin{displaymath}
\begin{array}{ll}
    \forall \psi.\; 
    &  \left<G(\localref{r}{v} \otimes \psi)\right> \\
    &  \getref r \\
    &  \left<a.\; G(\localref{r}{v} \otimes \psi) 
                  \land  \exists z.\;a = (v,z) \land \mathit{set}(\emptyset, z, \emptyset)
       \right> \\
     \end{array}
\end{displaymath}
\end{prop*}
\begin{proof}
\begin{tabbedproof}
\oo Assume we are in a prestate $G(\localref{r}{v} \otimes \psi)$ \\
\oo So there is an $H = (D,h)$ such that $Inv(H, \localref{r}{v} \otimes \psi)$ holds \\
\oo The spatial part of $Inv$ is $heap(H) * \mathit{refs}(\localref{r}{v} \otimes \psi)$ \\
\oo This is the same as $heap(H) * {r}\pointsto{v} * \mathit{refs}(\psi)$ \\
\oo $[\letv{x}{[!r]}{}$ \\
\oo This leaves us in $Inv(H, \localref{r}{v} \otimes \psi) \land x = v$ \\
\oo $\pair{v}{\ctext{emptyset}}]$ \\
\oo $G(\localref{r}{v} \otimes \psi) \land a = \pair{v}{\ctext{emptyset}}$ \\
\end{tabbedproof}
\end{proof}

\subsection{Proving the correctness of \textsc{ASetRef}}

\begin{lemma}{(Preservation of Satisfiability under Local Store Changes)}
We need $\satisfies{H}{\localref{r}{v} \otimes \psi}$ if and only if $\satisfies{H}{\localref{r}{v'} \otimes \psi}$ holds.
\end{lemma}
\begin{proof}
This follows by an easy induction on $\psi$, since $sat(H, D, \localref{r}{v}) = \top$. 
\end{proof}

\ \\

\begin{prop*}
The following specification is valid:
\begin{displaymath}
\begin{array}{ll}
\forall \psi.\; 
  &    \left<G(\localref{r}{v'} \otimes \psi)\right> \\
  &    \setref r\;v \\
  &    \left<a.\; G(\localref{r}{v} \otimes \psi) 
                  \land  \exists z.\;a = (v,z) \land \mathit{set}(\emptyset, z, \emptyset)
       \right> 
\end{array}
\end{displaymath}
\end{prop*}

\begin{proof}
\begin{tabbedproof}
\oo Assume we are in a prestate $G(\localref{r}{v'} \otimes \psi)$ \\
\oo Then there is an $H$ such that $R^\dagger_H$ and  $R^+_H$ is a strict partial order, \\
\oo and $R_H \subseteq V_H \times V_H$ and $\mathit{unique}(H)$ and $\satisfies{H}{\localref{r}{v'} \otimes \phi}$ \\
\oo and spatially $\mathit{heap}(H) * \mathit{refs}(\localref{r}{v'} \otimes \phi)$\\
\oo The spatial part is equivalent to $\mathit{heap}(H) * r \pointsto v' * \mathit{refs}(\phi)$ \\
\oo $[\letv{()}{[r := v]}{}$ \\
\oo Hence $\mathit{heap}(H) * r \pointsto v * \mathit{refs}(\phi)$ \\
\oo Hence $\mathit{heap}(H) * \mathit{refs}(\localref{r}{v} \otimes \phi)$ \\
\oo By lemma, $\satisfies{H}{\localref{r}{v} \otimes \phi}$ \\
\oo Hence $Inv(H, \localref{r}{v} \otimes \phi)$ \\
\oo Hence $G(\localref{r}{v} \otimes \phi)$ \\
\oo $\pair{\unit}{\ctext{emptyset}}]$ \\
\oo Hence $G(\localref{r}{v} \otimes \phi) \land a = \pair{\unit}{\ctext{emptyset}}$ \\
\end{tabbedproof}
\end{proof}

\section{Implementing Functional Reactive Programming}

In this section, we will see how to verify an imperative
implementation of a simple synchronous functional reactive programming
system.

\subsection{Specifying Functional Reactive Programs}

\emph{Functional Reactive Programming}~\cite{frp} is a style of
writing interactive programs based on the idea of \emph{stream
  transducers}.  The idea is to model a time-varying input signal of
type $A$ as an infinite stream of $A$'s, and to model an interactive
system as a function that takes a stream of inputs $\stream{A}$ and
yields a stream of outputs $\stream{B}$. Note that a stream can be
viewed either as an infinite sequence of values, or isomorphically as
a function from natural numbers to values (i.e., a function from times
to values). In our discussion, we'll switch freely between these two
views, using the most convenient viewpoint.\footnote{Given an infinite stream $vs$, we will use use $take\;n\;vs$ to denote
the finite list consisting of the first $n$ elements of the stream
$vs$. Correspondingly, $drop\;n\;vs$ is the infinite stream with $vs$
with its first $n$ elements cut off. With a function $f$, $map\;f\;vs$
maps $f$ over the elements of $vs$, and given another infinite stream
$us$, the call $zip\;us\;vs$ returns the infinite stream of pairs of
elements of $us$ and $vs$. If $v$ is an element, $v \cdot vs$ will 
denote consing $v$ to the front of $vs$, and if $xs$ is a finite list, then
$xs \cdot vs$ will denote appending the finite sequence $xs$ to the
front of $vs$. Finally, we will write $vs_n$ to denote the $n$-th element
of the stream $vs$.}

However, not all functions $\stream{A} \to \stream{B}$ are legitimate
stream transducers; we need to restrict our attention to \emph{causal}
stream transducers. A transducer is causal if we can compute the first
$n$ elements of the output after having read at most $n$ elements of
the input. 

\begin{tabbing}
$causal(f : \stream{A} \to \stream{B}) \equiv$ \\
\;\;\= $\exists \hat{f} : \listtype{A} \to \listtype{B}.\;\forall as:\stream{A}, n:\N.$ \\
    \> \;\;$take\;n\;(f\;as) = \hat{f}\;(take\;n\;as)$ 
\end{tabbing}

If we are given a causal transducer $p$, we will write $\hat{p}$ to
indicate the corresponding list function which computes its finite
approximations. Then, we can define a family of combinators acting on
causal transducers, which we give in Figure~\ref{transducer-semantics}.

\begin{figure}
\mbox{}
\begin{tabbing}
$\ST{A}{B} = \comprehend{f \in \stream{A} \to \stream{B}}{causal(f)}$\\[1em]

$lift : (A \to B) \to \ST{A}{B}$ \\
$lift\;f\;as = map\;f\;as$ \\[1em]

$seq  : \ST{A}{B} \to \ST{B}{C} \to \ST{A}{C}$ \\
$seq\;p\;q = q \circ p$ \\[1em]

$par  : \ST{A}{B} \to \ST{C}{D} \to \ST{A \times C}{B \times D}$ \\
$par\; p\;q\;abs = zip\; (p\;(map\;\pi_1\;abs))\;(q\;(map\;\pi_2\;abs))$\\[1em]

$switch : \N \to \ST{A}{B} \to \ST{A}{B} \to \ST{A}{B}$ \\
$switch\;k\;p\;q = \semfun{as}{(take\;k\;(p\;as))\cdot(q\;(drop\;k\;as))}$ \\[1em]

$loop : A \to \ST{A\times B}{A \times C} \to \ST{B}{C}$ \\
$loop\;a_0\;p = (map\;\pi_2) \circ (cycle\;a_0\;p)$ \\[1em]

$cycle : A \to \ST{A\times B}{A \times C} \to \ST{B}{A \times C}$ \\
$cycle\;a_0\;p = \lambda bs.\;\lambda n.\;last(gen\;a_0\;p\;v\;n)$ \\[1em]

$gen : A \to \ST{A\times B}{A \times C} \to \listtype{(A \times C)}$\\
$gen\;a_0\;p\;bs\;0 \;\;\; = \hat{p}\; [(a_0, bs_0)]$ \\
$gen\;a_0\;p\;bs\;(n+1) = $ \\
\;\;$\hat{p}\;(zip (a_0 \cdot (map\;\pi_1\;(gen\;a_0\;p\;bs\;n)))\;
                                        (take\;(n+2)\;bs))$ 
\end{tabbing}
\caption{Semantics of Stream Transducers}
\label{transducer-semantics}
\end{figure}

The operation $lift\;f$ creates a stream transducer that simply maps
the function $f$ over its input. Calls to $seq\;p\;q$ are sequential
composition: it feeds the output of $p$ into the input of $q$. The
operator $par\;p\;q$ defines parallel composition --- it takes a
stream of pairs, and feeds each component to its arguments,
respectively, and then merges the two output streams to produce the
combined output stream. The function $switch\;k\;p\;q$ is a very
simple ``switching combinator''.  It behaves as if it were $p$ for the
first $k$ time steps, and then behaves as if it were $q$, only
starting with the input stream beginning at time $k$.

The combinator $loop\;a_0\;p$ is a feedback operation. It acts
upon a transducer $p$ which takes pairs of $A$s and $B$s, and yields
pairs of $A$s and $C$s. It turns it into a combinator that takes $B$s
to $C$s, by giving $p$ the value $a_0$ (and its $B$-input) on the
first time step, and uses the output $A$ at time $n$ as the input $A$
at time $n+1$. This is useful for constructing transducers that do
things like sum their inputs over time, and other stateful operations. 

Because this function involves feedback, it should not be surprising
that it makes use of the causal nature of its argument operation. The
$loop$ function is defined in terms of $cycle$, which also returns the
sequence of output $A$s, and $cycle$ is defined in terms of $gen$,
which is a function that given an argument $n$ returns a list of
outputs for the time steps from $0$ to $n$. Notice that
$gen\;a_0\;p\;bs\;n$ will always return $n+1$ elements (e.g., at
argument 0, it will return a 1 element list containing the output at
time step 0), which means that the call to $last$ in $cycle$ is
actually safe. In order to calculate $gen$, we need to recursively
calculate the outputs for all smaller time steps, and this is what
$\hat{p}$ is needed for --- it is what lets us know that $p$ has a good
finite approximation.

All of these definitions are familiar to functional programmers, and
there are many techniques to prove properties of these functions ---
coinductive proofs, the $take$-lemma of \citet{bird-wadler}, arguments based on
the isomorphism between streams and functions from natural
numbers. All of these serve to make proving properties about stream
transducers very pleasant. For example, one property we will need in
the next section is the following:

\begin{lemma}{(Loop Unrolling)} We have that 
  \begin{displaymath}
    cycle\;a_0\;p\;bs = f\;(zip\;(a_0\cdot(map\;\pi_1\;(cycle\;a_0\;p\;bs)))\;bs)
  \end{displaymath}
\end{lemma}

\begin{proof}
  This is easily proved using Bird and Wadler's $take$-lemma, which
  says that two streams are equal if all their finite prefixes are
  equal.
\end{proof}


\subsection{Realizing Stream Transducers with Notifications}

\begin{figure}
\mbox{}
\begin{tabbing}
$\ST{\alpha}{\beta} \equiv \celltype{\alpha} \to \monad{\celltype{\beta}}$ \\[1em]

$\liftop : \forall \alpha,\beta:\star.\; (\alpha \to \beta) \to \ST{\alpha}{\beta}$ \\
$\liftop\;f\;input = $ \\
\;\; $\newcell\; (\bind\;(\readcell input)\; (\fun{x}{\alpha}{\return (f\;x)}))$ \\[1em]

$\composeop : \forall \alpha,\beta,\gamma:\star.\; \ST{\alpha}{\beta} \to \ST{\beta}{\gamma} \to \ST{\alpha}{\gamma}$ \\
$\composeop p\;q\;input = [$\=$\letv{middle}{p\;input}$ \\
                            \>$\letv{output}{q\;middle}$ \\ 
                            \>$\;output]$ \\[1em]

$\parop : \forall \alpha,\beta,\gamma,\delta:\star.\; \ST{\alpha}{\beta} \to \ST{\gamma}{\delta} \to \ST{\alpha \times \gamma}{\beta \times \delta}$ \\
$\parop p \; q \; input = $ \\
\;\;$[$\=$\ctext{letv}\;a = \newcell\; (\bind$\=$(\readcell\;input)$ \\
     \>                                   \>$(\fun{x}{\alpha\times \beta}{\return (\fst{x})}))$ \\
     \>$\ctext{letv}\;b = {p\;a}{}$ \\
     \>$\ctext{letv}\;c = \newcell\; (\bind$\=$(\readcell\;input)\;$\\ 
     \>                                   \>$(\fun{x}{\alpha\times \beta}{\return (\snd{x})}))$ \\
     \>$\ctext{letv}\;d = {q\;b} = $ \\
     \>$\ctext{letv}\;output = \newcell\; ($\=$\bind (\readcell b)\; (\lambda b:\beta.$ \\
     \>                                   \>$\bind (\readcell d)\; (\lambda d:\delta.$ \\
     \>                                   \>$\;\;\return \pair{b}{d})))] \;\ctext{in}$ \\
     \>$\;output]$ \\[1em]

$\switchop : \forall \alpha,\beta:\star.\; \N \to \ST{\alpha}{\beta} \to \ST{\alpha}{\beta} \to \ST{\alpha}{\beta}$ \\
$\switchop k\;p\;q\; input =  $ \\
\;\;$[$\=$\letv{r}{\newref{\N}{0}}{}$ \\
    \>$\letv{a}{p\;input}$ \\
    \>$\letv{b}{p\;input}$ \\
    \>$\ctext{letv}\; out = \newcell\; ($\=$\bind (\getref r) \;(\lambda i:\N.\;$ \\
    \>                                 \>$\bind (\setref r\;(i+1)) \; (\lambda q:\unittype.$ \\
    \>                                 \>$\;\;\ctext{if}(i < k, \readcell a, \readcell b)))) \;\ctext{in}$ \\
    \>$\;\;out]$\\[1em]

$\loopop : \forall \alpha,\beta,\gamma:\star.\; \alpha \to \ST{\alpha\times \beta}{\alpha\times \gamma} \to \ST{\beta}{\gamma}$ \\
$\loopop a_0\; p \; input = $ \\
\;\;$[$\=$\letv{r}{\newref{\alpha}{a_0}}{}$ \\
    \>$\ctext{letv}\; ab = \newcell\; ($\=$\bind (\readcell input)\; (\lambda b:\beta.$ \\
    \>                                \>$\bind (\getref r)\;       (\lambda a:\alpha.$ \\
    \>                                \>$\;\; \return \pair{a}{b}))) \;\ctext{in}$ \\
    \>$\letv{ac}{p\;ab}{}$ \\
    \>$\ctext{letv}\;c = \newcell\; ($\=$\bind (\readcell ac) \;(\lambda v:\alpha \times \gamma.$ \\
    \>                              \>$\bind (\setref r\;(\fst{v})) \;(\lambda q:\unittype.$ \\
    \>                              \>$\;\;\return (\snd{v}))))\;\ctext{in}$ \\
    \>$\;\;c]$ 
\end{tabbing}
\caption{Imperative Stream Transducers}
\label{imperative-transducer-impl}
\end{figure}

While the definitions in the previous subsection yield very clean
proofs, they are not suitable as implementations --- for example,
$loop$ recomputes an entire history at each time step! We can derive
better implementations by thinking about how imperative, event-driven
programming works.

The intuition underlying event-driven programming is that a stream
transducer is implemented with the combination of a notification
network, and an \emph{event loop}.  The event loop is a
(possibly-infinite) loop which updates an input cell at teach time
step, to reflect the events that occurred on that time step, and then
it reads the output cell of the network. When the input cell is
updated, invalidations are propagated throughout the dependency
network, and when the outputs are read, exactly the necessary
re-computations are performed.

We will shortly formalize exactly this idea, but we will first discuss
the implementation given in
Figure~\ref{imperative-transducer-impl} in informal terms. Here,
we define the type of imperative stream transducers as a function type
$\celltype{A} \to \monad{(\celltype{B})}$. This type should be read as
saying that the implementation is a function that, given an input cell
of type $A$, will \emph{construct} a dataflow notification network
realizing the corresponding transducer, and whose return value is the
output cell of type $B$ that the event loop should read. 

The simplest example of this is $\liftop\;f$. It will take an input
cell $input$, and build a new cell which reads $input$, and return $f$
applied to that value. Likewise, given two imperative implementations $p$
and $q$, $\composeop\;p\;q$ will take an input cell, and feed the
input to $p$ to build a network whose output is named $middle$, and
will then give $middle$ to $q$ to get the final output cell. The
overall network will be network built by the calls to both $p$ and
$q$, which interact through $p$'s network putting a value in $middle$,
and $q$'s network reading it.

The operation $\switchop\;k\;p\;q$ is the first example that uses 
local state. Given an $input$ cell, we first build networks corresponding
to $p$ and to $q$ (with outputs $a$ and $b$, respectively). Then we
create a local reference $r$, initialized to $0$. Then we build a cell $out$,
whose code reads and increments $r$, and which will read $a$ or $b$ depending
on whether the reference's contents are less than or equal to $k$. Notice
that the demand-driven nature of evaluation means that we never redundantly
evaluate $p$ or $q$'s networks --- we only ever execute one of them. 

Finally, the operation $\loopop a_0\;p$ builds a feedback network by
explicitly creating a reference to hold an accumulator parameter. It
constructs a local reference initialized to $a_0$, and then constructs
a cell $ab$ which reads the input and the local reference to produce a
pair of type $A \times B$. This cell is given to $p$, to construct a
network with an output cell $ac$, yielding pairs of type $A \times
C$. Finally, we construct the overall output cell $c$, which reads
$ac$ and updates the local reference with a new value of type $A$, and
returns a value of type $C$. The use of a local reference (rather than
a cell) to store the current state of $A$ is essential, because we need
to maintain the acyclicity of the dataflow graph. 

\subsection{Formally Specifying Transducers}

In Figure~\ref{transducer-specification}, we give the predicates we
will use to specify our imperative stream transducer library. The key
predicate is the predicate $\mathit{Transduce}(vs, i, \phi, o, ws)$
which says that the dataflow network $\phi$ reads the streams $vs$ on
input cell $i$, and writes the stream $ws$ on the output cell $o$. The
only subtlety in this specification is that $\phi$ is a function in
$\N \to \mathsf{formula}$, giving the formula of the dataflow network
as a function of time.

However, the definition of the predicate itself is consderably more
complicated. The first five lines of the specification give syntactic
conditions on readiness and unreadiness. 
\begin{enumerate}
\item The first condition, that $\unready{\theta}{i} \implies
\unready{\theta \otimes \phi_n}{o}$, says that the output $o$ must
depend on the input cell $i$.

\item The second condition, that $\ready{\theta}{i}{vs_n} \implies
  \ready{\theta \otimes \phi_{n+1}}{o}{ws_n}$, says that when the
  input cell $i$ has been read for its value $vs_n$, then the output
  cell will be ready with the value $ws_n$, and furthermore the
  network $\phi_{n+1}$ will have evolved to the state it will use to
  execute at time $n + 1$.

\item The condition $\closed{\phi_n}{\domain{\phi_n} \cup \setof{i}}$
means that $\phi_n$ depends on no external cells except for the input
cell $i$. 

\item The condtion $o \in \domain{\phi_n}$ simply ensures that the
output cell is always part of the network that computes it. 

\item The condition $\unready{R(\setof{i}, \phi_n)}{o}$ ensures
that the output is not ready to read, after we update the input
cell with a new, yet-to-be-read value. 
\end{enumerate}

Then, we can give the specification for the transducer itself.  The
intuitive reading of the specification is that if reading $i$ produces
a value $vs_n$, then reading $o$ should produce the value
$ws_n$. However, this definition is complicated by the fact that we do
not wish to specify the exact state owned by $i$ --- we are only
interested in the state $\phi$, and want our specification to work
obliviously to the state read by $i$. So we state the specification of
$o$ hypothetically, quantifying over the specification of $o$. So our
specification says that for any $\theta$ and $\theta'$, for which
reading $i$ leads to value $vs_n$ with ramification $u$, then reading
$o$ will give us the desired value $ws_n$. 

The other hypothetical assumptions give syntactic representations to
some natural conditions on $\theta$ and $\theta'$. Namely, if $i$ is
ready in $\theta$, then reading $\theta$ should do nothing (i.e.,
$\theta' = \theta$. If $i$ is not ready in $\theta$, then $i$ should
be ready with value $vs_n$ in $\theta'$, and finally that $\theta'$
should be closed, meaning that it has everything needed to evaluate
$i$. 

The $\mathit{Realize}$ predicate simply says that $\mathsf{\hat{f}}$
is a realizer for the function $f$, which means that executing it 
with input cell $i$ builds a dataflow graph which can act as a 
suitable transducer.  


\begin{figure}
\begin{specification}
\\ $\mathit{Transduce}(vs, i, \phi, o, ws)  =  $
\nextline $\forall \theta, n.\; \unready{\theta}{i} \implies \unready{\theta \otimes \phi_n}{o} \specand$ 
\nextline $\forall \theta, n.\; \ready{\theta}{i}{vs_n} \implies \ready{\theta \otimes \phi_{n+1}}{o}{ws_n} \specand$
\nextline $\forall n.\; \closed{\phi_n}{\domain{\phi_n} \cup \setof{i}} \specand$ 
\nextline $\forall n.\; o \in \domain{\phi_n} \specand$
\nextline $\forall n.\; \unready{R(\setof{i}, \phi_n)}{o} \specand$
\nextline\;\; $\forall n, \theta, \theta', u \subseteq \domain{\theta}.$  
\nextline\qquad\=$(\ready{\theta}{i}{v_n} \land \theta = \theta' \land u = \emptyset \specor
                         \unready{\theta}{i} \land i \in u) \specand$ 
\nextline\> $\ready{\theta'}{i}{v_n} \specand \closed{\theta'}{\domain{\theta'}} \specand$
\nextline\> $\forall \psi.\;$\=$\left<G(\theta \otimes \psi)\right>$ 
\nextline\>\> $\readcell i$
\nextline\>\> $\left<a.\;a = (vs_n, \setof{i}) \land G(\theta' \otimes R(u,\psi)\right>$ 
\nextline\> $\specimp$ 
\nextline\> $\exists \setof{o} \subseteq u' \subseteq \domain{\phi_n}.\;  \forall \psi.\;$\=$\left<G(\theta \otimes R(\setof{i}, \phi_n) \otimes \psi)\right>$ 
\nextline\>\>$\readcell o$ 
\nextline\>\>$\left<a.\;a = (ws_n, \setof{o}) \land 
                        G(\theta' \otimes \phi_{n+1} \otimes R(u \cup u', \psi))\right>$ 
\end{specification}


\begin{specification}
\nextline $\mathit{Realize}(\mathsf{\hat{f}}, f) = $ 
\nextline\;\;\= $\forall \psi, i.\; \spec{G(\psi)}{\mathsf{\hat{f}}\;i}{a}{\exists \phi.\;G(\psi \otimes R(\setof{i}, \phi_0)) \land \forall vs.\;\mathit{Transduce}(vs, i, \phi, a, f\;vs)}$
\end{specification}
\caption{Transducer Specification}
\label{transducer-specification}
\end{figure}


\subsection{Correctness Proofs}

\begin{prop}{(FRP Correctness)}
Then, the following specifications are provable: 
\begin{enumerate}
\item $\forall f:A\to B.\; \mathit{Realize}(\liftop f, \mathit{lift}\;f)$
\item $\forall p, f, q, g.\;\mathit{Realize}(p, f) \specand \mathit{Realize}(q, g) \specimp \mathit{Realize}(\composeop p\;q, \mathit{compose}\;f\;g)$
\item $\forall p, f, q, g.\;\mathit{Realize}(p, f) \specand \mathit{Realize}(q, g)
                       \specimp \mathit{Realize}(\parop p\;q, par\;f\;g)$
\item $\forall k, p, f, q, g.\;\mathit{Realize}(p, f) \specand \mathit{Realize}(q, g)
                          \specimp \mathit{Realize}(\switchop k\;p\;q, switch\;k\;f\;g)$
\item $\forall a_0, p, f.\; \mathit{Realize}(p, f) \specimp \mathit{Realize}(\loopop\;a_0\;p, loop\;a_0\;f)$
\end{enumerate}

\end{prop}

\noindent To prove these properties, we will first prove transduction lemmas for each kind of 
network, and then show that each operator creates an appropriate network. 

\subsubsection{Correctness of $\mathsf{lift}$}

\begin{lemma}{(The $\mathsf{lift}$ network)}
It is the case that $\mathit{Transduce}(vs, i, \phi, c, \mathit{lift}\;f\;vs)$ holds, when
\begin{itemize}
\item $\phi = \semfun{n}{\cellpos{c}{e}{ws_n}{\setof{i}}}$, where $ws = x \cdot (f\;vs)$ for some dummy $x$ and
\item $e = \bind (\readcell i)\; (\semfun{v}{\return (f\;v)})$
\end{itemize}
\end{lemma}

\begin{proof}
\begin{itemize}
\item First, it is clear that for all $\theta$ and $n$, if $\unready{\theta}{i}$, then $\unready{\theta \otimes \phi_n}{c}$, since $i$ is in the read set of $\phi_n$. 
\item Second, it is clear that for all $\theta$ and $n$, if $\ready{\theta}{i}{v_n}$, then $\ready{\theta \otimes \phi_n}{c}{(f\;v)_n}$, since the read set of $\phi_n$ is $i$, which is by hypothesis ready. 
\item Third, it is immediately clear that for all $n$, $\closed{\phi_n}{\setof{i} \cup \domain{\phi_n}}$,
since $\phi_n$ has a single cell whose read set contains only $i$. 
\item Fourth, it is immediate $c \in \domain{\cellpos{c}{e}{ws_n}{\setof{i}}}$
\item Fifth, for all $n$, we know that $R(\setof{i}, \phi_n) = \cellneg{c}{e}$, which obviously satisfies $\unready{R(\setof{i}, \phi_n)}{c}$ 

\end{itemize}
Now we need to show the implication over triples. 
\begin{tabbedproof}
\oo Assume we have $n$, $\theta$, $\theta'$ and $u \subseteq \domain{\theta}$. \\
\oo Assume that either $\ready{\theta}{i}{v_n}$ and $\theta = \theta'$ and $u = \emptyset$,  \\
\oo or $\unready{\theta}{i} \land i \in u$ \\
\oo Assume that $\closed{\theta'}{\domain{\theta'}}$ and that $\ready{\theta'}{i}{v_n}$ \\
\oo Assume for all $\psi$, we have \\
\ox  $\mspec{G(\theta \otimes \psi)}{\readcell i}{a}{a = ((f\;v)_n, \setof{c}) 
      \land G(\theta' \otimes R(u,\psi))}$ \\
\oo Now assume we have a $\psi$ and a prestate $G(\theta \otimes R(\setof{i}, \phi_n) \otimes \psi)$ \\
\oo We know $R(\setof{i}, \phi_n) = \cellneg{c}{e}$ \\
\oo So we know $\unready{\theta \otimes R(\setof{i}, \phi_n) \otimes \psi}{c}$ \\
\oo By the \textsc{AUnready}, \textsc{ABind}, and \textsc{AUnit} rules, we end in a state \\
\oo $G(R(u',\theta') \otimes \cellpos{c}{e}{f\;v_n}{\setof{i}} \otimes R(u \cup u',\psi)) \land a = (f\;v_n, \setof{o})$ \\
\oo where $u' = \setof{c}$ \\
\oo Since $c$ does not occur in $\theta'$ or else false is entailed, we know $c \not\in \domain{\theta'}$ \\
\oo Since $\theta'$ is closed with respect to its domain, $R(u',\theta') = \theta'$ \\
\oo Note that $f\;v_n = (\mathit{lift}\;f\;v)_n$, hence we have the conclusion we want. \\
\end{tabbedproof}

\end{proof}

\subsubsection{Correctness of $\mathsf{compose}$}

\begin{lemma}{(The $\mathsf{compose}$ network)}
If it is the case that $\mathit{Transduce}(vs, i, \phi, m, f\;vs)$ holds, and that
$\mathit{Transduce}(f\;vs, m, \sigma, o, g(f\;vs))$ holds, then it is the case that
$\mathit{Transduce}(vs, i, \phi \otimes \sigma, o, g\;(f\;vs))$ holds.
\end{lemma}

\begin{proof}
\begin{itemize}
\item First, we want to show that for all $\theta, n$, if $\unready{\theta}{i}$ then $\unready{\theta \otimes \phi_n \otimes \sigma_n}{o}$. 

  To show this assume $\unready{\theta}{i}$. Then we know from $\mathit{Transduce}(vs, i, \phi, m, f\;vs)$
  that $\unready{\theta \otimes \phi_n}{m}$. Then we know from $\mathit{Transduce}(f\;vs, m, \sigma, o, g(f\;vs))$
  that $\unready{\theta \otimes \phi_n \otimes \sigma_n}{o}$. 

\item Second, we want to show that for all $\theta, n$, if
  $\ready{\theta}{i}{vs_n}$ then $\ready{\theta \otimes \phi_n \otimes
  \sigma_{n+1}}{o}{(f\;vs)_n}$.

  Assume $\ready{\theta}{i}{vs_n}$. 

  Then we know from $\mathit{Transduce}(vs, i, \phi, m, f\;vs)$ that
  $\ready{\theta \otimes \phi_{n+1}}{m}{(f\;vs)_n}$. Then we know from
  $\mathit{Transduce}(f\;vs, m, \sigma, o, g(f\;vs))$ that
  $\ready{\theta \otimes \phi_{n+1} \otimes
    \sigma_{n+1}}{o}{(g\;(f\;vs))_n}$.

\item Third, we want to show that $\unready{R(\setof{i}, \phi_n \otimes \sigma_n)}{o}$. 

  By hypothesis, we know that $\unready{R(\setof{i},
    \phi_n)}{m}$. Hence $\unready{R(\setof{i}, \phi_n) \otimes
    \sigma_n}{o}$, and hence $\unready{R(\setof{i}, \phi_n \otimes
    \sigma_n)}{o}$, since $\sigma$ is closed with respect to $i$. 

\item Fourth, we want to show that $\closed{\phi_n \otimes \sigma_n}{\domain{\phi_n \otimes \sigma_n} \cup \setof{i}}$. We know that  $\closed{\phi_n}{\domain{\phi_n} \cup \setof{i}}$ and 
$\closed{\sigma_n}{\domain{\sigma_n} \cup \setof{m}}$. So we know that $\closed{\phi_n \otimes \sigma_n}{\domain{\phi_n \otimes \sigma_n} \cup \setof{i,m}}$. Since $m \in \domain{\phi_n}$, we have that
$\closed{\phi_n \otimes \sigma_n}{\domain{\phi_n \otimes \sigma_n} \cup \setof{i}}$

\item Finally we want to show that $o \in \domain{\phi_n \otimes \sigma_n}$. Since $o \in \domain{\sigma_n}$,
  it follows immediately that $o \in \domain{\phi_n \otimes \sigma_n}$. 


\end{itemize}

Now, let's prove the entailment of specifications. 

\begin{tabbedproof}
\oo Assume we have $\theta, \theta', n$, and $u$. \\
\oo Assume that either $\ready{\theta}{i}{v_n}$ and $\theta = \theta'$ and $u = \emptyset$,  \\
\oo or $\unready{\theta}{i} \land i \in u$ \\
\oo Assume that $\closed{\theta'}{\domain{\theta'}}$ \\
\oo Assume that $\ready{\theta'}{i}{v_n}$ and $\closed{\theta'}{\domain{\theta'}}$ \\
\oo Assume for all $\psi$, we have \\
\ox  $\mspec{G(\theta \otimes \psi)}{\readcell i}{a}{a = ((f\;v)_n, \setof{c}) 
      \land G(\theta' \otimes R(u,\psi)) }$ \\
\oo Assume we have a $\psi$. Now, we use the hypothesis above, together \\
\oo with the fact that $\mathit{Transduce}(f\;vs, m, \sigma, o, g(f\;vs))$ holds, \\
\oo to conclude that there is a $u'$ such that $\setof{m} \subseteq u' \subseteq \domain{\phi_n}$ and \\
\ox $\left<G(\theta \otimes R(\setof{i}, \phi_n) \otimes \psi)\right>$ \\
\ox $\readcell m$ \\
\ox $\left<a.\;G(\theta' \otimes \phi_{n+1} \otimes R(u \cup u',\psi)
             \land  a = ((f\;v)_n, \setof{m})\right>$ \\
\oo Note that since $\theta'$ is closed with respect to its own domain and $\phi_n$ is closed with \\
\oo respect to $i$ and its own domain, we have $\closed{\theta' \otimes \phi_{n+1}}{\domain{\theta' \otimes \phi_{n+1}}}$ \\
\oo Note also that $m \in u \cup u'$ and $\unready{\theta \otimes R(\setof{i}, \phi_n)}{m}$ \\
\oo Furthermore, since $\ready{\theta'}{i}{v_n}$, we know $\ready{\theta' \otimes \phi_{n+1}}{m}{(f\;v)_n}$ \\
\oo Hence from $\mathit{Transduce}(f\;vs, m, \sigma, o, g(f\;vs))$, we can conclude that \\
\oo there is a $u''$ such that $\setof{o} \subseteq u'' \subseteq \domain{\sigma_n}$ and for all $\psi$ \\
\ox $\left<G(\theta \otimes R(\setof{i}, \phi_n) \otimes R(\setof{m}, \sigma_n) \otimes \psi)\right>$ \\
\ox $\readcell o$ \\
\ox $\left<a.\;G(\theta' \otimes \phi_{n+1} \otimes \sigma_{n+1} \otimes R(u \cup u' \cup u'',\psi)
             \land a = ((f\;v)_n, \setof{o})\right>$ \\
\oo Since $\unready{\theta \otimes R(\setof{i}, \phi_n)}{m}$, we know that \\
\oo $\unready{\theta \otimes R(\setof{i}, \phi_n) \otimes \sigma_n}{m}$ \\
\oo Hence $\theta \otimes R(\setof{i}, \phi_n) \otimes \sigma_n \vdash R(\setof{m}, \theta \otimes R(\setof{i}, \phi_n) \otimes \sigma_n)$ \\
\oo Hence $\theta \otimes R(\setof{i}, \phi_n) \otimes \sigma_n \vdash \theta \otimes R(\setof{i}, \phi_n) \otimes R(\setof{m}, \sigma_n)$ \\
\oo Since $i \not\in \domain{\sigma_n} \cup \setof{m}$, we know $R(\setof{i}, \sigma_n) = \sigma_n$ \\
\oo Hence $\theta \otimes R(\setof{i}, \phi_n) \otimes R(\setof{i}, \sigma_n) \vdash \theta \otimes R(\setof{i}, \phi_n) \otimes R(\setof{m}, \sigma_n)$ \\
\oo Hence $\theta \otimes R(\setof{i}, \phi_n \otimes \sigma_n) \vdash \theta \otimes R(\setof{i}, \phi_n) \otimes R(\setof{m}, \sigma_n)$ \\
\oo Hence we can conclude that \\
\ox $\left<G(\theta \otimes R(\setof{i}, \phi_n \otimes \sigma_n) \otimes R(\setof{m}, \sigma_n) \otimes \psi)\right>$ \\
\ox $\readcell o$ \\
\ox $\left<a.\;G(\theta' \otimes \phi_{n+1} \otimes \sigma_{n+1} \otimes R(u \cup u' \cup u'',\psi)
             \land a = ((f\;v)_n, \setof{o})\right>$ \\
\oo Note that $u' \cup u'' \subseteq \domain{\phi_n \otimes \sigma_n}$, which is the existential witness
\end{tabbedproof}
\end{proof}

\subsubsection{Correctness of $\mathsf{par}$}

\begin{lemma}{(The $\mathsf{par}$ network)}
If it is the case that $\mathit{Transduce}(v, i, \phi, b, f\;v)$ holds, and that
$\mathit{Transduce}(v, i, \sigma, c, g\;v)$ holds, then it is the case that
$\mathit{Transduce}(v, i, \phi \otimes \sigma \otimes \omega, o, \mathit{par}\;f\;g\;v)$ holds,
where 

\begin{itemize}
\item $\omega = \semfun{n}{\cellpos{o}{e}{ws_n}{\setof{b,c}}}$, where $ws = x \cdot (\mathit{par}\;f\;g\;v)$ for some dummy $x$ and
\item $e = \bind (\readcell b)\; (\semfun{x}{\bind (\readcell c)\; (\semfun{y}{\return (x,y)})})$
\end{itemize}
\end{lemma}

\begin{proof}
\begin{itemize}
\item We want to show that $\unready{\theta}{i}$ implies $\unready{\theta \otimes \phi_n \otimes \sigma_n \otimes \omega_n}{o}$ 

  Assume that $\unready{\theta}{i}$ holds. Then we know by hypothesis
  that $\unready{\theta \otimes \phi_n}{b}$ holds. This lets us conclude
  that $\unready{\theta \otimes \phi_n \otimes \omega_n}{o}$ holds. From this,
  it follows that $\unready{\theta \otimes  \phi_n \otimes \sigma_n \otimes \omega_n}{o}$.

\item We want to show that $\ready{\theta}{i}{v_n}$ implies $\ready{\theta \otimes \phi_{n+1} \otimes \sigma_{n+1} \otimes \omega_{n+1}}{o}{(\mathit{par}\;f\;g\;v)_n}$ 

  Assume that $\ready{\theta}{i}{v_n}$ holds. Then we know that 
  $\ready{\theta \otimes \phi_{n+1}}{b}{(f\;v)_n}$ holds, and that 
  $\ready{\theta \otimes \sigma_{n+1}}{c}{(g\;v)_n}$ holds. 

  So we know that $\ready{\theta \otimes \phi_{n+1} \otimes \sigma_{n+1} \otimes \omega_{n+1}}{b}{(f\;v)_n}$ holds.

  So we know that $\ready{\theta \otimes \phi_{n+1} \otimes \sigma_{n+1} \otimes \omega_{n+1}}{c}{(g\;v)_n}$ holds.

  Hence $\ready{\theta \otimes \phi_{n+1} \otimes \sigma_{n+1} \otimes \omega_{n+1}}{o}{(\mathit{par}\;f\;g\;v)_n}$ holds.

\item We want to show that $\closed{\phi_n \otimes \sigma_n \otimes \omega_n}{\domain{\phi_n \otimes \sigma_n \otimes \omega_n} \cup \setof{i}}$ 

  We know $\closed{\phi_n}{\domain{\phi_n} \cup \setof{i}}$. 
  We know $\closed{\sigma_n}{\domain{\sigma_n} \cup \setof{i}}$. 
  We know $\closed{\omega_n}{\domain{\omega_n} \cup \setof{b,c}}$. 

  So $\closed{\phi_n \otimes \sigma_n \otimes \omega_n}{\domain{\phi_n \otimes \sigma_n \otimes \omega_n} \cup \setof{i, b, c}}$ .

  But $b \in \domain{\phi_n}$ and $c \in \domain{\sigma_n}$, so 
   $\closed{\phi_n \otimes \sigma_n \otimes \omega_n}{\domain{\phi_n \otimes \sigma_n \otimes \omega_n} \cup \setof{i}}$. 

\item We want to show that $\unready{R(\setof{i}, \phi_n \otimes \sigma_n \otimes \omega_n)}{o}$ 

  We know by hypothesis that $\unready{R(\setof{i}, \phi_n)}{b}$
  holds. This lets us conclude that $\unready{R(\setof{i}, \phi_n
    \otimes \omega_n)}{o}$ holds. From this, it follows that
  $\unready{R(\setof{i}, \phi_n \otimes \sigma_n \otimes
    \omega_n)}{o}$.

\item We want to show that $o \in \domain{\omega_n}$. This is immediate. 
\end{itemize}

\noindent Now we will show the implication over triples holds.

\begin{tabbedproof}
\oo Assume we have $\theta, \theta', n$, and $u$. \\
\oo Assume that either $\ready{\theta}{i}{v_n}$ and $\theta = \theta'$ and $u = \emptyset$,  \\
\oo or $\unready{\theta}{i} \land i \in u$ \\
\oo Assume that $\closed{\theta'}{\domain{\theta'}}$ \\
\oo Assume that $\ready{\theta'}{i}{v_n}$ and $\closed{\theta'}{\domain{\theta'}}$ \\
\oo Assume for all $\psi$, we have \\
\ox  $\mspec{G(\theta \otimes \psi)}{\readcell i}{a}{a = ((f\;v)_n, \setof{c}) 
      \land G(\theta' \otimes R(u,\psi)) }$ \\
\oo Since $\mathit{Transduce}(v, i, \phi, b, f\;v)$, we can conclude that \\
\oo there is a $u'$ such that $\setof{b} \subseteq u' \subseteq \domain{\phi_n}$, \\
\oo $\forall \psi.\;\mspec{G(\theta \otimes R(\setof{i},\phi_n) \otimes \psi)}{\readcell b}{a}{a = ((f\;v)_n, \setof{b}) \land G(\theta' \otimes \phi_{n+1} \otimes R(u \cup u', \psi))}$ \\
\oo Now, note that $\ready{\theta'}{i}{v_n}$, so by rule \textsc{AReady} we can conclude that \\
\oo $\forall \psi.\;\mspec{G(\theta' \otimes \psi)}{\readcell i}{a}{a = (v_n, \setof{i}) \land G(\theta' \otimes \psi)}$ \\
\oo So from $\mathit{Transduce}(v, i, \sigma, c, f\;v)$, we can conclude that\\
\oo there is a $u''$ such that $\setof{c} \subseteq u'' \subseteq \domain{\sigma_n}$ and \\
\oo $\forall \psi.\;\mspec{G(\theta' \otimes R(\setof{i},\sigma_n) \otimes \psi)}{\readcell c}{a}{a = ((g\;v)_n, \setof{c}) \land G(\theta' \otimes \phi_{n+1} \otimes R(u'', \psi))}$ \\
\oo Now let $u''' = u' \cup u'' \cup \setof{o}$ \\
\oo So we want to show that \\
\oo $\forall \psi.\;$\=$\left<G(\theta \otimes R(\setof{i},\phi_n \otimes \sigma_n \otimes \omega_n) \otimes \psi)\right>$ \\
\oo \> ${\readcell c}$ \\
\oo \> $\left<{a.\;a = ((\mathit{par}\;f\;g\;v)_n, \setof{c}) \land G(\theta' \otimes \phi_{n+1} \otimes \sigma_{n+1} \otimes \omega_{n+1} \otimes R(u'', \psi))}\right>$ \\
\oo Since $c$ is unready in the precondition, we need to use the \textsc{AUnready} rule. \\
\oo So consider the expression $e$, in a state \\
\oo $G(\theta \otimes R(\setof{i},\phi_n \otimes \sigma_n) \otimes \psi)$ \\
\oo Now, to use the \textsc{ABind} rule, consider  $\readcell b$. By hypothesis, we end up in a state \\
\oo $G(\theta' \otimes \phi_{n+1} \otimes R(u' \cup \setof{i},\sigma_n) \otimes R(u', \psi)) \land (x,r_1) = ((f\;v)_n, \setof{b})$ \\
\oo Since $\phi$ and $\sigma$ have disjoint domains, this implies (pulling out $(x,r_1) = ((f\;v)_n, \setof{b})$) \\
\oo Also, since $i \in u'$, \\
\oo $G(\theta' \otimes \phi_{n+1} \otimes R(\setof{i},\sigma_n) \otimes R(u', \psi))$ \\
\oo Now, using the \textsc{ABind} rule again, consider $\readcell c$. By hypothesis, we end up in a state \\
\oo $G(\theta' \otimes R(u'',\phi_{n+1}) \otimes \sigma_{n+1} \otimes R(u' \cup u'', \psi)) \land (y,r_2) = ((g\;v)_n, \setof{b, c})$ \\
\oo Since $\phi$ and $\sigma$ have disjoint domains, this implies (pulling out $(y,r_2) = ((g\;v)_n, \setof{b, c})$) \\
\oo $G(\theta' \otimes \phi_{n+1} \otimes \sigma_{n+1} \otimes R(u' \cup u'', \psi)) \land (y, r_2) = ((g\;v)_n, \setof{b,c})$ \\
\oo Now, by the \textsc{AReturn} rule and the definition of $\mathit{par}$, we get \\
\oo $G(\theta' \otimes \phi_{n+1} \otimes \sigma_{n+1} \otimes R(u' \cup u'', \psi)) \land a = ((\mathit{par}\;f\;g\;v)_n, \setof{b,c})$ \\
\oo So the final state is \\
\oo $G(R(\setof{c}, \theta' \otimes \phi_{n+1} \otimes \sigma_{n+1}) \otimes \omega_{n+1} \otimes R(\setof{c} \cup u' \cup u'', \psi)) \land a = ((\mathit{par}\;f\;g\;v)_n, \setof{c})$ \\
\oo Since $c$ is not in the domain of $\theta', \phi_{n+1},$ or $\sigma_{n+1}$, and these are all suitably closed\\
\oo $G(\theta' \otimes \phi_{n+1} \otimes \sigma_{n+1} \otimes \omega_{n+1} \otimes R(u''', \psi)) \land a = ((\mathit{par}\;f\;g\;v)_n, \setof{c})$ \\
\end{tabbedproof}
\end{proof}

\subsubsection{Correctness of $\mathsf{switch}$}

\begin{lemma}{(The $\mathsf{par}$ network)}
If it is the case that $\mathit{Transduce}(v, i, \phi, b,f\;v)$ holds, and that 
$\mathit{Transduce}(\mathit{drop}\;k\;v, i, \sigma, c, g\;v)$ holds,
then it is the case that $\mathit{Transduce}(v, i, \omega, o,
\mathit{switch}\;k\;f\;g\;v)$ holds, where

\begin{itemize}
\item $\omega = \semfun{n}{\left\{\begin{array}{ll}
                                    \localref{r}{n} \otimes \phi_n \otimes R(\setof{i}, \sigma_0) \otimes \delta_n 
                                    & \mbox{if } n < k \\
                                    \localref{r}{n} \otimes R(\setof{i}, \phi_k) \otimes \sigma_{n-k} \otimes \delta_n 
                                    & \mbox{otherwise} \\
                                   \end{array}\right.}$
\item $\delta_n = \left\{\begin{array}{ll}
                          \cellpos{o}{e}{(\mathit{switch}\;f\;g\;v)_n}{\setof{b}} & \mbox{if } n < k\\
                          \cellpos{o}{e}{(\mathit{switch}\;f\;g\;v)_n}{\setof{c}} & \mbox{otherwise} \\
                         \end{array}
                 \right.$
\item $e = \bind (\getref r)\; (\semfun{n}{\bind (\setref r\;(n+1))\; (\semfun{\unit}{\IfThenElse{n < k}{\readcell b}{\readcell c}})})$
           

\end{itemize}
\end{lemma}

\begin{proof}
\begin{itemize}
\item First, we need to show that $\unready{\theta}{i}$ implies $\unready{\theta \otimes \omega_n}{o}$. 

  \begin{tabbedproof}
    \oo To prove this, assume $\unready{\theta}{i}$ and consider whether $n < k$:\\
    \oo If $n < k$:\\
    \ooo Then $\omega_n = \localref{r}{n} \otimes \phi_n \otimes R(\setof{i}, \sigma_0) \otimes \delta_n$ \\
    \ooo So we know that $\unready{\theta \otimes \phi_n}{b}$ holds \\
    \ooo Since $\delta_n = \cellpos{o}{e}{(\mathit{switch}\;f\;g\;v)_n}{\setof{b}}$, we can see that \\
    \ooo $\unready{\theta \otimes \omega_n}{o}$ \\
    \oo If $n \geq k$: \\
    \ooo Then $\omega_n = \localref{r}{n} \otimes R(\setof{i}, \phi_k) \otimes \sigma_{n-k} \otimes \delta_n$ \\
    \ooo So we know that $\unready{\theta \otimes \sigma_{n-k}}{c}$ holds \\
    \ooo Since $\delta_n = \cellpos{o}{e}{(\mathit{switch}\;f\;g\;v)_n}{\setof{c}}$, we can see that \\
    \ooo $\unready{\theta \otimes \omega_n}{o}$ \\
  \end{tabbedproof}

\item We want to show that $\ready{\theta}{i}{v_n}$ implies $\ready{\theta \otimes \omega_{n+1}}{o}{(\mathit{par}\;f\;g\;v)_n}$. 

  \begin{tabbedproof}
    \oo To prove this, assume $\ready{\theta}{i}{v_n}$ and consider whether $n < k$:\\
    \oo If $n < k$:\\
    \ooo Then $\omega_n = \localref{r}{n} \otimes \phi_n \otimes R(\setof{i}, \sigma_0) \otimes \delta_n$ \\
    \ooo So we know that $\ready{\theta \otimes \phi_n}{b}{(f\;v)_n}$ holds \\
    \ooo Since $\delta_n = \cellpos{o}{e}{(\mathit{switch}\;f\;g\;v)_n}{\setof{b}}$, we can see that \\
    \ooo $\ready{\theta \otimes \omega_n}{o}{(\mathit{switch}\;f\;g\;v)_n}$ \\
    \oo If $n \geq k$: \\
    \ooo Then $\omega_n = \localref{r}{n} \otimes R(\setof{i}, \phi_k) \otimes \sigma_{n-k} \otimes \delta_n$ \\
    \ooo So we know that $\ready{\theta}{i}{(\mathit{drop}\;k\;v)_{n-k}}$ \\
    \ooo So we know that $\ready{\theta \otimes \sigma_{n-k}}{c}{(g\;v)_{n-k}}$ holds \\
    \ooo Since $\delta_n = \cellpos{o}{e}{(\mathit{switch}\;f\;g\;v)_n}{\setof{c}}$, we can see that \\
    \ooo $\ready{\theta \otimes \omega_n}{o}{(\mathit{switch}\;f\;g\;v)_n}$ \\
  \end{tabbedproof}

\item Now we want to show that $\closed{\omega_n}{\domain{\omega_n} \cup \setof{i}}$. 

  \begin{tabbedproof}
    \oo Suppose $n < k$:\\
    \ooo Then $\omega_n = \localref{r}{n} \otimes \phi_n \otimes R(\setof{i}, \sigma_0) \otimes \delta_n$ \\
    \ooo So $\closed{\phi_n}{\domain{\phi_n} \cup \setof{i}}$ and \\
    \ooox $\closed{\sigma_0}{\domain{\sigma_n} \cup \setof{i}}$ so $\closed{R(\setof{i}, \sigma_0)}{\domain{R(\setof{i}, \sigma_n)} \cup \setof{i}}$ and \\
    \ooox $\closed{\delta_n}{\setof{b}}$ \\
    \ooo Since $b \in \domain{\phi_n}$, it follows that $\closed{\omega_n}{\domain{\omega_n} \cup \setof{i}}$ \\
    \oo Suppose $n \geq k$:\\
    \ooo Then $\omega_n = \localref{r}{n} \otimes R(\setof{i}, \phi_k) \otimes \sigma_{n-k} \otimes \delta_n$ \\
    \ooo So $\closed{\sigma_{n-k}}{\domain{\sigma_{n-k} \cup \setof{i}}}$ and \\
    \ooox $\closed{\phi_k}{\domain{\phi_k} \cup \setof{i}}$ so $\closed{R(\setof{i}, \phi_k)}{\domain{R(\setof{i}, \phi_k)} \cup \setof{i}}$ and \\
    \ooox $\closed{\delta_n}{\setof{c}}$ \\
    \ooo Since $c \in \domain{\sigma_{n-k}}$, it follows that $\closed{\omega_n}{\domain{\omega_n} \cup \setof{i}}$  \end{tabbedproof}

\item Next, we want to show that $\unready{R(\setof{i}, \omega_n)}{o}$

  \begin{tabbedproof}
    \oo To prove this, consider whether $n < k$:\\
    \oo If $n < k$:\\
    \ooo Then $\omega_n = \localref{r}{n} \otimes \phi_n \otimes R(\setof{i}, \sigma_0) \otimes \delta_n$ \\
    \ooo So we know that $\unready{\theta \otimes \phi_n}{b}$ holds \\
    \ooo Since $\delta_n = \cellpos{o}{e}{(\mathit{switch}\;f\;g\;v)_n}{\setof{b}}$, we can see that \\
    \ooo $\unready{\theta \otimes \omega_n}{o}$ \\
    \oo If $n \geq k$: \\
    \ooo Then $\omega_n = \localref{r}{n} \otimes R(\setof{i}, \phi_k) \otimes \sigma_{n-k} \otimes \delta_n$ \\
    \ooo So we know that $\unready{\theta \otimes \sigma_{n-k}}{c}$ holds \\
    \ooo Since $\delta_n = \cellpos{o}{e}{(\mathit{switch}\;f\;g\;v)_n}{\setof{c}}$, we can see that \\
    \ooo $\unready{\theta \otimes \omega_n}{o}$ \\
  \end{tabbedproof}


\item Next, we want to show that $o \in \domain{\omega_n}$, which is immediate. 
\end{itemize}

Now we will show the implication over triples. 
\begin{tabbedproof}
\oo Assume we have $\theta, \theta', n$, and $u$. \\
\oo Assume that either $\ready{\theta}{i}{v_n}$ and $\theta = \theta'$ and $u = \emptyset$,  \\
\oo or $\unready{\theta}{i} \land i \in u$ \\
\oo Assume that $\closed{\theta'}{\domain{\theta'}}$ \\
\oo Assume that $\ready{\theta'}{i}{v_n}$ and $\closed{\theta'}{\domain{\theta'}}$ \\
\oo Assume for all $\psi$, we have \\
\ox  $\mspec{G(\theta \otimes \psi)}{\readcell i}{a}{a = ((f\;v)_n, \setof{c}) 
      \land G(\theta' \otimes R(u,\psi)) }$ \\
\oo Now suppose $n < k$: \\
\ooo Now assume we have $\psi$ and note that  \\
\oooo since we know $\mathit{Transduce}(v, i, \phi, b, (f\;v)_n)$, we can conclude that \\
\oooo there is a $u'$ such that $\setof{b} \subseteq u' \subseteq \domain{\phi_n}$ such that \\
\oooo $\left<G(\theta \otimes \localref{r}{n+1} \otimes R(\setof{i}, \phi_n) \otimes R(\setof{i}, \sigma_0) \otimes \psi)\right>$ \\
\oooo $\readcell b$\\
\oooo $\left<a.\;G(\theta' \otimes \localref{r}{n+1} \otimes \phi_{n+1} \otimes R(u' \cup \setof{i}, \sigma_0) \otimes R(u', \psi))
      \land a = ((f\;v)_n, \setof{b})\right>$ \\
\ooo Choose a witness to the existential equal to $u' \cup \setof{o}$ and consider the prestate \\
\ooo $G(\theta \otimes R(\setof{i}, \omega_n) \otimes \psi)$ \\
\ooo We know $R(\setof{i}, \omega_n) = \theta \otimes \localref{r}{n} \otimes R(\setof{i}, \phi_n) \otimes R(\setof{i}, \sigma_0) \otimes \delta_n$ \\
\ooo Now, we know that $\unready{\theta \otimes \omega_n \otimes \psi}{o}$, since $\delta_n$'s read set \\
\ooo contains $b$, which is unready \\
\ooo So to evaluate $\readcell o$, we need to use the \textsc{AUnready} rule \\
\ooo So we need to evaluate $e$ in the state \\
\ooo $G(\theta \otimes \localref{r}{n} \otimes R(\setof{i}, \phi_n) \otimes R(\setof{i}, \sigma_0) \otimes \psi)$ \\
\ooo We begin with the \textsc{ABind} rule, which asks us to evaluate $\getref r$, which gives us \\
\ooo $G(\theta \otimes \localref{r}{n} \otimes R(\setof{i}, \phi_n) \otimes R(\setof{i}, \sigma_0) \otimes \psi) \land (n_1,r_1) = (n,\emptyset)$ \\
\ooo In this case, $e$ in $\delta_n$ simplifies to \\
\oooo $e = \bind (\getref r)\; (\semfun{n}{\bind (\setref r\;(n+1))\; (\semfun{\unit}{\readcell b})})$ \\
\ooo So now we need to evaluate $\bind (\setref r\;(n+1))\; (\semfun{\unit}{\readcell b})$ in \\
\ooo $G(\theta \otimes \localref{r}{n+1} \otimes R(\setof{i}, \phi_n) \otimes R(\setof{i}, \sigma_0) \otimes \psi)$ \\
\ooo Using the \textsc{ABind} rule, we need to evaluate $\setref r\;(n+1)$, which yields  \\
\ooo $G(\theta \otimes \localref{r}{n+1} \otimes R(\setof{i}, \phi_n) \otimes R(\setof{i}, \sigma_0) \otimes \psi)$ \\
\ooo with the need to consider $\readcell b$ \\
\ooo Using the triple we derived above, we get \\
\ooo $G(\theta' \otimes \localref{r}{n+1} \otimes \phi_{n+1} \otimes R(u' \cup \setof{i}, \sigma_0) \otimes R(u', \psi))
      \land a = ((f\;v)_n, \setof{b})$ \\
\ooo So then finishing the \textsc{AUnready} rule, we have a state \\
\ooo $G(R(\setof{o}, \theta' \otimes \localref{r}{n+1} \otimes \phi_{n+1} \otimes R(u' \cup \setof{i}, \sigma_0) \otimes R(u', \psi)) \otimes \delta_{n+1}) \land a = ((f\;v)_n, \setof{o})$\\
\ooo Simplifying using the closure properties, we get \\
\ooo $G(\theta' \otimes \localref{r}{n+1} \otimes \phi_{n+1} \otimes R(u' \cup \setof{i}, \sigma_0) \otimes \delta_{n+1} \otimes R(u' \cup \setof{o}, \psi))) \land a = ((f\;v)_n, \setof{o})$\\
\ooo which is \\
\ooo $G(\theta' \otimes \localref{r}{n+1} \otimes \phi_{n+1} \otimes R(u' \cup \setof{i}, \sigma_0) \otimes \delta_{n+1} \otimes R(u' \cup \setof{o}, \psi))) \land a = ((f\;v)_n, \setof{o})$\\
\ooo Since $(f\;v)_n = (\mathit{switch}\;k\;f\;g\;v)_n$, we have the conclusion \\
\oo Now suppose $n \geq k$: \\
\ooo Now assume we have $\psi$ and note that  \\
\oooo since we know $\mathit{Transduce}(\mathit{drop}\;k\;v, i, \sigma, c, (g\;(\mathit{drop}\;k\;v))_n)$, we can conclude that \\
\oooo there is a $u'$ such that $\setof{c} \subseteq u' \subseteq \domain{\sigma_{n-k}}$ such that \\
\oooo $\left<G(\theta \otimes \localref{r}{n+1} \otimes R(\setof{i}, \phi_k) \otimes R(\setof{i}, \sigma_{n-k}) \otimes \psi)\right>$ \\
\oooo $\readcell c$\\
\oooo $\left<a.\;G(\theta \otimes \localref{r}{n+1} \otimes R(\setof{i}, \phi_k) \otimes \sigma_{n-k+1} \otimes R(u', \psi))
      \land a = ((g\;(\mathit{drop}\;k\;v))_{n-k}, \setof{b})\right>$ \\
\ooo making use of the observation that $(\mathit{drop}\;k\;v)_{n-k} = v_n$ \\
\ooo Choose a witness to the existential equal to $u' \cup \setof{o}$ and consider the prestate \\
\ooo $G(\theta \otimes R(\setof{i}, \omega_n) \otimes \psi)$ \\
\ooo We know $R(\setof{i}, \omega_n) = \theta \otimes \localref{r}{n} \otimes R(\setof{i}, \phi_k) \otimes R(\setof{i}, \sigma_{n-k}) \otimes \delta_n$ \\
\ooo Now, we know that $\unready{\theta \otimes \omega_n \otimes \psi}{o}$, since $\delta_n$'s read set \\
\ooo contains $c$, which is unready \\
\ooo So to evaluate $\readcell o$, we need to use the \textsc{AUnready} rule \\
\ooo So we need to evaluate $e$ in the state \\
\ooo $G(\theta \otimes \localref{r}{n} \otimes R(\setof{i}, \phi_k) \otimes R(\setof{i}, \sigma_{n-k}) \otimes \psi)$ \\
\ooo We begin with the \textsc{ABind} rule, which asks us to evaluate $\getref r$, which gives us \\
\ooo $G(\theta \otimes \localref{r}{n} \otimes R(\setof{i}, \phi_k) \otimes R(\setof{i}, \sigma_{n-k}) \otimes \psi) \land (n_1,r_1) = (n,\emptyset)$ \\
\ooo In this case, $e$ in $\delta_n$ simplifies to \\
\oooo $e = \bind (\getref r)\; (\semfun{n}{\bind (\setref r\;(n+1))\; (\semfun{\unit}{\readcell c})})$ \\
\ooo So now we need to evaluate $\bind (\setref r\;(n+1))\; (\semfun{\unit}{\readcell c})$ in \\
\ooo $G(\theta \otimes \localref{r}{n+1} \otimes R(\setof{i}, \phi_k) \otimes R(\setof{i}, \sigma_{n-k}) \otimes \psi)$ \\
\ooo Using the \textsc{ABind} rule, we need to evaluate $\setref r\;(n+1)$, which yields  \\
\ooo $G(\theta \otimes \localref{r}{n+1} \otimes R(\setof{i}, \phi_k) \otimes R(\setof{i}, \sigma_{n-k}) \otimes \psi)$ \\
\ooo with the need to consider $\readcell c$ \\
\ooo Using the triple we derived above, we get \\
\ooo $G(\theta' \otimes \localref{r}{n+1} \otimes R(\setof{i}, \phi_k) \otimes \sigma_{n-k+1} \otimes R(u', \psi))
      \land a = ((g\;(\mathit{drop}\;k\;v))_{n-k}, \setof{c})$ \\
\ooo Here, we have used the fact that $\phi_k$ is closed with respect to $u'$ to simplify the state\\
\ooo Hiding the equality, and then finishing the \textsc{AUnready} rule, we have a state \\
\ooo $G(R(\setof{o}, \theta' \otimes \localref{r}{n+1} \otimes R(\setof{i}, \phi_k) \otimes R(u' \cup \setof{i}, \sigma_0) \otimes R(u', \psi)) \otimes \delta_{n+1})$\\
\ooo Simplifying using the closure properties, we get \\
\ooo $G(\theta' \otimes \localref{r}{n+1} \otimes R(\setof{i}, \phi_k) \otimes R(u' \cup \setof{i}, \sigma_0) \otimes \delta_{n+1} \otimes R(u' \cup \setof{o}, \psi))$\\
\ooo which is \\
\ooo $G(\theta' \otimes \localref{r}{n+1} \otimes R(\setof{i}, \phi_k) \otimes R(u' \cup \setof{i}, \sigma_0) \otimes \delta_{n+1} \otimes R(u' \cup \setof{o}, \psi)))$\\
\ooo Note that $(\mathit{switch}\;k\;f\;g\;v)_n = (g\;(\mathit{drop}\;k\;v))_{n-k}$, so restoring the equality \\
\oox we get our goal
\end{tabbedproof}
\end{proof}

\subsubsection{Correctness of $\mathsf{loop}$}

\begin{lemma}
  Suppose that for all $xys$, we have $\mathit{Transduce}(xys, s,
  \phi, t, f\;xys)$. Then it is the case that for all $ys$ and $x$ we
  have $\mathit{Transduce}(ys, i, \sigma, o, \mathit{loop}\;x\;f\;ys)$, where

  \begin{itemize}
  \item $\sigma_n = \localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n} \otimes
                      \iota_n \otimes \phi_n \otimes \delta_n$ 
  \item $\iota_n = \cellpos{s}{e_1}{ws_n}{\setof{i}}$ where $ws_{n+1} = ((x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n, ys_n)$ and $ws_0$ is some dummy value\\
  \item $e_1 = \bind (\readcell i)\; \semfun{y}{\bind (\getref r)\; \semfun{x}{\return (x,y)}}$ \\
  \item $\delta_n = \cellpos{o}{e_2}{(z\cdot (\mathit{loop}\;x\;f\;ys))_n}{\setof{t}}$ for some dummy $z$ \\ 
  \item $e_2 = \bind (\readcell t)\; (\semfun{(x,z)}{
               \bind (\setref r\;x)\; (\semfun{\unit}{\return z}}))$ \\
  \end{itemize}
\end{lemma}

\begin{proof}
  \begin{itemize}
  \item First, we want to prove that if $\unready{\theta}{i}$ then $\unready{\theta \otimes \sigma_n}{o}$ 

    \begin{tabbedproof}
      \oo Assume $\unready{\theta}{i}$ \\
      \oo Hence $\unready{\theta \otimes \iota_n}{s}$ \\
      \oo Hence $\unready{\theta \otimes \iota_n \otimes \phi_n}{t}$ \\
      \oo Hence $\unready{\theta \otimes \iota_n \otimes \phi_n \otimes \delta_n}{o}$ \\
    \end{tabbedproof}

  \item Now, we want to show that if $\ready{\theta}{i}{ys_n}$, then $\ready{\theta \otimes \sigma_{n+1}}{o}{(\mathit{loop}\;x\;f\;ys)_n}$ 
    \begin{tabbedproof}
      \oo Assume $\ready{\theta}{i}{ys_n}$ \\
      \oo Hence $\ready{\theta \otimes \iota_n}{s}{((\mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n, ys_n)}$ \\
      \oo Hence $\ready{\theta \otimes \iota_n \otimes \phi_n}{t}{(f\;(\mathit{zip}\;(\mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))\;ys))_n}$ \\
      \oo Hence $\ready{\theta \otimes \iota_n \otimes \phi_n \otimes \delta_n}{o}{(\mathit{loop}\;x\;f\;ys)_n}$ \\
    \end{tabbedproof}

  \item Now, we want to show that $\closed{\sigma_n}{\domain{\sigma_n} \cup \setof{i}}$ 

    \begin{tabbedproof}
      \oo First, observe that $\closed{\iota_n}{\setof{i} \cup \domain{\iota_n}}$\\
      \oo Next, by hypothesis $\closed{\phi_n}{\domain{\phi_n} \cup \setof{s}}$ \\
      \oo Note that $s \in \domain{\iota_n}$ \\
      \oo Next, note that $\closed{\delta_n}{\setof{t} \cup \domain{\delta_n}}$ \\
      \oo Note that $t \in \domain{\phi_n}$ \\
      \oo Hence $\closed{\sigma_n}{\setof{i} \cup \domain{\sigma_n}}$
    \end{tabbedproof}
  \item Next, we want to show that $o \in \domain{\sigma_n}$. This is obvious, since $\delta_n$ is part 
    of $\sigma_n$. 
  \item Next, we want to show that $\unready{R(\setof{i}, \sigma_n)}{o}$
    
    \begin{tabbedproof}
      \oo $R(\setof{i}, \iota_n) = \cellneg{s}{e_1}$, so $\unready{R(\setof{i}, \iota_n)}{s}$ \\
      \oo Hence by hypothesis, we know $\unready{R(\setof{i}, \iota_n) \otimes R(\setof{i}, \phi_n)}{t}$ \\
      \oo So we know that $\unready{R(\setof{i}, \iota_n) \otimes R(\setof{i}, \phi_n) \otimes \delta_n}{o}$ \\
      \oo But $R(\setof{i}, \delta_n) = \delta_n$ \\
      \oo Furthermore, $R(\setof{i}, \localref{r}{\ldots}) = \localref{r}{\ldots}$ \\
      \oo Hence $\unready{R(\setof{i}, \sigma_n)}{o}$ 
    \end{tabbedproof}

  \end{itemize}

Now, we'll prove the entailment of implications. 
\begin{tabbedproof}
\oo Assume we have $\theta, \theta', n$, and $u$. \\
\oo Assume that either $\ready{\theta}{i}{y_n}$ and $\theta = \theta'$ and $u = \emptyset$,  \\
\oo or $\unready{\theta}{i} \land i \in u$ \\
\oo Assume that $\closed{\theta'}{\domain{\theta'}}$ \\
\oo Assume that $\ready{\theta'}{i}{y_n}$ and $\closed{\theta'}{\domain{\theta'}}$ \\
\oo Assume for all $\psi$, we have \\
\ox  $\mspec{G(\theta \otimes \psi)}{\readcell i}{a}{a = ((f\;v)_n, \setof{c}) 
      \land G(\theta' \otimes R(u,\psi)) }$ \\
\oo Now, we'll consider the effect of reading $s$ \\
\ooo We know that $\unready{\theta \otimes \localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n} \otimes R(i, \iota_n)}{s}$ \\
\ooo Using the \textsc{AUnready} rule, we can derive the following triple: \\
\ooo $\left<G(\theta \otimes \localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n} \otimes R(\setof{i}, \iota_n) \psi)\right>$ \\
\ooo $\readcell s$ \\
\ooo $\left<a.\; G(\theta' \otimes \localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n} \otimes \iota_{n+1} \otimes R(u \cup {s},\psi))\right.$ \\
\ooo $\left.\;\;\land\;a = ((\pi_1(\mathit{cycle}\;x\;f\;ys)_n, y_n), \setof{s}) \right>$ \\
\ooo using the fact that $s \not\in \domain{\theta}$ and its closure \\
\oo Furthermore, it's clear that $u \cup \setof{s} \subseteq \domain{\theta \otimes \localref{r}{\ldots} \otimes R(\setof{i}, \iota_n)}$\\
\oo and that $\unready{\theta \otimes \localref{r}{\ldots} \otimes R(\setof{i}, \iota_n)}{s}$ \\
\oo and that $s \in \domain{\theta \otimes \localref{r}{\ldots} \otimes R(\setof{i}, \iota_n)}$\\
\oo So we can then use $\mathit{Transduce}(xys, s, \phi, t, f\;xys)$ to conclude that for all $\psi$\\
\ooo $\left<G(\theta \otimes \localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n} \otimes R(\setof{i}, \iota_n \otimes \phi_n) \otimes \psi)\right>$\\
\ooo $\readcell t$ \\
\ooo $\left<G(\theta \otimes \localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n} \otimes \iota_{n+1} \otimes \phi_{n+1} \otimes R(u \cup \setof{s} \cup u', \psi))\right.$\\
\ooo $\;\;\land\;\left.a = ((f\;(\mathit{zip}\;(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))\;y))_n, \setof{t})\right>$\\
\ooo By the loop unrolling lemma, this postcondition is equivalent to  \\
\ooo $\left<G(\theta \otimes \iota_{n+1} \otimes \phi_{n+1} \otimes R(u \cup \setof{s} \cup u', \psi))
            \land a = ((\mathit{cycle}\;x\;f\;ys)_n, \setof{t})\right>$\\
\oo Take the witness to be $u' \cup \setof{s, t}$ \\
\oo Now, assume we have $\psi$, and a prestate \\
\oo $G(\localref{r}{\pi_1(\mathit{cycle}\;x\;f\;ys)_n} \otimes R(\setof{i}, \iota_n \otimes \phi_n \otimes \delta_n) \otimes \psi)$ \\
\oo Since $\unready{\localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n} \otimes \theta \otimes R(\setof{i}, \iota_n)}{s}$, we have \\
\oox $\unready{\localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n} \otimes \theta \otimes R(\setof{i}, \iota_n \otimes \phi_n)}{t}$, so we have \\
\oox $\unready{\localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n} \otimes \theta \otimes R(\setof{i}, \iota_n \otimes \phi_n \otimes \delta_n)}{o}$, so we have \\
\oox $\unready{\localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n} \otimes \theta \otimes R(\setof{i}, \iota_n \otimes \phi_n \otimes \delta_n) \otimes \psi}{o}$ \\
\oo So to read $o$, we should use the \textsc{AUnready} rule. So we want to evaluate $e_2$ in a state\\
\oo $G(\localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n} \otimes R(\setof{i}, \iota_n \otimes \phi_n) \otimes \psi)$\\
\oo Now by \textsc{ABind} we need to consider $\readcell t$, and from our derivation above \\
\oo $G(\localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n} \otimes \iota_{n+1} \otimes \phi_{n+1} \otimes R(u \cup u' \cup \setof{s}, \psi))$\\
\oo and furthermore the return value is $((\mathit{loop}\;x\;f\;ys)_n, \setof{t})$ \\
\oo Calling $(x, z) = (\mathit{cycle}\;x\;f\;ys)_n$, we need to consider $\bind (\setref r\;x)\; (\semfun{\unit}{\return z})$ \\
\oo Using the \textsc{ABind} rule and first the \textsc{ASetRef} rule, we see that \\
\oo $G(\localref{r}{\pi_1\;(\mathit{cycle}\;x\;f\;ys)_n} \otimes \iota_{n+1} \otimes \phi_{n+1} \otimes R(u \cup u' \cup \setof{s}, \psi))$\\
\oo By equational reasoning, this is equivalent to \\
\oo $G(\localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_{n+1}} \otimes \iota_{n+1} \otimes \phi_{n+1} \otimes R(u \cup u' \cup \setof{s}, \psi))$\\
\oo Finishing with $\return z$, we get the poststate: \\
\oo $G(R(\setof{t}, \localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_{n+1}} \otimes \iota_{n+1} \otimes \phi_{n+1} \otimes R(u \cup u' \cup \setof{s}, \psi)) \otimes \delta_{n+1})$\\
\oox $\land\; a = (z, \setof{t})$\\
\oo Note $z = \pi_2\;(\mathit{cycle}\;x\;f\;ys)_n = (\mathit{map}\;\pi_2\;(\mathit{cycle}\;x\;f\;ys))_n = (\mathit{loop}\;x\;f\;ys)_n$ \\
\oo Furthermore, the poststate simplifies to \\
\oo $G(\localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_{n+1}} \otimes \iota_{n+1} \otimes \phi_{n+1} \otimes R(u \cup u' \cup \setof{s,t}, \psi)) \otimes \delta_{n+1})$ \\
\oox $\land\; a = (z, \setof{t})$\\
\oo using the closure properties of $\phi, \theta, \delta,$ and $\iota$, which is what we want.
\end{tabbedproof}
\end{proof}

\subsubsection{Correctness of Realizability}

\begin{prop*}{(FRP Correctness)}
Then, the following specifications are provable: 
\begin{enumerate}
\item $\forall f:A\to B.\; \mathit{Realize}(\liftop f, \mathit{lift}\;f)$
\item $\forall p, f, q, g.\;\mathit{Realize}(p, f) \specand \mathit{Realize}(q, g) \specimp \mathit{Realize}(\composeop p\;q, \mathit{compose}\;f\;g)$
\item $\forall p, f, q, g.\;\mathit{Realize}(p, f) \specand \mathit{Realize}(q, g)
                       \specimp \mathit{Realize}(\parop p\;q, par\;f\;g)$
\item $\forall k, p, f, q, g.\;\mathit{Realize}(p, f) \specand \mathit{Realize}(q, g)
                          \specimp \mathit{Realize}(\switchop k\;p\;q, switch\;k\;f\;g)$
\item $\forall a_0, p, f.\; \mathit{Realize}(p, f) \specimp \mathit{Realize}(\loopop\;a_0\;p, loop\;a_0\;f)$
\end{enumerate}
\end{prop*}

\begin{proof}
  Since each of these combinators are straight line code, the
  correctness proof consists of nothing but building the dataflow
  graph and observing that the resulting graph matches the state
  posited in the transduction lemmas we just proved.

  The only even marginally interesting part of these proofs comes in
  the use of the rule of consequence to take newly-created cells (whose
  predicates are of the form $\cellneg{c}{e}$), and turn them into
  $\cellpos{c}{e}{\mathit{dummy}}{rs}$.
\end{proof}

\section{Future Work}

Now that we have introduced the idea of ramifications and seen two
different applications for them we see many possible further uses.  It
would be interesting to investigate the relationship between
ramification operators and methods based on
rely-guarantee~\cite{rely-guarantee-jones}. Rely-guarantee works by
imposing a mutual contract between a piece of code and the rest of the
world, which is at least conceptually similar to the idea of a
ramification, though we see no obvious direct relationship.

Third, so far we have presented ramifications as a style of
specification useful for verifying a particular library.  Might it be
sensible or useful to bake ramification operators into the basic
logical framework?  If so, what are their logical properties --- $R(u,
\phi)$ looks like a family of modal operators on the formula $\phi$.
However, our first two examples exhibited a number of different
auxiliary interaction lemmas, which is what made them truly useful, 
and the common features are still unclear. 

\section{Related Work}

Prior work on verifying callbacks using separation logic includes both
\citet{tldi09,ftfjp07} work as well as by
\citet{parkinson-iwaco-07}. The approach in these papers was similar;
each subject predicate was equipped with a list of observers, rather
than maintaining them implicitly in the invariant. These approaches
were not modular, because the observers had to be explicitly
named. Worse still, this approach broke down when faced with chains of
subjects and observers, because separation logic is a resource-based
logic, and the existence of multiple paths to an object meant that
ownership of observer state became ambiguous.

\citet{shaner-leavens-naumann} studied using gray-box model programs
to model higher-order method calls (which can be understood as a a
variant of refinement calculus-based methods) in JML, and
\citet{history-invariants} have applied Liskov and Wing's idea of
history invariants~\cite{liskov-wing} to model observers. As before,
both of these methods are also non-modular, since they require knowing
what all of the observers are, and furthermore both of these methods
sharply restrict the kinds of invariants that can be used, making it
very difficult to model the code-update-based protocol seen in our FRP
example.

\citet{self-adjusting} have proposed
\emph{self-adjusting computation} as a technique for using change
propagation to write programs that incrementally
recompute answers as the inputs are adjusted. It would be worth 
studying if our techniques could help verifying implementations of this
idea.

Functional reactive programming (FRP) was proposed by \citet{frp} as a
declarative formalism for interactive programming. The API in our
paper differs from theirs in two ways. First, our interface is a
variation of the \emph{arrowized FRP} interface proposed in
\cite{afrp}, and secondly, we use a discrete model of time, rather
than a continuous model of time --- though we found the core idea of
using a declarative semantics as a specification for the interface an
inspiring one.

Furthermore, our work could also serve as a bridge between the work on
purely functional reactive programming, and more imperative
implementations, such as the work done by \citet{superglue} on
SuperGlue and by \citet{frtime} on the FrTime system.


\section{Appendix: The $\cellset$ Interface}

In this section, we'll describe the interface to the $\cellset$ type,
which is intended to be used to represent pure collections of
existentially quantified cells. Specifying this interface is not
entirely trivial, because of the way equality works for this
type. Ordinarily, we would simply give a two-place predicate $set(v,
\elts)$ relating a value $v$, and the mathematical set of elements
$\elts$ it represents.

However, this approach is not sufficient in our case. In order to
manage dependencies, we need to be able to test cells of
\emph{different} concrete type for equality, and the natural equality
for references only permits testing references of the same type. As a
result, we can't unpack an existentially-quantified cell and compare
the elements in its tuple, because we don't know that the two cells
are of the same type (and indeed, they might not be). 

To get around this problem, we generate a unique integer identifier
for each cell we create, and then compare those identifiers to
establish equality. Since these identifiers are all generated
dynamically along with the cells, this means that the precise partial
equivalence relation we need to use is determined dynamically as
well. So we add an additional index to the set predicate $set(W, v,
\elts)$. The extra parameter $W$ is the \emph{world}, the set of all
the cells allocated so far, which must collectively satisfy the
constraint that two elements of the world are equal if and only if their
identifier fields match.

All of the usual set operations exist. We have an $\ctext{emptyset}$,
representing an empty set of cells, as well as singleton
($\ctext{singleton}$) and union ($\ctext{union}$) operations.  We have
$\ctext{addset}\;v\;x$, which adds the element $x$ to the set $v$
represents, and $\ctext{removeset}\;v\;x$, which removes $x$ from the
set $v$ represents. We also have $\ctext{iterset}\;f\;v$, which
iterates over the elements of $v$'s set and applies $f$ to each
element in some sequential order. (Observe that the specification
makes use of two auxiliary predicates: $matches$, which assert that a
set and a list have the same elements; and $iterseq$, which constructs
a command representing the sequential execution of those elements.)

We have three axioms that our implementation must satisfy. First, if a
$\cellset$ value $v$ represents a set in a world $W$, it will also
represent a set in any larger world $W'$. Second, the values in a set
are always a subset of the world $W$. Finally, we require that
$set(W,v,\elts)$ is a pure predicate (i.e., is not heap-dependent),
which implies that it have a purely functional implementation (for
example, as a binary tree). 


\begin{tabbing}
$World = $ \\
\;\;\;\;\=$\{D \in \powersetfin{\ecell}\;|\;\forall (\pack{\alpha}{c_0} \; \mathrm{as}\; c),(\pack{\beta}{d_0} \;\mathrm{as}\; d) \in D.\;$\=$c_0.id = d_0.id \iff c = d\}$\\[1em]

$\exists \cellset : \star.$ \\
$\exists set : World \To \cellset \To \powersetfin{\ecell} \To \assert.$ \\
$\exists \ctext{emptyset}    : cellset.$ \\
$\exists \ctext{singleton}   : \ecell \to \cellset.$ \\
$\exists \ctext{union}      : \cellset \to \cellset \to \cellset.$ \\
$\exists \ctext{addset}      : \cellset \to \ecell \to \cellset.$ \\
$\exists \ctext{removeset}   : \cellset \to \ecell \to \cellset.$ \\
$\exists \ctext{iterset}     : (\ecell \to \monad{\unittype}) \to \cellset \to \unittype.$\\[1em]

$\forall W \in World.\; set(W, \ctext{emptyset}, \emptyset)$ \\[1em]

$\forall W \in World, c \in W.\; set(W, \ctext{singleton}\;c, \setof{c})$ \\[1em]

$\forall W \in World, c_1 : \cellset, \elts_1 \in \powersetfin{W}, c_2 : \cellset, \elts_2 \in \powersetfin{W}.$ \\
\;\;$set(W, c_1, \elts_1) \land set(W, c_2, \elts_2) \implies set(W, \ctext{union}\;c_1\;c_2, \elts_1 \cup \elts_2)$ \\[1em]


$\forall W \in World, v : \cellset, x : \ecell, \elts \in \powersetfin{\ecell}.$ \\ 
\> $set(W, v, \elts) \land x \in W \implies set(W, \ctext{addset}\;v\;x, \elts \cup \setof{x})$ \\[1em]


$\forall W \in World, v : \cellset, x : \ecell, \elts \in \powersetfin{\ecell}.$ \\ 
\> $set(W, v, \elts) \land x \in W \implies set(W, \ctext{removeset}\;v\;x, \elts - \setof{x})$ \\[1em]


$\forall W \in World, v : \cellset, \elts \in \powersetfin{\ecell}, 
         f : (\ecell \to \monad{\unittype}).$ \\ 
\> $set(W, v, \elts) \implies \exists L : \seqsort{\ecell}.\;$\=$matches\;\elts\;L\; \land \ctext{iterset}\;f\;v = iterseq\;f\;L$ \\[1em]


$\forall W, W' \in World, v, \elts.$ \\
\>$set(W,v,\elts) \land W \subseteq W' \implies set(W',v, \elts)$\\[1em]

$\forall W, W' \in World, v, \elts.$ \\
\>$set(W, v, \elts) \implies \elts \subseteq W$ \\[1em]

$\forall W, v, \elts.\; \mathrm{Pure}(set(W,v,\elts))$ \\[1em]
  

$matches\;\elts\;[] \qquad\;\;\; = \elts = \emptyset$ \\
$matches\;\elts\;(v :: vs) = v \in \elts \land matches\;(\elts - \setof{v})\;vs$\\[1em]

$iterseq\; f\; [] \qquad\;\;\;\;$\=$= \comp{\unit}$ \\
$iterseq\; f\; (v :: vs)$\>$= \comp{\letv{\unit}{f\;v}{\ctext{run}\;iterseq\;f\;vs}}$ \\
\end{tabbing}



