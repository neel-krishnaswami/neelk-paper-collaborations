\documentclass{article}
\usepackage{amsmath,amssymb}
\usepackage{mathpartir}
 
\newcommand{\fix}[2]{\mu {#1}.\;{#2}}
\newcommand{\lft}[1]{\left<{#1}\right.}
\newcommand{\rgt}[1]{\left.{#1}\right>}
\newcommand{\bnfalt}{\;\;|\;\;}
\newcommand{\Word}{\Sigma^{*}}
\newcommand{\ints}{\mathbb{Z}}
\newcommand{\nats}{\mathbb{N}}
\newcommand{\judgebalance}[3][\Gamma]{{#1} \vdash {#2} : {#3}}
\newcommand{\judgecat}[3]{{#1} \circ {#2} \equiv {#3}}
\newcommand{\judgesubst}[3]{{#1} \vdash {#2} : {#3}}
\newcommand{\combine}[2]{{#1} \oplus {#2}}
\newcommand{\true}{\mathsf{true}}
\newcommand{\false}{\mathsf{false}}
\newcommand{\zero}{(0,0)}
\newcommand{\powerset}[1]{\mathcal{P}({#1})}
\newcommand{\powersetfin}[1]{\mathcal{P}^{\mathrm{fin}}({#1})}
\newcommand{\interp}[1]{[\![{#1}]\!]}
\newcommand{\setof}[1]{\{{#1}\}}
\newcommand{\comprehend}[2]{\setof{{#1}\;|\;{#2}}}
\newcommand{\semderiv}[2]{D_{#1}({#2})}
\newcommand{\deriv}[2]{d_{#1}({#2})}
\newcommand{\call}[2]{C_{#1}({#2})}
\newcommand{\fun}[2]{\lambda {#1}.\;{#2}}
\newcommand{\IfThenElse}[3]{\mbox{if }{#1}\mbox{ then }{#2}\mbox{ else }{#3}}
\newcommand{\Let}[2]{\mbox{let }{#1} = {#2}}
\newcommand{\nullable}[1]{\mathit{null}(#1)}
\newcommand{\emptify}[1]{\delta({#1})}
\newcommand{\bump}[2]{\mathrm{bump}({#1}, {#2})}
\newcommand{\sgn}[1]{\mathrm{sgn}({#1})}
\newcommand{\guard}[2]{{#1}\rhd{#2}}
\newcommand{\pieces}[1]{P({#1})}
\newcommand{\depth}[1]{|{#1}|}

\newtheorem{prop}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}



\newenvironment{proof}{\noindent\textbf{Proof.}}{\noindent\textbf{End Proof.}}


\newenvironment{caseblock}{\begin{itemize}}{\end{itemize}}
\newenvironment{case}[1]{\item \textbf{Case} {#1}\\}{}


\author{Neel Krishnaswami}
\title{Partial Parsing with Nested Words}

\begin{document}
\maketitle

\section{Bracketed Grammars}

\subsection{Notational Conventions}

Intuitively, a bracketed grammar is a grammar in which all recursive calls to
grammatical productions are wrapped in explicit open-close symbols.

So we will fix three disjoint sets $\Sigma_i, \Sigma_l,$ and $\Sigma_r$ to use
as an alphabet in what follows. The set $\Sigma_i$ is the set of basic
characters, whose elements we will denote with $a, b, c$.  The set $\Sigma_l$
is the set of the left brackets, whose elements we will denote with $\lft{a},
\lft{b}, \lft{c}$. The set $\Sigma_r$ is the set of right brackets, whose
elements we will write $\rgt{a}, \rgt{b}, \rgt{c}$. We will write $\Sigma =
\Sigma_i \cup \Sigma_l \cup \Sigma_r$, and denote its elements with $\sigma$
and $\tau$.

Formally, we define \emph{grammar expressions} via the following
BNF:

\begin{displaymath}
\begin{array}{lcll}
g & ::= & \epsilon   & \mbox{Empty String} \\
  &  |  & a          & \mbox{Single character from $\Sigma_i$} \\
  &  |  & \lft{a}    & \mbox{Single character from $\Sigma_l$} \\
  &  |  & \rgt{a}    & \mbox{Single character from $\Sigma_r$} \\
  &  |  & g \cdot g' & \mbox{Concatenation} \\ 
  &  |  & g*         & \mbox{Kleene Closure} \\
  &  |  & \bot       & \mbox{Empty Language} \\
  &  |  & g \vee g'  & \mbox{Language Union} \\
  &  |  & \fix{x}{g} & \mbox{Fixed Point} \\
  &  |  & x          & \mbox{Recursive Call} \\
\end{array}
\end{displaymath}

Note that this is essentially the language of regular expressions, extended
with an operator to take the fixed point of a language. This is (thanks
to a variant of Bekic's lemma) essentially lets us define unrestricted
context-free grammars. 

To give this syntax a semantics, let's take the set of strings to be
the free monoid $\Word$ over the set of characters, writing $\epsilon$
and $s\cdot s'$ for the unit and join of the monoid. Now, since our
language has recursive calls, we'll need to interpret grammars as
fixed points of monotone operators.

\begin{mathpar}
\boxed{\interp{-} :  (\Gamma \to \powerset{\Word}) \to G \to \powerset{\Word}}

\\

\begin{array}{lcl}
\interp{\epsilon}\gamma    & = & \setof{\epsilon} \\
\interp{a}\gamma           & = & \setof{a} \\
\interp{\lft{b}}           & = & \setof{\lft{b}} \\
\interp{\rgt{c}}           & = & \setof{\rgt{c}} \\
\interp{g \cdot g'}\gamma  & = & \comprehend{\sigma\cdot\tau}
                                            {\sigma \in \interp{g}\gamma \mbox{ and } \tau \in \interp{g'}\gamma} \\
\interp{g*}\gamma          & = & \bigcup\limits_{n \in \nats} 
                                   \comprehend{s_1 \cdot \ldots \cdot s_n}
                                              {\forall i \in \setof{1 \ldots n}.\; s_i \in \interp{g}\gamma} \\
\interp{\bot}\gamma        & = & \emptyset \\
\interp{g \vee g'}\gamma   & = & \interp{g}\gamma \cup \interp{g'}\gamma \\
\interp{x}\gamma           & = & \gamma(x) \\
\interp{\fix{x}g}\gamma    & = & \mathit{fix}(\fun{L}{L \cup \interp{g}(\gamma, L)}) \\ 
\end{array}
\end{mathpar}

All of the cases of this definition are straightforward, with the
exception of the final case, the definition of the fixed point. In
this clause, we make use of the fact that the powerset of words forms
a complete lattice, and so by the Knaster-Tarski theorem, monotonic
functions on this lattice have least fixed points.

Since the set of languages is a Kleene algebra, we can write $g \simeq
g'$ to indicate that the two grammars have the same interpretation,
and then $(\cdot, \epsilon)$ has monoidal structure, and $(\bot,
\vee)$ has join-semilattice structure. Furthermore, from the definition
of fixed points we know that $\fix{x}{g} \simeq g[\fix{x}{g}/x]$. 

\begin{lemma}{(Soundness of Substitution)}
Suppose $g$ has free variables in $\Gamma, x$. 
Then for all  $g'$ with free variables in $\Gamma$ and $\gamma$ mapping variables
to languages, we have that $\interp{g}(\gamma, \interp{g'}\gamma) = \interp{g[g'/x]}\gamma$. 
\end{lemma}

\begin{proof}
  This proof is by induction on $g$. 

  \begin{caseblock}
    \begin{case}{$g \in \setof{\epsilon, \bot, \sigma}$}
      Immediate, since none of these cases have any free variables. 
    \end{case}

    \begin{case}{$g = g_1 \cdot g_2$}
      By induction, we know that $\interp{g_1}(\gamma, \interp{g'}\gamma) = \interp{g_1[g'/x]}\gamma$.

      By induction, we know that $\interp{g_2}(\gamma, \interp{g'}\gamma) = \interp{g_2[g'/x]}\gamma$.

      Hence $\interp{g_1}(\gamma, \interp{g'}\gamma) \cup \interp{g_2}(\gamma, \interp{g'}\gamma) = \interp{g_1[g'/x]}\gamma \cup \interp{g_2[g'/x]}\gamma$.

      Hence $\interp{g_1 \vee g_2}(\gamma, \interp{g'}\gamma) = \interp{g_1[g'/x] \vee g_2[g'/x]}\gamma$.

      Hence $\interp{g_1 \vee g_2}(\gamma, \interp{g'}\gamma) = \interp{(g_1 \vee g_2)[g'/x]}\gamma$.
    \end{case}

    \begin{case}{$g = g_1\cdot g_2$}
      By induction, we know that $\interp{g_1}(\gamma, \interp{g'}\gamma) = \interp{g_1[g'/x]}\gamma$.

      By induction, we know that $\interp{g_2}(\gamma, \interp{g'}\gamma) = \interp{g_2[g'/x]}\gamma$.

      Hence $\comprehend{\sigma\cdot\tau}{\sigma\in\interp{g_1}(\gamma, \interp{g'}\gamma \land \tau\in\interp{g_2}(\gamma, \interp{g'}\gamma}$ equals \\
      \noindent $\comprehend{\sigma\cdot\tau}{\sigma\in\interp{g_1[g'/x]}\gamma \land \tau\in\interp{g_2[g'/x]}\gamma}$.

      Hence $\interp{g_1\cdot g_2}(\gamma, \interp{g'}\gamma) = \interp{g_1[g'/x]\cdot g_2[g'/x]}\gamma$. 

      Hence $\interp{g_1\cdot g_2}(\gamma, \interp{g'}\gamma) = \interp{(g_1\cdot g_2)[g'/x]}\gamma$. 
    \end{case}

    \begin{case}{$g = g_0*$}
      By induction we know that $\interp{g_0}{\gamma, \interp{g'}\gamma} = \interp{g_0[g'/x]}\gamma$. 

      Hence $\bigcup\limits{n \in \nats} \comprehend{s_1\cdot\ldots s_n}{\forall i \in \setof{1\ldots n}.\; s_i \in \interp{g_0}(\gamma, \interp{g'}\gamma)}$ equals\\
      $\bigcup\limits{n \in \nats} \comprehend{s_1\cdot\ldots s_n}{\forall i \in \setof{1\ldots n}.\; s_i \in \interp{g_0[g'/x]}(\gamma)}$

      Hence $\interp{g_0*}(\gamma, \interp{g'}\gamma) = \interp{(g_0[g'/x])*}\gamma$

      Hence $\interp{g_0*}(\gamma, \interp{g'}\gamma) = \interp{(g_0*)[g'/x]}\gamma$
    \end{case}

    \begin{case}{$g = y$}
      If $y \not=x$, then $\interp{y}(\gamma, \interp{g'}\gamma) = \gamma(y) = \interp{y[g'/x]}\gamma$. 

      Otherwise, $\interp{x}(\gamma, \interp{g'}\gamma) = \interp{g'}\gamma = \interp{x[g'/x]}\gamma$. 
    \end{case}

    \begin{case}{$g = \fix{y}{g_0}$}
      By inversion , we know that that $g_0$ has free variables in $\Gamma, y, x$. 

      So by induction, we know that for all $\gamma'$ sending $\Gamma, y$ to languages, 
      $\interp{g_0}(\gamma', \interp{g'}\gamma') = \interp{g_0[g'/x]}\gamma'$. 

      Now, assume we have a $\gamma$ sending $\Gamma$ to languages. Since $y$ does not 
      occur free in $g'$, we know that for all languages $L$, $\interp{g'}(\gamma, L) = \interp{g'}\gamma$. 

      Hence $\interp{g_0}(\gamma, x:\interp{g'}\gamma, y:L) = \interp{g_0[g'/x]}(\gamma, y:L)$.

      Hence $\mathit{fix}(\fun{L}{\interp{g_0}(\gamma, x:\interp{g'}\gamma, y:L)}) = \mathit{fix}(\fun{L}{\interp{g_0[g'/x]}(\gamma, L)}$. 
 
      Hence $\interp{\fix{y}{g_0}}(\gamma, \interp{g'}\gamma) = \interp{\fix{y}{g_0[g'/x]}}\gamma$. 

      Hence $\interp{\fix{y}{g_0}}(\gamma, \interp{g'}\gamma) = \interp{(\fix{y}{g_0})[g'/x]}\gamma$. 
   \end{case}
  \end{caseblock}
\end{proof}

\subsection{Bracketed Languages}

To define the bracketed languages, we will impose \emph{typing
  restrictions} on our syntax of grammatical expressions, to ensure
that open and close parentheses match up, and that every recursive
call is wrapped with an explicit open and close symbol.

\begin{mathpar}
  \begin{array}{llcl}
    \mbox{Contexts} & \Gamma & ::= & \cdot \bnfalt \Gamma, x \\
    \mbox{Types}    & d      & \in  & \nats \times \nats \\
  \end{array}
\\
\boxed{\judgebalance{g}{d}}
\\
\inferrule*[right=TEpsilon]
           { }
           {\judgebalance{\epsilon}{\zero}}
\and
\inferrule*[right=TChar]
          { }
          {\judgebalance{c}{0}}
\and
\inferrule*[right=TOpen]
          { }
          {\judgebalance{\rgt{b}}{(1, 0)}}
\and
\inferrule*[right=TClose]
          { }
          {\judgebalance{\rgt{b}}{(0, 1)}}
\and
\inferrule*[right=TCat]
          {\judgebalance{g_1}{d_1} \\ 
           \judgebalance{g_2}{d_2} }
          {\judgebalance{g_1\cdot g_2}{d_1 \oplus d_2}}
\and
\inferrule*[right=TStar]
          {\judgebalance{g}{\zero}}
          {\judgebalance{g*}{\zero}}
\and
\inferrule*[right=TBot]
          { }
          {\judgebalance{\bot}{d}}
\and
\inferrule*[right=TAlt]
          {\judgebalance{g_1}{d} \\ 
           \judgebalance{g_2}{d} }
          {\judgebalance{g_1 \vee g_2}{d}}
\and
\inferrule*[right=TVar]
          {x \in \Gamma}
          {\judgebalance{\lft{a} x \rgt{b}}{\zero}}
\and
\inferrule*[right=TFix]
          {\judgebalance[\Gamma, x]{g}{\zero}}
          {\judgebalance{\fix{x}{g}}{\zero}}
\\
\\
\combine{(R_1, L_1)}{(R_2, L_2)} = 
         \begin{array}{l}
           \IfThenElse{L_1 < R_2}{(R_1 + R_2 - L_1, L_2)}{(R_1, L_1 +  L_2 - R_2)} 
         \end{array}
  
      
\end{mathpar}

Here, we ascribe integers as types to our grammars, with the idea that
the type of a grammar is a pair describing the number of unbalanced
(right, left)-parentheses in each sentence of the grammar's language.
So a properly bracketed string will have a type of $\zero$, and if a
string has type $(r, l)$, then it will have $r$ unbalanced right
parentheses on the left and $l$ unbalanced left parentheses on the
right.


\begin{itemize}
\item The grammar $\rgt{a} \vee \rgt{b}\cdot(\lft{c}\cdot x\cdot
  \rgt{d})*$ should have type $(1, 0)$, since every sentence of this
  language has one unbalanced right-bracket.

\item The grammar $(a \vee c)\cdot\lft{a}\cdot\lft{b}$ has type $(0, 2)$, since 
  each word in this language has two right parentheses on the left, and 
  no left parentheses on the right. 

\item The grammar $\rgt{b}\cdot\lft{a}$ has type $(1, 1)$, since this
  grammar has one unbalanced right-bracket and one unbalanced left-bracket. 

\item A language like $\epsilon \vee \rgt{a}$ will fail to typecheck,
  since each of its two sentences $\setof{\epsilon, \rgt{a}}$ has a
  different number of unbalanced parentheses in them. 
\end{itemize}

The rule \textsc{TVar} is the only rule that lets us introduce 
variables, and it ensures that every call is guarded with a left-
and right-bracket.  

The \textsc{TStar} and \textsc{TFix} rules restrict their subterms to
be balanced (i.e., have a type of $\zero$) to ensure that a fixed type
$d = (R, L)$ can accurately describe every string in the language --
otherwise different strings in the grammar's language could have
different types due to unbalanced parentheses being repeated a variable
number of times.




\begin{theorem}{(Substitution)}
If $\judgebalance[\Gamma,x]{g}{d}$ and $\judgebalance{g'}{\zero}$
then $\judgebalance[\Gamma']{g[g'/x]}{d}$. 
\end{theorem}

\begin{proof}
  This proceeds by induction on the derivation of $g$. 

  \begin{caseblock}
    \begin{case}{$g \in \{\sigma, \bot, \epsilon\}$}
      By rule $\judgebalance{g[g'/x]}{d}$, and we know $g[g'/x] = g$ since
      these terms have no free variables in them. 
      Hence $\judgebalance{g[g'/x]}{d}$
    \end{case}

    \begin{case}{$\judgebalance[\Gamma,x]{g*}{\zero}$}
      By inversion, we have $\judgebalance{g}{\zero}$. 

      By induction, we have $\judgebalance{g[g'/x]}{\zero}$.

      By rule \textsc{TStar}, we have $\judgebalance{(g[g'/x])*}{\zero}$. 

      By definition of substitution, $\judgebalance{(g*)[g'/x]}{\zero}$. 
    \end{case}

    \begin{case}{$\judgebalance[\Gamma, x]{g_1\cdot g_2}{d}$}
      By inversion, we have $\judgebalance[\Gamma, x]{g_1}{d_1}$, and
        $\judgebalance[\Gamma, x]{g_2}{d_2}$, and $d = d_1 + d_2$. 
      
      By induction, we have $\judgebalance{g_1[g'/x]}{d_1}$ and 
      $\judgebalance{g_2[g'/x]}{d_2}$. 

      By rule \textsc{TCat}, we have $\judgebalance{(g_1[g'/x])\cdot(g_2[g'/x])}{d_1 + d_2}$. 
      
      By definition, we have $\judgebalance{(g_1\cdot g_2)[g'/x]}{d}$. 
    \end{case}

    \begin{case}{$\judgebalance[\Gamma, x]{g_1\vee g_2}{d}$}
      By inversion, we have $\judgebalance[\Gamma, x]{g_1}{d}$, and
        $\judgebalance[\Gamma, x]{g_2}{d}$.
      
      By induction, we have $\judgebalance{g_1[g'/x]}{d}$ and 
      $\judgebalance{g_2[g'/x]}{d}$. 

      By rule \textsc{TCat}, we have $\judgebalance{(g_1[g'/x])\vee(g_2[g'/x])}{d}$. 
      
      By definition, we have $\judgebalance{(g_1\vee g_2)[g'/x]}{d}$. 
    \end{case}
    
    \begin{case}{$\judgebalance[\Gamma, y]{\lft{a}\cdot y \cdot\rgt{b}}{\zero}$}
      There are two cases, depending on whether $x = y$ or not. 

      \begin{itemize}
        \item If $x \not= y$, then $y \in \Gamma$, therefore
          $\judgebalance{\lft{a}\cdot y \cdot\rgt{b}}{\zero}$. 

        \item If $x = y$:
          
          By hypothesis, $\judgebalance{g'}{\zero}$.

          By rule \textsc{TCat} twice, $\judgebalance{\lft{a}\cdot g'\cdot\rgt{b}}{\zero}$. 

          By definition, $\judgebalance{(\lft{a}\cdot x \cdot\rgt{b})[g'/x]}{\zero}$
      \end{itemize}
    \end{case}

    \begin{case}{$\judgebalance[\Gamma, x]{\fix{y}{g}}{\zero}$}
      By inversion, we have $\judgebalance[\Gamma, x, y]{g}{\zero}$

      By induction, we have $\judgebalance[\Gamma, y]{g[g'/x]}{\zero}$

      By rule \textsc{TFix}, $\judgebalance{\fix{y}{g[g'/x]}}{\zero}$

      By definition, $\judgebalance{(\fix{y}{g})[g'/x]}{\zero}$
    \end{case}
  \end{caseblock}
\end{proof}

\begin{lemma}{(Associativity of $\oplus$)}
  For all $d_1, d_2, d_3$, we have that 
  $\combine{(\combine{d_1}{d_2})}{d_3} = \combine{d_1}{(\combine{d_2}{d_3})} $. 
\end{lemma}

\begin{proof}
  Let $d_i = (R_i, L_i)$ for $i \in \setof{1,2,3}$. 

  First, let us consider the two cases for whether $R_2 < L_1$
  \begin{caseblock}
    \begin{case}{$L_1 < R_2$}
      In this case $\combine{d_1}{d_2} = (R_1 + R_2 - L_1, L_2)$. 

      Now consider whether $L_2 < R_3$: 
      \begin{caseblock}
        \begin{case}{$L_2 < R_3$}
          In this case $\combine{d_2}{d_3} = (R_2 + R_3 - L_2, L_3)$. 

          Furthermore, $\combine{(\combine{d_1}{d_2})}{d_3} = (R_1 + R_2 - L_1 + R_3 - L_2, L_3)$

          Since $L_1 < R_2$ and $L_2 < R_3$, we know $L_1 + L_2 < R_2 + R_3$, and so 
          $L_1 < R_2 + R_3 - L_2$. Therefore $\combine{d_1}{(\combine{d_2}{d_3})} = (R_1 + R_2 + R_3 - L_2 - L_1, L_3)$. 
        \end{case}

        \begin{case}{$L_2 \geq R_3$}
          In this case $\combine{d_2}{d_3} = (R_2, L_2 + L_3 - R_3)$. 

          Furthermore, $\combine{(\combine{d_1}{d_2})}{d_3} = (R_1 + R_2 - L_1, L_2 + L_3 - R_3)$. 

          Furthermore, $\combine{d_1}{(\combine{d_2}{d_3})} = (R_1 + R_2 - L_1, L_2 + L_3 - R_3)$. 
        \end{case}
      \end{caseblock}
    \end{case}

    \begin{case}{$L_1 \geq R_2$}
      In this case $\combine{d_1}{d_2} = (R_1, L_1 + L_2 - R_2)$. 

      Now consider whether $L_2 < R_3$: 
      \begin{caseblock}
        \begin{case}{$L_2 < R_3$}
          In this case, $\combine{d_2}{d_3} = (R_2 + R_3 - L_2, L_3)$. 

          Now consider whethere $L_1 + L_2 - R_2 < R_3$: 
          \begin{caseblock}
            \begin{case}{$L_1 + L_2 - R_2 < R_3$}
              In this case $\combine{(\combine{d_1}{d_2})}{d_3} = (R_1 + R_3 + R_2 - L_1 - L_2, L_3)$.
              
              Furthermore, since $L_1 < R_2 + R_3 - L_2$, we know 
              $\combine{d_1}{(\combine{d_2}{d_3})} = (R_1 + R_2 + R_3 - L_2 - L_1, L_3)$. 
            \end{case}

            \begin{case}{$L_1 + L_2 - R_2 \geq R_3$}
              In this case $\combine{(\combine{d_1}{d_2})}{d_3} = (R_1, L_1 + L_2 - R_2 + L_3 - R_3)$. 

              Furthermore, since $L_1 \geq R_2 + R_2 - L_2$, we know that 
              $\combine{d_1}{(\combine{d_2}{d_3})} = (R_1, L_1 + L_3 - R_2 - R_3 + L_2)$. 
            \end{case}
          \end{caseblock}
        \end{case}

        \begin{case}{$L_2 \geq R_3$}
          In this case, $\combine{d_2}{d_3} = (R_2, L_2 + L_3 - R_3)$. 

          Since $L_1 + L_2 \geq R_2 + R_3$, we know that $L_1 + L_2 - R_2 \geq R_3$. Hence
          $\combine{(\combine{d_1}{d_2})}{d_3} = (R_1, L_1 + L_2 - R_2 + L_3 - R_3)$. 

          Since $L_1 + L_2 \geq R_2 + R_3$, we know that $L_1 \geq R_2 + R_3 - L_2$, Hence
          $\combine{d_1}{(\combine{d_2}{d_3})} = (R_1, L_1 + L_2 + L_3 - R_3 - R_2)$
        \end{case}
      \end{caseblock}
    \end{case}
  \end{caseblock}
\end{proof}



\begin{lemma}{(Equivalence is Type-Preserving)}
For the following equivalences, if $\judgebalance{g}{d}$ and $g \simeq g'$, then $\judgebalance{g'}{d}$.   
\end{lemma}

\begin{proof}
  \begin{caseblock}
    \begin{case}{$g_1 \vee g_2 \simeq g_2 \vee g_1$}
      By inversion $\judgebalance{g_1}{d}$ and $\judgebalance{g_2}{d}$. By 
      rule \textsc{TAlt}, $\judgebalance{g_2 \vee g_2}{d}$. 
    \end{case}

    \begin{case}{$g \vee g \simeq g$}
      By inversion $\judgebalance{g}{d}$. 
    \end{case}

    \begin{case}{$g \simeq g \vee g$}
      By rule \textsc{TAlt}, $\judgebalance{g \vee g}{d}$. 
    \end{case}

    \begin{case}{$g \vee \bot \simeq g$}
      By inversion, $\judgebalance{g}{d}$. 
    \end{case}

    \begin{case}{$g \simeq g \vee \bot$}
      By rule \textsc{TBot}, $\judgebalance{\bot}{d}$. 

      By rule \textsc{TAlt}, $\judgebalance{g \vee \bot}{d}$. 
    \end{case}

    \begin{case}{$g_1 \vee (g_2 \vee g_3) \simeq (g_1 \vee g_2) \vee g_3$}
      By inversion $\judgebalance{g_1}{d}$ and $\judgebalance{g_2 \vee g_3}{d}$. 

      By inversion $\judgebalance{g_2}{d}$ and $\judgebalance{g_3}{d}$.

      By rule \textsc{TAlt}, $\judgebalance{g_1 \vee g_2}{d}$.
      
      By rule \textsc{TAlt}, $\judgebalance{(g_1 \vee g_2) \vee g_3}{d}$. 
    \end{case}

    \begin{case}{$(g_1 \vee g_2) \vee g_3 \simeq g_1 \vee (g_2 \vee g_3)$}
      By inversion $\judgebalance{g_3}{d}$ and $\judgebalance{g_1 \vee g_2}{d}$. 

      By inversion $\judgebalance{g_1}{d}$ and $\judgebalance{g_2}{d}$.

      By rule \textsc{TAlt}, $\judgebalance{g_2 \vee g_3}{d}$.
      
      By rule \textsc{TAlt}, $\judgebalance{g_1 \vee (g_2 \vee g_3)}{d}$. 
    \end{case}

    \begin{case}{$\epsilon\cdot g \simeq g$}
      By inversion, $\judgebalance{\epsilon}{\zero}$ and $\judgebalance{g}{d}$. 
    \end{case}

    \begin{case}{$g \simeq g\cdot\epsilon$}
      By inversion, $\judgebalance{\epsilon}{\zero}$ and $\judgebalance{g}{d'}$,
      where $d = \combine{\zero}{d'}$. 

      Hence $d' = d$ and $\judgebalance{g}{d}$. 
    \end{case}
    

    \begin{case}{$g \simeq g \cdot \epsilon$}
      By rule \textsc{TEpsilon}, $\judgebalance{\epsilon}{\zero}$. 

      Since $\combine{d}{\zero} = d$, by rule \textsc{TCat}, $\judgebalance{g \cdot \epsilon}{d}$. 
    \end{case}

    \begin{case}{$g\cdot\epsilon \simeq g$}
      By inversion, $\judgebalance{\epsilon}{\zero}$ and $\judgebalance{g}{d'}$,
      where $d = \combine{d'}{0}$. 

      Hence $d' = d$ and $\judgebalance{g}{d}$. 
    \end{case}
    
    \begin{case}{$g_1\cdot(g_2\cdot g_3) \simeq (g_1\cdot g_2)\cdot g_3$}
      By inversion, $\judgebalance{g_1}{d_1}$ and $\judgebalance{g_2\cdot g_3}{d'}$, 
      where $d = \combine{d_1}{d'}$. 
      
      By inversion, $\judgebalance{g_2}{d_2}$ and $\judgebalance{g_3}{d_3}$, where
      $d' = \combine{d_2}{d_3}$. 

      So $d = \combine{d_1}{(\combine{d_2}{d_3})}$. By associativity of $\oplus$, 
      $d = \combine{(\combine{d_1}{d_2})}{d_3}$. 
    \end{case}

    \begin{case}{$\bot \cdot g \simeq \bot$}
      By rule \textsc{TBot}, $\judgebalance{\bot}{d}$.
    \end{case}

    \begin{case}{$g \cdot \bot \simeq \bot$}
      By rule \textsc{TBot}, $\judgebalance{\bot}{d}$.
    \end{case}

    \begin{case}{$(g_1 \vee g'_1)\cdot g_2 \simeq g_1\cdot g_2 \vee g'_1\cdot g_2$}
      By inversion we know that $\judgebalance{g_1 \vee g'_1}{d_1}$ and 
      $\judgebalance{g_2}{d_2}$ where $d = \combine{d_1}{d_2}$. 

      By inversion $\judgebalance{g_1}{d_1}$ and $\judgebalance{g'_1}{d_1}$.

      By rule \textsc{TCat} that $\judgebalance{g_1\cdot g_2}{d}$. 

      By rule \textsc{TCat} that $\judgebalance{g'_1\cdot g_2}{d}$. 

      By rule \textsc{TOr} that $\judgebalance{g_1\cdot g_2 \vee g'_1\cdot g_2}{d}$. 
    \end{case}

    \begin{case}{$g* \simeq \epsilon \vee g\cdot(g*)$}
      By inversion, $\judgebalance{g}{\zero}$. 

      By rule $\judgebalance{\epsilon}{\zero}$

      Since $\zero = \combine{\zero}{\zero}$, $\judgebalance{g\cdot(g*)}{\zero}$
      
      By rule, $\judgebalance{\epsilon \vee g\cdot(g*)}{\zero}$
    \end{case}

    \begin{case}{$\fix{x}{g} \simeq g[\fix{x}{g}/x]$}
      By inversion $\judgebalance[\Gamma, x]{g}{\zero}$. 

      By substitution, $\judgebalance{g[\fix{x}{g}/x]}{\zero}$
    \end{case}
  \end{caseblock}

  Here are some equivalences that don't work the way we might expect: 
  \begin{caseblock}
    \begin{case}{$\bot \not\simeq g \cdot \bot$ and $\bot \not\simeq \bot \cdot g$}
      In general this doesn't hold since $g$ isn't necessarily well-typed. But if it is,
      it does hold. 
    \end{case}

    \begin{case}{$g_1\cdot g_2 \vee g'_1\cdot g_2 \not\simeq (g_1 \vee g'_1)\cdot g_2$}
      This direction does not have to hold. Consider $(\lft{a}\cdot\bot) \vee (\rgt{a}\cdot\bot)$. 
      This can be given a type, but after ``undistributing'' it won't. Luckily we won't
      use this direction of rewriting!
    \end{case}
  \end{caseblock}
\end{proof}

\subsection{Semantics of Bracketed Grammars}

To verify the claims above, we'll need to give a refined semantics for bracketed 
languages. 

\subsubsection{Properties of Bracketing}

Next, we'll say a word $\sigma$ is \emph{strictly well-bracketed} if there is a
relation $R$ on the positions in the word, such that

\begin{enumerate}
\item $R$ describes a matching between open and close brackets: 
      $i \in \mathrm{dom}(R)$ iff $\sigma(i) \in \Sigma_l$. And also,
      $j \in \mathrm{cod}(R)$ iff $\sigma(j) \in \Sigma_r$.
\item $R$ is nested: if $R(i, j)$ and $R(i', j')$ holds, then if $i \leq i'$ and $i' \leq j$, then $j' \leq j$. 
\item Brackets match up uniquely: if $R(i, j)$ and $R(i', j')$ holds, then $i = i'$ iff $j = j'$. 
\end{enumerate}

Now, we will relax this condition, and say a word $\sigma$ is
bracketed up to $d = (R, L) \in \nats \times \nats$ if it can
be broken up into $L + R + 1$ strictly well-bracketed substrings, with 
the first $R$ substrings separated by characters from $\Sigma_r$ and
the last $L$ substrings separated by characters from $\Sigma_l$. 

So a string of type $\zero$ is just a strictly well-bracketed string,
whereas one of type $(0, 1)$ will be split into two strictly
well-bracketed pieces with a right-parenthesis separating them. We
will also say a language $L$ is well-bracketed up to $d$, if every
string $\sigma$ in $L$ is well-bracketed to depth $d$.


\begin{prop}{(Semantic Nesting Lemma)}
If $s$ is nested to depth $d$ and $s'$ is nested to depth $d'$, then 
$s\cdot s'$ is nested to depth $\combine{d}{d'}$.
\end{prop}

\begin{proof}
  Suppose that $d = (r, l)$ and $d' = (r', l')$. By definition, we know that 
  \begin{mathpar}
    s = s_0 \cdot \rgt{a_1} \cdot \ldots \rgt{a_r} \cdot s_r \cdot \lft{b_1} \cdot \ldots \cdot \lft{b_l} \cdot s_{r+l}    
    \\
    s' = s'_0 \cdot \rgt{a_1} \cdot \ldots \rgt{a_{r'}} \cdot s_{r'} \cdot \lft{b_1} \cdot \ldots \cdot \lft{b_{l'}} \cdot s_{r'+l'}    
    \\
  \end{mathpar}

  Therefore the concatenation is 
  \begin{mathpar}
    s\cdot s' = s_0 \cdot \rgt{a_1} \cdot \ldots \rgt{a_r} \cdot s_r \cdot \lft{b_1} \cdot \ldots \cdot \lft{b_l} \cdot (s_{r+l} \cdot s'_0) \cdot \rgt{a'_1} \cdot \ldots \rgt{a'_{r'}} \cdot s_{r'} \cdot \lft{b'_1} \cdot \ldots \cdot \lft{b'_{l'}} \cdot s_{r'+l'}     
  \end{mathpar}

  Now, suppose that $l < r'$. Then we know that 
  $s_r \cdot \lft{b_1} \cdot \ldots \cdot \lft{b_l} \cdot (s_{r+l} \cdot s'_0) \cdot \rgt{a'_1} s'_{1} \cdot \cdot \ldots \rgt{a'_l} \cdot s'_{l}$ is strictly well-bracketed. Therefore the concatenation has $r + r' - l$ leading
unbalanced right parentheses, and $l'$ unbalanced left-parentheses. So $s\cdot s'$ is nested to depth $\combine{d}{d'}$

  On the other hand, suppose $l \geq r'$. Then we know that $s_{r+l-r'-1} \cdot \lft{b_{l-r}} \cdot \ldots \cdot \lft{b_l} \cdot (s_{r+l} \cdot s'_0) \cdot \rgt{a'_0} \cdot \ldots \rgt{a'_{r'}} \cdot s'_{r'}$ is strictly well-bracketed.
So the concatenation has $r$ leading unbalanced right parentheses, and $l-r+l'$ unbalanced left parentheses. As a
result, $s\cdot s'$ is nested to depth $\combine{d}{d'}$. 

\end{proof}

\begin{prop}
If $\judgebalance{g}{d}$, and $\gamma$ is a map from the variables in $\Gamma$ to 
languages well-nested with depth $0$, then $\interp{g}\;\gamma$ is a language well-nested 
with depth $d$. 
\end{prop}

\begin{proof}
The proof is by induction on the typing derivation of $g$. Assume we have a context $\gamma$ of well-nested
languages.

\begin{caseblock}
  \begin{case}{$\judgebalance{\epsilon}{\zero}$}
    We see $\interp{\epsilon}{\gamma} = \setof{\epsilon}$, which is a one-element set consisting 
    of a single well-nested word (since it has no characters in it at all). 
  \end{case}

  \begin{case}{$\judgebalance{c}{\zero}$}
    We see $\interp{c}{\gamma} = \setof{c}$, which is a one-element set consisting 
    of a single well-nested word (since it has no brackets in it at all). 
  \end{case}

  \begin{case}{$\judgebalance{\rgt{a}}{+1}$}
    We see $\interp{\rgt{a}}{\gamma} = \setof{\rgt{a}}$, which is a one-element set consisting 
    of a single bracket. This is a well-nested word of depth $+1$, since we can write it as a 
    word of the from $\epsilon\rgt{a}\cdot\epsilon$, and $\epsilon$ is well-nested. 
   \end{case}

  \begin{case}{$\judgebalance{g_1\cdot g_2}{d_1 + d_2}$}
    We reason as follows: 
    \begin{enumerate}
      \item By inversion, we know that $\judgebalance{g_1}{d_1}$, and $\judgebalance{g_2}{d_2}$.
      \item By the semantics, every word $\sigma$ of $\interp{g_1\cdot g_2}\gamma$ is equal to 
        $\sigma_1\cdot\sigma_2$, where $\sigma_1 \in \interp{g_1}\gamma$ and $\sigma_2 \in \interp{g_2}\gamma$. 
      \item By induction, we know that $\sigma_1$ is nested to depth $d_1$ and $\sigma_2$ is nested to depth $d_2$.
      \item By the semantic nesting lemma, we know that $\sigma_1 \cdot \sigma_2$ has nesting depth $d_1 + d_2$. 
    \end{enumerate}
  \end{case}

  \begin{case}{$\judgebalance{g*}{\zero}$}
    We reason as follows: 
    \begin{enumerate}
      \item By inversion, we know that $\judgebalance{g}{\zero}$, so every string in $\interp{g}\gamma$ is 
        well-nested. 
      \item By the semantics of languages, every word $\sigma$ in $\interp{g*}\gamma$ is a concatenation of 
        $n$ well-nested words for some $n$. 
      \item By induction on $n$ and the semantic nesting lemma, we know that $\sigma$ is well-nested. 
    \end{enumerate}
  \end{case}

  \begin{case}{$\judgebalance{\lft{a}x\rgt{b}}{\zero}$}
    We reason as follows: 
    \begin{enumerate}
      \item By hypothesis, we know that $\gamma(x)$ is a well-nested language of depth 0. 
      \item From the semantics we know that every word $\sigma$ of $\interp{\lft{a}x\rgt{b}}\gamma$ is 
        of the form $\lft{a}\cdot\sigma'\cdot\rgt{b}$, where $\sigma' \in \gamma(x)$. 
      \item We can construct a nesting relation for this word by adding the first and last positions 
        to the nesting relation for $\sigma'$. 
      \item This means that there are no brackets left over, so we have a nesting depth of 0. 
    \end{enumerate}
  \end{case}

  \begin{case}{$\judgebalance{\fix{x}{g}}{\zero}$}
    We reason as follows: 
    \begin{enumerate}
      \item By inversion, we know that $\judgebalance[\Gamma, x]{g}{\zero}$ holds. 
      \item By induction, given a zero-balanced language $L$ as an argument, $f = \fun{L}{\interp{g}(\gamma,L)}$
        returns a zero-balanced language. 
      \item Since the empty language is zero-balanced, $f\;\emptyset$ is
        also zero-balanced. 
      \item So, we know from the semantics that $f$ preserves zero-balance and that the least language is zero-balanced. 
      \item So we know that $h = \fun{L}{L \cup f(L)}$ is zero-balanced, since zero-balance is closed under unions. 
      \item Hence $\mathit{fix}(h)$ is also zero-balanced. 
      \item This is the denotation of $\fix{x}{g}$ at $\gamma$, so the theorem holds. 
    \end{enumerate}
  \end{case}

  \begin{case}{$\judgebalance{\bot}{d}$}
    The interpretation of $\bot$ is the empty set, which vacuously satisfies the property that
    all its elements are well-nested to depth $d$. 
  \end{case}

  \begin{case}{$\judgebalance{g_1 \vee g_2}{d}$}
    We reason as follows:
    \begin{enumerate}
      \item From the semantics $\interp{g_1 \vee g_2}\gamma = \interp{g_1}\gamma \cup \interp{g_2}\gamma$.
      \item By induction, both $\interp{g_1}\gamma$ and $\interp{g_2}\gamma$ are well-nested to depth $d$.
      \item Therefore every element in the union is well-nested to depth $d$. 
    \end{enumerate}
    
  \end{case}
\end{caseblock}

\end{proof}


% \subsection{Generalizing to Nested Word Languages}
% 
% Now that we have a definition and semantics for bracketed languages, we'll
% generalize this just a little bit, to \emph{nested word languages}. A nested
% word language is essentially a regular expression over the whole alphabet
% $\Sigma$, but which can make calls to a bracketed language. We'll define the
% set $N$ of nested word grammars with the following BNF:
% 
% \begin{mathpar}
%   \begin{array}{lcl}
%     n & ::= & \epsilon \bnfalt \sigma \bnfalt n_1 \cdot n_2 \bnfalt n* \bnfalt \bot 
%               \bnfalt n_1 \vee n_2 \bnfalt \lft{a} i \rgt{b} \\
%   \end{array}
% \end{mathpar}
% 
% The reason we make this generalization is for two reasons. First, we'd like to
% be able to specify a language that includes \emph{unbalanced} brackets, so
% that we can handle incremental addition of parentheses in an editor.  Second,
% and more importantly, nested word languages have better closure properties
% than bracketed languages do -- in particular, when we take a derivative of a
% balanced paren, the remaining string is now unbalanced.

\subsection{Relating Syntactic and Semantic Properties of Grammars}

We define the emptification operator on well-typed grammars as follows: 

\begin{mathpar}
  \begin{array}{lcl}
    \emptify{\epsilon}      & = & \true \\
    \emptify{\sigma}        & = & \false \\
    \emptify{g_1 \cdot g_2} & = & \emptify{g_1} \land \emptify{g_2} \\
    \emptify{g*}           & = & \true \\
    \emptify{\bot}         & = & \false \\
    \emptify{g_1 \vee g_2} & = & \emptify{g_1} \vee \emptify{g_2} \\
    \emptify{\fix{x}{g}}   & = & \emptify{x} \\
    \emptify{\lft{a} x \rgt{b}} & = & \false \\
  \end{array}
\end{mathpar}

The idea is that this is an operation that returns the language
$\epsilon$ if its argument contains the empty string, and the language
$\bot$ if its argument language does not contain the empty string. Since we
restrict to well-typed grammars, all occurences of variables are 
guarded, and so the result of the emptification operator is the same under
all substitutions for the variables.  

\begin{prop}{(Emptiness Operator)}
Suppose $g$ is a well-typed grammar with free variables $\Gamma$. Then
for any assignment of languages $\gamma$ for $\Gamma$, we have that
$\emptify{g}$ is $\true$ if $\epsilon \in \interp{g}\gamma$, and is
$\false$ otherwise.
\end{prop}

\begin{proof}
This proof is by induction on $g$. 
\begin{caseblock}
  \begin{case}{$\epsilon$}
    The interpretation of this language contains the empty string, and $\emptify{\epsilon} = \true$. 
  \end{case}

  \begin{case}{$\sigma$}
    The interpretation of this language is the one-element set containing the one-character string $c$, 
    which does not contain $\epsilon$, and we have that $\emptify{\sigma} = \false$. 
  \end{case}

  \begin{case}{$g_1\cdot g_2$}
    The interpretation $\interp{g_1\cdot g_2}\gamma$ contains the concatenations of the strings of
    $\interp{g_1}\gamma$ and $\interp{g_2}\gamma$. This can only contain an empty string if both 
    languages contain empty strings. 

    By induction, we know that in that case, both $\emptify{g_1}$ and $\emptify{g_2}$ will equal $\true$, 
    and so by the definition, we know that $\emptify{g_1\cdot g_2} = \false$. Otherwise, it will equal
    $\false$, and likewise the interpretation will not contain the empty string.
  \end{case}

  \begin{case}{$g*$}
    We know that $\interp{g*}\gamma$ contains the empty string by definition, and likewise the 
    $\emptify{g*} = \true$. 
  \end{case}

  \begin{case}{$\fix{x}{g}$}
    By induction, we know for any language $L$, that $\epsilon \in \interp{g}(\gamma, L)$  if and 
    only if $\emptify{g} = \true$. Therefore, we know that 
    $\epsilon \in \interp{g}(\gamma, \interp{\fix{x}{g}}\gamma)$ if and only if $\emptify{g} = \true$. 
    Therefore, we know that $\emptify{g} = \true$ if and only if $\epsilon \in \interp{\fix{x}{g}}\gamma$. 
  \end{case}

  \begin{case}{$\lft{a}x\rgt{b}$}
    For any language $L$, all the words in $\interp{\lft{a}x\rgt{b}}L$ are non-empty. 
    Since $\emptify{\lft{a}x\rgt{b}} = \false$, the algorithm is correct in this case. 
  \end{case}

  \begin{case}{$\bot$}
    The interpretation of this grammar is the empty set of strings, which does not
    contain the empty string. Since $\emptify{\bot} = \false$, the algorithm is correct in
    this case. 
  \end{case}

  \begin{case}{$g_1 \vee g_2$}
    We reason as follows:
    \begin{enumerate}
      \item By induction, we know that $\emptify{g_1} = \true$ when $\epsilon \in \interp{g_1}\gamma$, 
        and is $\false$  otherwise. 
      \item By induction, we know that $\emptify{g_2} = \true$ when $\epsilon \in \interp{g_2}\gamma$, 
        and is $\false$  otherwise. 
      \item The interpretation $\interp{g_1 \vee g_2}\gamma = \interp{g_1}\gamma \cup \interp{g_2}\gamma$,  
        and so $\epsilon$ is in this set if and only if it is in either $\interp{g_1}\gamma$ or in 
        $\interp{g_2}\gamma$.
      \item If it is in either one, then $\emptify{g_1 \vee g_2} = \true$ by the definition, and is 
        $\false$ otherwise. 
    \end{enumerate}
  \end{case}
\end{caseblock}
\end{proof}

\begin{lemma}{Emptiness and Balance}
If $\judgebalance{g}{d}$ is well-typed, and $\emptify{g}$, then $d = \zero$. 
\end{lemma}

\begin{proof}
  This is by induction over the derivation of $g$. 
  \begin{caseblock}
    \begin{case}{$\judgebalance{\epsilon}{d}$}
      By inversion on the derivation, we know that $d = \zero$
    \end{case}

    \begin{case}{$\judgebalance{\sigma}{d}$}
      By assumption $\emptify{\sigma} = \true$, which is a contradiction. Hence this
      case is impossible. 
    \end{case}

    \begin{case}{$\judgebalance{g_1\cdot g_2}{d}$}
      By inversion, we know that $\judgebalance{g_1}{d_1}$, and
      $\judgebalance{g_2}{d_2}$, and that $\combine{d_1}{d_2} = d$.  

      By hypothesis, we know that $\emptify{g_1\cdot g_2} = \true$. 

      By definition we know that $\emptify{g_1} \land \emptify{g_2} =
      \true$. 

      Hence $\emptify{g_1} = \true$ and $\emptify{g_2} = \true$.

      By induction, $d_1 = \zero$ and $d_2 = \zero$. Hence $d = \combine{d_1}{d_2} = \zero$. 
    \end{case}

    \begin{case}{$\judgebalance{g*}{d}$}
      By inversion, $d = \zero$. 
    \end{case}

    \begin{case}{$\judgebalance{\bot}{d}$}
      Since $\emptify{\bot} = \false$, and we assume $\emptify{g} = \true$, this case is
      impossible. 
    \end{case}

    \begin{case}{$\judgebalance{g_1 \vee g_2}{d}$}
      By inversion, we know that $\judgebalance{g_1}{d}$ and $\judgebalance{g_2}{d}$. 
      
      By hypothesis, we know that $\emptify{g_1 \vee g_2} = \true$. 

      By definition, $\emptify{g_1} \vee \emptify{g_2} = \true$. 
      
      Hence either $\emptify{g_1}$ or $\emptify{g_2}$ is $\true$. 

      Suppose it is $g_i$. Then by induction $d = \zero$. 

      Hence $\judgebalance{g_1 \vee g_2}{\zero}$. 
    \end{case}

    \begin{case}{$\judgebalance{\fix{x}{g}}{d}$}
      By inversion, $d = \zero$. 
    \end{case}
  \end{caseblock}
\end{proof}

\subsection{Derivatives of Nested Words}

\subsubsection{Derivatives, Semantically}

The definition of a single-character derivative is straightforward. For 
$c \in \Sigma$, we define:

\begin{mathpar}
\semderiv{c}{L} = \comprehend{ s \in \Word }{ c\cdot s \in L}  
\end{mathpar}

\noindent We can lift to derivatives over strings $s$ in a straightforward way: 

\begin{mathpar}
  \begin{array}{lcl}
    \semderiv{\epsilon}{L} & = & L \\
    \semderiv{c \cdot s}{L} & = & \semderiv{c}{\semderiv{s}{L}} \\
  \end{array}
\end{mathpar}

\subsection{Derivatives, Syntactically}

Now, let's try to define what derivatives should be for grammar
expressions:

\begin{mathpar}
  \begin{array}{lcl}
    \deriv{\sigma}{\epsilon}        & = & \bot \\
    \deriv{\sigma}{\sigma}          & = & \epsilon \\
    \deriv{\sigma}{\sigma'}         & = & \bot \\
    \deriv{\sigma}{g_1 \cdot g_2}   & = & \deriv{\sigma}{g_1}\cdot g_2 \vee (\IfThenElse{\emptify{g_1}}{\deriv{\sigma}{g_2}}{\bot}) \\
    \deriv{\sigma}{g*}              & = & \deriv{\sigma}{g}\cdot(g*) \\
    \deriv{\sigma}{\bot}            & = & \bot \\
    \deriv{\sigma}{g_1 \vee g_2}    & = & \deriv{\sigma}{g_1} \vee \deriv{\sigma}{g_2} \\
    \deriv{\sigma}{\fix{x}{g}}      & = & \deriv{\sigma}{g}[\fix{x}{g}/x] \\
    \deriv{\sigma}{x}               & = & \mbox{(undefined)}
  \end{array}
\end{mathpar}

All of the clauses are identical to the standard derivative algorithm,
except for the last two. We do not define what the algorithm should do
when it reaches a free variable; that is, this algorithm is only
partially defined. 

The derivative of a fixed point $\fix{x}{g}$ is handled by taking the
derivative of fixed point's body, and then substituting the original
gramamtical expression for $x$ and recurring. Intuitively, a
derivative is equivalent to its unrolling, so it might seem that a
more natural thing to do is to unroll the fixed point first, and
\emph{then} take the derivative. However, this would be a
non-structural recursion, and so will complicate the theory.

However, since we are going to be considering balanced grammars, we
can exploit the fact that a one-character derivative will never to
unroll a given fixed point more than once, since every variable
occurence will be guarded. As a result, we can take the derivative,
and then perform the substitution, without changing the result (we
will prove this shortly). 

Now, the derivative of a well-typed grammar will not necessarily be
well-typed, since a subterm of the form $\lft{a}\cdot x \cdot\rgt{b}$ can
differentiated to $x\cdot\rgt{b}$, but it will be the case that any
\emph{substitution} of a derivative will also be well-typed, since
any ``bare'' variables will be replaced by well-typed terms. 

Of course, if we take the derivative with respect to a parenthesis,
the nesting depth of the language will change. Since a parsing
algorithm only ever proceeds from left to right, we only need to
consider the effect on types with zero excess left parentheses on the
right -- that is, we will never generate a derivative of the form $(r,
l > 0)$. So we can define a function to adjust the derivative as 
follows: 

\begin{mathpar}
  \begin{array}{lcll}
    \bump{\sigma \in \Sigma_i}{(r, 0)} & = & (r, 0) \\
    \bump{\lft{a}}{(r, 0)} & = & (r+1, 0) \\
    \bump{\rgt{b}}{(r, 0)} & = & (r-1, 0) \\
  \end{array}
\end{mathpar}

\begin{lemma}{(Existence and Well-Typedness of Derivatives)}
For any grammatical expression $g$ such that $\judgebalance{g}{d}$, we
have that $\deriv{\sigma}{g}$ is defined and that for all
substitutions $\gamma$ such that
$\judgesubst{\Gamma'}{\gamma}{\Gamma}$, we have that
$\judgebalance[\Gamma']{\gamma(\deriv{\sigma}{g})}{\bump{\sigma}{d}}$ with 
and that
$\gamma(\deriv{\sigma}{g}) = \deriv{\sigma}{\gamma(g)}$.
\end{lemma}

\begin{proof}
  This proof proceeds by induction on the derivation of $g$. 

  \begin{caseblock}
    \begin{case}{$g = \bot$ or $g = \epsilon$ or $g = \sigma'$ (where $\sigma' \not= \sigma$)}
      In each case, the derivative exists and is $\bot$, which trivially satisfies the 
      substitution condition. 
    \end{case}

    \begin{case}{$\judgebalance{\sigma}{d}$}
      In this case, the derivative is $\epsilon$, which has a balance of $\zero$ in all 
      contexts. Furthermore $\bump{\sigma}{\sgn{\sigma}} = \zero$. 

      Again, the substitution condition is trivially satisfied, since $\epsilon$ has
      no free variables. 
    \end{case}

    \begin{case}{$\judgebalance{g_1 \vee g_2}{d}$}
      By inversion, we have $\judgebalance{g_2}{d}$ and $\judgebalance{g_2}{d}$
      
      By induction, we have that $\deriv{\sigma}{g_1}$ and $\deriv{\sigma}{g_2}$ are
      both defined. Therefore, we know that $\deriv{\sigma}{g_1 \vee g_2} = \deriv{\sigma}{g_1} \vee 
      \deriv{\sigma}{g_2}$ is defined.

      Suppose that we have $\judgesubst{\Gamma'}{\gamma}{\Gamma}$. Then, by 
      induction we know that $\judgebalance[\Gamma']{\gamma(\deriv{\sigma}{g_1})}{\bump{\sigma}{d}}$ and 
      $\judgebalance[\Gamma']{\gamma(\deriv{\sigma}{g_2})}{\bump{\sigma}{d}}$, and furthermore 
      we know that $\gamma(\deriv{\sigma}{g_1}) = \deriv{\sigma}{\gamma(g_1)}$ and 
      $\gamma(\deriv{\sigma}{g_2}) = \deriv{\sigma}{\gamma(g_2)}$. 

      By rule \textsc{TOr}, we know that $\judgebalance[\Gamma']{\gamma(\deriv{\sigma}{g_1}) \vee \gamma(\deriv{\sigma}{g_2})}{\bump{\sigma}{d}}$. 

      This is equal to $\gamma(\deriv{\sigma}{g_1 \vee g_2})$, so we
      know $\judgebalance[\Gamma']{\gamma(g_1 \vee g_2)}{\bump{\sigma}{d}}$.

      Furthermore, we can reason that: 
      \begin{mathpar}
        \begin{array}{lcl}
          \gamma(\deriv{\sigma}{g_1 \vee g_2})
               & = & \gamma(\deriv{\sigma}{g_1} \vee \deriv{\sigma}{g_2}) \\
               & = & \gamma(\deriv{\sigma}{g_1}) \vee \gamma(\deriv{\sigma}{g_2}) \\
               & = & \deriv{\sigma}{\gamma(g_1)} \vee \deriv{\sigma}{\gamma(g_2)} \\
               & = & \deriv{\sigma}{\gamma(g_1) \vee \gamma(g_2)} \\
               & = & \deriv{\sigma}{\gamma(g_1 \vee g_2)} \\
        \end{array}
      \end{mathpar}
    \end{case}

    \begin{case}{$g = g_1\cdot g_2$}
      By inversion, we know that $\judgebalance{g_1}{d_1}$ and 
      $\judgebalance{g_2}{d_2}$ and $d = \combine{d_1}{d_2}$. 

      By induction, we know that $\deriv{\sigma}{g_1}$ and $\deriv{\sigma}{g_2}$ 
      exist. Since emptiness is defined on all well-typed grammars, it follows
      immediately that $\deriv{\sigma}{g}$ exists. 

      Now suppose that $\judgesubst{\Gamma'}{\gamma}{\Gamma}$. 

      By induction we know that $\judgebalance[\Gamma']{\gamma(\deriv{\sigma}{g_1})}{\bump{\sigma}{d_1}}$ and
      that $\gamma(\deriv{\sigma}{g_1}) = \deriv{\sigma}{\gamma(g_1)}$. 
      
      By substitution, we know that $\judgebalance[\Gamma']{\gamma(g_2)}{d_2}$
        
      Therefore we know that \textsc{TCat}, we know that $\judgebalance[\Gamma']{\gamma(g_1\cdot g_2)}{\combine{\bump{\sigma}{d_1}}{d_2}}$. Furthermore, $\combine{\bump{\sigma}{d_1}}{d_2} = \bump{\sigma}{\combine{d_1}{d_2}}$. 

      We now proceed by  case analysis on $\emptify{g_1}$. 

      \begin{itemize}
        \item If $\emptify{g_1}$ is true, then we know that $d_1 = \zero$. 
        
          Therefore we know that $d_2 = d$, and by induction, we know 
          that $\judgebalance[\Gamma]{\gamma(\deriv{\sigma}{g_2})}{\bump{\sigma}{d}}$, and 
          that $\deriv{\sigma}{\gamma(g_2)} = \gamma(\deriv{\sigma}{g_2})$. 
          
          Therefore we know that $\judgebalance[\Gamma']{\gamma(\deriv{\sigma}{g})}{\bump{\sigma}{d}}$. 

          Furthermore, we can reason that: 
          \begin{mathpar}
            \begin{array}{lcl}
              \gamma(\deriv{\sigma}{g_1\cdot g_2}) 
               & = & \gamma(\deriv{\sigma}{g_1}\cdot g_2 \vee \deriv{\sigma}{g_2}) \\
               & = & \gamma(\deriv{\sigma}{g_1}\cdot g_2) \vee \gamma(\deriv{\sigma}{g_2}) \\
               & = & \gamma(\deriv{\sigma}{g_1})\cdot \gamma(g_2) \vee \gamma(\deriv{\sigma}{g_2}) \\
               & = & \deriv{\sigma}{\gamma(g_1)}\cdot \gamma(g_2) \vee \deriv{\sigma}{\gamma(g_2)} \\
               & = & \deriv{\sigma}{\gamma(g_1)\cdot\gamma(g_2)} \\
               & = & \deriv{\sigma}{\gamma(g_1\cdot g_2)} \\
            \end{array}
          \end{mathpar}

        \item If $\emptify{g_2}$ is false, 

          We know by rule \textsc{TBot} that $\judgebalance[\Gamma']{\bot}{\bump{\sigma}{d}}$. 

          Therefore we know that $\judgebalance[\Gamma']{\gamma(\deriv{\sigma}{g})}{\bump{\sigma}{d}}$. 
          Furthermore, we can reason that: 
          \begin{mathpar}
            \begin{array}{lcl}
              \gamma(\deriv{\sigma}{g_1\cdot g_2}) 
               & = & \gamma(\deriv{\sigma}{g_1}\cdot g_2 \vee \bot) \\
               & = & \gamma(\deriv{\sigma}{g_1}\cdot g_2) \vee \gamma(\bot) \\
               & = & \gamma(\deriv{\sigma}{g_1})\cdot \gamma(g_2) \vee \gamma(\bot) \\
               & = & \deriv{\sigma}{\gamma(g_1)\cdot \gamma(g_2) \vee \bot} \\
               & = & \deriv{\sigma}{\gamma(g_1)\cdot\gamma(g_2)} \\
               & = & \deriv{\sigma}{\gamma(g_1\cdot g_2)} \\
            \end{array}
          \end{mathpar}
      \end{itemize}
    \end{case}

    \begin{case}{$\judgebalance{\fix{x}{g}}{\zero}$}
      By inversion, we know that $\judgebalance[\Gamma, x]{g}{\zero}$. 
      
      So, by induction we know that $\deriv{\sigma}{g}$ is well-defined, and hence 
      $\deriv{\sigma}{\fix{x}{g}}$ is well-defined. 

      Now, suppose that we have $\judgesubst{\Gamma'}{\gamma}{\Gamma}$. Now, note that 
      by substitution, $\judgebalance[\Gamma']{\gamma(\fix{x}{g})}{\zero}$ holds. Hence
      $\judgesubst{\Gamma'}{\gamma_x = \gamma, [\gamma(\fix{x}{g})/x]}{\Gamma,x}$. 

      Therefore by induction hypothesis, we know that
      $\judgebalance[\Gamma']{\gamma_x(\deriv{\sigma}{g})}{\bump{\sigma}{\zero}}$ and that $\deriv{\sigma}{\gamma_x(g)} = \gamma_x(\deriv{\sigma}{g})$. 

      By the definition of $\gamma_x$, substitution and the derivative, we know that $\gamma_x(\deriv{\sigma}{g}) = \gamma(\deriv{\sigma}{g}[\fix{x}{g}/x]) = \gamma(\deriv{\sigma}{\fix{x}{g}})$. 


      Therefore $\judgebalance[\Gamma']{\gamma(\deriv{\sigma}{\fix{x}{g}})}{\bump{\sigma}{\zero}}$.

      Furthermore, we can reason that: 
      \begin{mathpar}
        \begin{array}{lcl}
          \gamma(\deriv{\sigma}{\fix{x}{g}})  
          & = & \gamma(\deriv{\sigma}{g}[\fix{x}{g}/x]) \\
          & = & \gamma(\deriv{\sigma}{g})[\gamma(\fix{x}{g}/x)] \\
          & = & \deriv{\sigma}{\gamma(g)}[\fix{x}{\gamma(g)}/x] \\
          & = & \deriv{\sigma}{\fix{x}{\gamma(g)}} \\
          & = & \deriv{\sigma}{\gamma(\fix{x}{g})} \\
        \end{array}
      \end{mathpar}

    \end{case}

    \begin{case}{$\judgebalance{g*}{\zero}$}
      By inversion, we know that $\judgebalance{g}{\zero}$. 

      Therefore by induction we know that $\deriv{\sigma}{g}$ exists, and so the 
      derivative $\deriv{\sigma}{g*} = \deriv{\sigma}{g}\cdot g*$ exists. 
      
      Assume that we have $\judgesubst{\Gamma'}{\gamma}{\Gamma}$. 
      
      By induction we know that $\judgebalance[\Gamma']{\gamma(\deriv{\sigma}{g})}{\bump{\sigma}{\zero}}$ holds,
      and that $\gamma(\deriv{\sigma}{g}) = \deriv{\sigma}{\gamma(g)}$. 

      By substitution we know that $\judgebalance[\Gamma']{\gamma(g*)}{\zero}$ holds. 

      By rule \textsc{TCat}, we know that $\judgebalance[\Gamma']{\gamma(\deriv{\sigma}{g})\cdot\gamma(g*)}{\bump{\sigma}{\zero}}$ holds. 

      Therefore $\judgebalance[\Gamma']{\gamma(\deriv{\sigma}{g}\cdot(g*))}{\bump{\sigma}{\zero}}$ holds, and
      so $\judgebalance[\Gamma']{\gamma(\deriv{\sigma}{g*})}{\bump{\sigma}{\zero}}$ holds. 

      Furthermore, we can reason that: 
      \begin{mathpar}
        \begin{array}{lcl}
          \gamma(\deriv{\sigma}{g*})  
          & = & \gamma(\deriv{\sigma}{g}\cdot(g*)) \\
          & = & \gamma(\deriv{\sigma}{g})\cdot\gamma(g*) \\
          & = & \deriv{\sigma}{\gamma(g)}\cdot(\gamma(g))* \\
          & = & \deriv{\sigma}{(\gamma(g))*} \\
          & = & \deriv{\sigma}{\gamma(g*)} \\
        \end{array}
      \end{mathpar}
    \end{case}

    \begin{case}{$\judgebalance{\lft{a}\cdot x \cdot\rgt{b}}{\zero}$}
      If $\sigma = \lft{a}$, then $\deriv{\sigma}{\lft{a}\cdot x \cdot\rgt{b}} = x \cdot \rgt{b}$, and
      if it is not, then the derivative is $\bot$. Either way, the derivative exists. 

      Now suppose we have $\judgesubst{\Gamma'}{\gamma}{\Gamma}$. 

      If the derivative is $\bot$, then the conclusion is immediate. 

      Otherwise, we know that $\judgebalance[\Gamma']{\gamma(x)}{\zero}$, and so by rule 
      \textsc{TCat}, we know that $\judgebalance[\Gamma']{\gamma(x)\cdot \rgt{b}}{\combine{\zero}{(1, 0)}}$. But
      we know $\bump{\lft{a}}{\zero} = (1, 0)$. 

      Furthermore, it is immediate that $\gamma(\deriv{\sigma}{\lft{a}\cdot x\cdot\rgt{b}}) = \gamma(x \cdot \rgt{b})$
    \end{case}
  \end{caseblock}
\end{proof}




Now, let's show that syntactic and semantic derivatives coincide. 

\begin{prop}{(Syntactic and Semantic Derivatives Coincide)}
For any  $\judgebalance{g}{d}$ and character $\sigma$ we have that
$\interp{\deriv{\sigma}{g}}\gamma = \semderiv{\sigma}{\interp{g}\gamma}$.
\end{prop}

\begin{proof}
  We proceed by induction of $g$: 

  \begin{caseblock}
    \begin{case}{$\sigma'$}
      There are two possibilities, depending on whether or not $\sigma = \sigma'$: 
      \begin{itemize}
        \item If $\sigma = \sigma'$, then $\interp{\deriv{\sigma}{\sigma}} = \interp{\epsilon} = \setof{\epsilon}$

          Furthermore, $\interp{\sigma} = \setof{\sigma}$, and $\semderiv{\sigma}{\setof{\sigma}} = \setof{\epsilon}$
        \item If $\sigma \not= \sigma'$, then $\interp{\deriv{\sigma}{\sigma'}} = \interp{\bot} = \emptyset$
          
          Furthermore, $\interp{\sigma'} = \setof{\sigma'}$, and $\semderiv{\sigma}{\setof{\sigma'}} = \emptyset$
      \end{itemize}
    \end{case}

    \begin{case}{$\epsilon$}
      $\interp{\deriv{\sigma}{\epsilon}} = \interp{\bot} = \emptyset = \semderiv{\sigma}{\setof{\epsilon}} = \semderiv{\sigma}{\interp{\epsilon}}$
    \end{case}

    \begin{case}{$g_1\cdot g_2$}
      We need to show that $\interp{\deriv{\sigma}{g_1\cdot g_2}} = \semderiv{\sigma}{\interp{g_1\cdot g_2}}$. 
      \begin{enumerate}
        \item By induction, we know that $\interp{\deriv{\sigma}{g_1}} = \semderiv{\sigma}{\interp{g_1}}$
        \item By induction, we know that $\interp{\deriv{\sigma}{g_2}} = \semderiv{\sigma}{\interp{g_2}}$
        \item We want that for all $s$, $s \in \interp{\deriv{\sigma}{g_1\cdot g_2}}$ if and 
          only if $s \in \semderiv{\sigma}{\interp{g_1\cdot g_2}}$. 
          \begin{itemize}
          \item The $\Leftarrow$ direction: 
            \begin{enumerate}
              \item Suppose $s \in \semderiv{\sigma}{\interp{g_1\cdot g_2}}$. 
              \item Then there exist $s_1$ and $s_2$ such that $\sigma\cdot s = s_1\cdot s_2$ and 
                $s_1 \in \interp{g_1}$ and $s_2 \in \interp{g_2}$. 
              \item Now, $s_1$ has either 0 or more elements. 
                \begin{itemize}
                  \item Suppose $s_1$ has length $0$. 
                    \begin{enumerate}
                      \item Then $s_1$ is the empty string, so $\epsilon \in \interp{g_1}$ and 
                            $s_2 = \sigma \cdot s$
                      \item From the emptiness lemma,  $\emptify{g_1} = \true$ 
                      \item From the induction hypothesis, $s \in \interp{\deriv{\sigma}{g_2}}$ 
                      \item Therefore $s \in \interp{\emptify{g_1}\cdot\deriv{\sigma}{g_2}}$
                      \item Therefore $s \in \interp{\deriv{\sigma}{g_1}\cdot g_2 \vee \deriv{\sigma}{g_2}}$
                  \end{enumerate}
                 \item Suppose $s_1$ has length $n \geq 1$ 
                   \begin{enumerate}
                     \item Then there exists $s'_1$ such that $s = s'_1 \cdot s_2$ and $s_1 = \sigma \cdot s'_1$. 
                     \item Therefore $s'_1 \in \semderiv{\sigma}{\interp{g_1}}$
                     \item By induction hypothesis $s'_1 \in \interp{\deriv{\sigma}{g_1}}$
                     \item Therefore $s = s'_1 \cdot s_2$ is in $\interp{\deriv{\sigma}{g_1}\cdot g_2}$
                     \item Therefore $s \in \interp{\deriv{\sigma}{g_1}\cdot g_2 \vee \IfThenElse{\emptify{g_1}}{\deriv{\sigma}{g_2}}{\bot}}$
                   \end{enumerate}
                \end{itemize}
            \end{enumerate}
          \item The $\Rightarrow$ direction: 
            \begin{enumerate}
              \item Suppose $s \in \interp{\deriv{\sigma}{g_1\cdot g_2}}$
              \item Therefore $s \in \interp{\deriv{\sigma}{g_1}\cdot g_2 \vee \IfThenElse{\emptify{g_1}}{\deriv{\sigma}{g_2}}{\bot}}$
              \item Therefore either $s \in \interp{\deriv{\sigma}{g_1}\cdot g_2}$ or 
                    $s \in \interp{\IfThenElse{\emptify{g_1}}{\deriv{\sigma}{g_2}}{\bot} }$
                \begin{itemize}
                  \item Suppose $s \in \interp{\deriv{\sigma}{g_1}\cdot g_2}$ 
                    \begin{enumerate}
                      \item Therefore there exist $s_1, s_2$ such that $s = s_1 \cdot s_2$ and 
                        $s_1 \in \interp{\deriv{\sigma}{g_1}}$ and $s_2 \in \interp{g_2}$
                      \item By induction hypothesis $s_1 \in \semderiv{\sigma}{\interp{g_1}}$
                      \item Therefore $\sigma \cdot s_1 \in \interp{g_1}$
                      \item Therefore $\sigma \cdot s_1 \cdot s_2 \in \interp{g_1 \cdot g_2}$
                      \item Therefore $s_1 \cdot s_2 \in \semderiv{\sigma}{g_1 \cdot g_2}$
                    \end{enumerate}
                  \item Suppose $s \in \interp{\IfThenElse{\emptify{g_1}}{\deriv{\sigma}{g_2}}{\bot} }$

                    We proceed by cases on $\emptify{g_1}$. 
                    \begin{itemize}
                    \item If $\emptify{g_1} = \true$: 
                        
                      Therefore $s \in \interp{\deriv{\sigma}{g_2}}\gamma$ 
                      
                      By induction $\sigma\cdot s \in \interp{g_2}\gamma$
                      
                      By emptiness, $\epsilon \in \interp{g_1}$
                      
                      Therefore $\epsilon\cdot\sigma\cdot s \in \interp{g_1\cdot g_2}\gamma$
                      
                      Therefore $s \in \semderiv{\sigma}{\interp{g_1\cdot g_2}\gamma}$ 
                    \item If $\emptify{g_2} = \false$: 

                         Therefore $s \in \interp{\bot}{\gamma} = \emptyset$

                         This is a contradiction, so this case is impossible.
                    \end{itemize}
                \end{itemize}
            \end{enumerate}
          \end{itemize}
      \end{enumerate}
    \end{case}

    \begin{case}{$g*$}
      By induction we know that $\interp{\deriv{\sigma}{g}}\gamma = \semderiv{\sigma}{\interp{g}\gamma}$.

      We want for all $s$, that $s \in \interp{\deriv{\sigma}{g}}\gamma \iff s \in \semderiv{\sigma}{\interp{g}\gamma}$. 
      \begin{itemize}
        \item $\Rightarrow$ direction: 

          Assume $s \in \interp{\deriv{\sigma}{g*}}\gamma$. 
          
          Therefore $s \in \interp{\deriv{\sigma}{g}\cdot(g*)}\gamma$. 

          So we know there are $s_1, s_2$ such that $s = s_1\cdot s_2$ and $s_1 \in \interp{\deriv{\sigma}{g}}\gamma$ and $s_2 \in \interp{g*}\gamma$. 
          
          Therefore $s_1 \in \semderiv{\sigma}{\interp{g}\gamma}$
          
          Therefore $\sigma\cdot s_1 \in \interp{g}{\gamma}$. 
          
          Therefore $(\sigma\cdot s_1)\cdot s_2 \in \interp{g*}\gamma$
          
          Therefore $s_1\cdot s_2 \in \semderiv{\sigma}{\interp{g*}\gamma}$. 
          
          Therefore $s \in \semderiv{\sigma}{\interp{g*}\gamma}$. 

        \item $\Leftarrow$ direction: 

          Assume $s \in \semderiv{\sigma}{\interp{g*}\gamma}$. 

          Therefore $\sigma\cdot s \in \interp{g*}\gamma$. 

          Therefore there exists $s_1, \ldots s_n \in \interp{g}\gamma$, such that $s_1\cdot\ldots s_n = \sigma\cdot s$, and without loss of generality, suppose $s_1$ is nonempty.  

          Then there is a $s'_1$, such that $s_1 = \sigma\cdot s'_1$. 

          Hence $s'_1 \in \semderiv{\sigma}{\interp{g}\gamma}$.

          Hence $s'_1 \in \interp{\deriv{\sigma}{g}}\gamma$. 

          By definition $s_2\cdot\ldots s_n \in \interp{g*}\gamma$. 

          Therefore $s'_1\cdot s_2\ldots s_n \in \interp{\deriv{\sigma}{g}\cdot(g*)}\gamma$. 
          
          Therefore $s \in \interp{\deriv{\sigma}{g*}}\gamma$
      \end{itemize}
    \end{case}

    \begin{case}{$g = \bot$}
      We want to show that for all $s$, $s \in \interp{\deriv{\sigma}{\bot}}\gamma = \semderiv{\sigma}{\interp{\bot}\gamma}$. 
      
      This is equivalent to showing $\emptyset = \emptyset$, which is immediate. 
    \end{case}

    \begin{case}{$g = g_1 \vee g_2$}

      By induction, we know that $\interp{\deriv{\sigma}{g_1}} = \semderiv{\sigma}{\interp{g_1}}$

      By induction, we know that $\interp{\deriv{\sigma}{g_2}} = \semderiv{\sigma}{\interp{g_2}}$

      We want to show that for all $s$, $s \in \interp{\deriv{\sigma}{g_1 \vee g_2}}\gamma \iff s \in \semderiv{\sigma}{\interp{g_1 \vee g_2}}\gamma$.

      Assume $s$. We can reason as follows: 

      \begin{mathpar}
        \begin{array}{lcl}
          s \in \interp{\deriv{\sigma}{g_1 \vee g_2}}\gamma
          & \iff & s \in \interp{\deriv{\sigma}{g_1} \vee \deriv{\sigma}{g_2}}\gamma \\
          & \iff & s \in \interp{\deriv{\sigma}{g_1}}\gamma \cup \interp{\deriv{\sigma}{g_2}}\gamma \\
          & \iff & s \in \semderiv{\sigma}{\interp{g_1}\gamma} \cup \semderiv{\sigma}{\interp{g_2}\gamma} \\
          & \iff & s \in \semderiv{\sigma}{\interp{g_1}\gamma} \cup \semderiv{\sigma}{\interp{g_2}\gamma} \\
          & \iff & \sigma\cdot s \in \interp{g_1}\gamma \cup \interp{g_2}\gamma \\
          & \iff & \sigma\cdot s \in \interp{g_1 \vee g_2}\gamma \\
          & \iff & s \in \semderiv{\sigma}{\interp{g_1 \vee g_2}\gamma} \\
        \end{array}
      \end{mathpar}
    \end{case}

    \begin{case}{$g = \lft{a}\cdot x \cdot\rgt{b}$}
      If $\sigma \not= \lft{a}$, then $\deriv{\sigma}{g} = \bot$ and the result is immediate. 

      Otherwise, we want to show for any $s$, that $s \in \interp{\semderiv{\lft{a}}{\lft{a}\cdot x \cdot\rgt{b}}}\gamma \iff s \in \semderiv{\lft{a}}{\interp{\lft{a}\cdot x \cdot\rgt{b}}\gamma}$. 

      Assume $s$, and reason as follows: 
      \begin{mathpar}
        \begin{array}{lcl}
          s \in \interp{\deriv{\lft{a}}{\lft{a}\cdot x \cdot\rgt{b}}}\gamma 
          & \iff & s \in \interp{x \cdot\rgt{b}}\gamma  \\
          & \iff & \lft{a}\cdot s \in \comprehend{\lft{a}\cdot s'}{s' \in \interp{x \cdot\rgt{b}}\gamma}  \\
          & \iff & \lft{a}\cdot s \in \comprehend{s''\cdot s'}{s'' \in \setof{\lft{a}} \land s' \in \interp{x \cdot\rgt{b}}\gamma}  \\
          & \iff & \lft{a}\cdot s \in \comprehend{s''\cdot s'}{s'' \in \interp{\lft{a}}\gamma \land s' \in \interp{x \cdot\rgt{b}}\gamma}  \\
          & \iff & \lft{a}\cdot s \in \interp{\lft{a}\cdot x \cdot \rgt{b}}\gamma \\
          & \iff & s \in \semderiv{\lft{a}}{\interp{\lft{a}\cdot x \cdot \rgt{b}}\gamma} \\
        \end{array}
      \end{mathpar}
    \end{case}

    \begin{case}{$\fix{x}{g}$}
      By induction, we know that for all $\gamma'$ for $\Gamma,x$ , $\interp{\deriv{\sigma}{g}}\gamma' = \semderiv{\sigma}{\interp{g}\gamma'}$

      \begin{math}
        \begin{array}{lcl}
          s \in \interp{\deriv{\sigma}{\fix{x}{g}}}\gamma 
          & \iff & s \in \interp{\deriv{\sigma}{g}[\fix{x}{g}/x]}\gamma \\
          & \iff & s \in \interp{\deriv{\sigma}{g}}(\gamma, \interp{\fix{x}{g}}\gamma) \\
          & \iff & s \in \semderiv{\sigma}{\interp{g}(\gamma, \interp{\fix{x}{g}}\gamma)} \\
          & \iff & \sigma\cdot s \in \interp{g}(\gamma, \interp{\fix{x}{g}}\gamma) \\
          & \iff & \sigma\cdot s \in \interp{\fix{x}{g}}\gamma \\
          & \iff & s \in \semderiv{\sigma}{\interp{\fix{x}{g}}\gamma} \\
        \end{array}
      \end{math}
    \end{case}
  \end{caseblock}
\end{proof}



\section{Nondeterministic Brzozowski Derivatives}

Now, our definition is sound, in the sense that it means the right
thing. Unfortunately, it won't give us a finite set of derivatives. 
For example,  consider the grammar $\fix{x}{\epsilon \vee \lft{a} i \rgt{b}}$. 
When we  differentiate with respect to $\lft{a}$, the result is equivalent to 
\begin{mathpar}
(\fix{x}{\epsilon \vee \lft{a} i \rgt{b}}) \cdot \rgt{b}
\end{mathpar}

\noindent When we differentiate this again, we get
\begin{mathpar}
(\fix{x}{\epsilon \vee \lft{a} i \rgt{b}}) \cdot \rgt{b} \cdot \rgt{b}  
\end{mathpar}

\noindent and so on for arbitrary $n$-fold derivatives.  Of course,
this shouldn't be terribly surprising --- if we try to interpreting
expressions as states, we \emph{should} founder on the fact there's no
finite state machine that can recognize this language!

So what we need to do is find some generalization of the notion of
derivative, from which we some kind of stack machine will fall out in
the same way that finite-state automata fall out of derivatives of
regular expressions. To do this, we'll proceed in two steps. First,
we'll give a generalized version of the Brzozowski derivative
algorithm, and then show how to construct a stack machine from it.

In Brzozowski's derivative algorithm, the states of a state machine
recognizing a regular language are identified with regular expressions
which describe the language recognizable from that state. In our case,
this simple intuition is not quite powerful enough. A recursive
grammar cannot be recognized with a finite state machine, and so the
derivatives ought to correspond to the state and the stack of a
push-down automaton.


\begin{definition}{(Finite Base)}
We say a grammatical expression $g$ is derived from a basis set $G$,
when $G$ is a finite set of grammatical expressions, and $g$ is
equivalent to a sum of concatenations of elements of $G$. That is, $g$
should be generated (up to $\simeq$) via the following grammar, where
$g$ ranges over elements of $G$.
\begin{mathpar}
  \begin{array}{llcl}
    T_G & t & ::= & \epsilon \bnfalt t \cdot t' \bnfalt \bot \bnfalt t \vee t' \bnfalt g \in G
  \end{array}
\end{mathpar}

We say a grammatical expression $g$ is based in $G$, when for all $s$, if 
whenever $\deriv{s}{g}$ exists, it is also derived from the basis set $G$.
\end{definition}

Now, define the \emph{height} of a basis expression as follows: 

\begin{mathpar}
  \begin{array}{lcl}
    \depth{b}            & = & 1 \\
    \depth{\epsilon}     & = & 0 \\
    \depth{\rgt{b}}      & = & 1 \\
    \depth{t_1\cdot t_2} & = & \depth{t_1} + \depth{t_2} \\
    \depth{\bot}         & = & 0 \\ 
    \depth{t_1 \vee t_2} & = &  \max(\depth{t_1}, \depth{t_2}) \\
  \end{array}
\end{mathpar}

\begin{mathpar}
  \begin{array}{lcl}
    \pieces{\sigma}       & = & \setof{\sigma} \\
    \pieces{\epsilon}     & = & \emptyset \\
    \pieces{g_1\cdot g_2} & = & \pieces{g_1} \cup \pieces{g_2} \\
    \pieces{\bot}         & = & \emptyset \\
    \pieces{g_1 \vee g_2} & = & \pieces{g_1} \cup \pieces{g_2} \\
    \pieces{g*}           & = & \pieces{g} \cup \pieces{g*} \\
    \pieces{x}            & = & \setof{x} \\
    \pieces{\fix{x}{g}}   & = & \pieces{g} \cup \setof{\fix{x}{g}} \\
  \end{array}
\end{mathpar}


\begin{prop}{(The Set of Derivatives Is Finitely Based)}

For any $\judgebalance{\Gamma}{g}{\zero}$ there is a finite set $G$ of
$\Gamma$-typed terms such that for any grounding substitution $\gamma$
for $\Gamma$ based in any $X$, $\gamma(g)$ is based in $\gamma(G) \cup
X$. Furthermore, for any string $s$ of depth $-d$, the derivative
$\deriv{s}{g}$ is equivalent to a basis expression of height $d + 1$.
\end{prop}

\begin{proof}
\begin{caseblock}
  \begin{case}{$g = \epsilon$}
    Let $G = \emptyset$. If $s$ is the empty string, 
    then $D_\epsilon(\epsilon) = \epsilon$. If it is nonempty, then $D_{c\cdot s'}(\epsilon) = \bot$. 
    The maximum height in this case is 1. 
  \end{case}

  \begin{case}{$g = \sigma$}
    Let $G = \setof{\sigma}$. If $s$ is empty, the derivative is $\sigma$. 
    If $s$ is $\sigma$, the derivative is $\epsilon$. Otherwise, it is $\bot$. 
    The maximum size in this case is at most 1. 
  \end{case}

  \begin{case}{$g = \bot$}
    Let $G = \emptyset$. All derivatives of $\bot$ are $\bot$. 
    The maximum height in this case is at most 1. 
  \end{case}

  \begin{case}{$g = g_1 \vee g_2$}
    Let $G_1$ and $G_2$ be the basis sets of $g_1$ and $g_2$. Then, we know 
    that $\deriv{s}{\gamma(g_1 \vee g_2)} = \deriv{s}{\gamma(g_1)} \vee \deriv{s}{\gamma(g_2)}$. Since
    $\deriv{s}{g_1}$ is finitely based in $\gamma(G_1) \cup X$ and $\deriv{s}{g_2}$ is finitely based in $\gamma(G_2) \cup X$, 
    it follows that $\deriv{s}{g_1} \vee \deriv{s}{g_2}$ is finitely based in $\gamma(G) \cup X$. 

    Similarly, if $s$ has depth $-d$, then $\deriv{s}{g_1}$ has a height of at most $d + 1$,
    as does $\deriv{s}{g_2}$. Hence $\deriv{s}{g_1} \vee \deriv{s}{g_2}$ does too, and this is 
    equivalent to $\deriv{s}{g_1 \vee g_2}$. 
  \end{case}

  \begin{case}{$\judgebalance{g_1\cdot g_2}{d}$}
    By inversion, we know that $\judgebalance{g_1}{d_1}$ and $\judgebalance{g_2}{d_2}$.
    
    By induction we have $G_1$ and $G_2$ as finite bases for $\gamma(g_1)$ and $\gamma(g_2)$. 
    
    Take $G = \comprehend{g\cdot g_2}{g \in G_1 } \cup G_2$. 

    Now let $\gamma$ be a grounding substitution based in $X$. Then 
    $\gamma(G_1) \cup X$ is a basis for $\gamma(g_1)$ and $\gamma(G_2)$ is a basis
    for $\gamma(g_2) \cup X$. 

    Now we proceed by induction on the length of an arbitrary string $s$. 
    
    If the string is empty, then the derivative is equal to $g_1\cdot
    g_2$. Because of the finite basis property, there is an expression
    $t_1$ equivalent to $g_1$ generated from from $\gamma(G_1) \cup
    X$. Then, by induction on $t_1$, we can show that there is a term
    equivalent to $t_1 \cdot g_2$ derived from the basis $\gamma(G_1
    \cup G_2) \cup X$.

    If the string is nonempty, it is of the form $s = \sigma\cdot s'$. 

    Therefore 
    \begin{mathpar}
      \begin{array}{lcl}
        \deriv{s}{g_1\cdot g_2} 
        & = & \deriv{s'}{\deriv{\sigma}{g_1\cdot g_2}} \\
        & = & \deriv{s'}{\deriv{\sigma}{g_1}\cdot g_2 \vee \IfThenElse{\emptify{g_1}}{\deriv{\sigma}{g_2}}{\bot}}\\
        & \simeq & \deriv{s'}{t'_1\cdot g_2 \vee \IfThenElse{\emptify{g_1}}{t_2}{\bot}}\\
      \end{array}
    \end{mathpar}

    Now, note that $t'_1 \simeq \deriv{\sigma}{g_1}$ is based in
    $\gamma(G_1) \cup X$, and $t'_2 \simeq \deriv{\sigma}{g_2}$ is
    based in $\gamma(G_2) \cup X$.  Then, by induction on $t'_1$, we
    can see that there is a $t \simeq t'_1 \cdot g_2$ based in
    $\comprehend{g\cdot g_2}{g \in G_1} \cup X$. Then by induction 
    we know that the whole thing is based in $G$. 

    Next, suppose we have a string of depth $-d$. 

    If $s = \epsilon$, then we know that $d = 0$. We know that there is a
    $t_1 \simeq g_1$ based in $\gamma(G_1) \cup X$ of height 1, and then by 
    induction we can establish that there is a $t \simeq t_1\cdot g_2$. 
  \end{case}

  \begin{case}{$\judgebalance{g'*}{\zero}$}
    By inversion we have $\judgebalance{g'}{\zero}$.
    
    By induction we have $G'$ such that for all $\gamma$ grounding $\Gamma$ 
    based in all $X$, $\gamma(g')$ is based in $\gamma(G') \cup X$. 

    Take $G$ to be $G' \cup g'*$. 

    Now assume that we have $\gamma$ grounding $\Gamma$ based in $X$. 

    Now suppose we have some string $s$. If it is empty, then obviously 
    $\gamma(g'*) \in \gamma(G)$. Otherwise, the string is $s = \sigma\cdot s'$
    for some $s'$. Then:
    \begin{mathpar}
      \begin{array}{lcl}
        \deriv{s}{\gamma(g'*)} 
         & = & \deriv{s}{(\gamma(g'))*} \\
         & = & \deriv{s'}{\deriv{\sigma}{(\gamma(g'))*}} \\
         & = & \deriv{s'}{\deriv{\sigma}{\gamma(g')}\cdot\gamma(g')*} \\
      \end{array}
    \end{mathpar}
    By hypothesis $\deriv{\sigma}{\gamma(g')}$ is derived from $\gamma(G) \cup X$, 
    and likewise for $\gamma(g')$. Hence every derivative of this is also based 
    in $\gamma(G) \cup X$. 
  \end{case}

  \begin{case}{$g = \fix{x}{g'}$}
    By hypothesis, we have $\judgebalance{\fix{x}{g'}}{\zero}$.

    By inversion, we know that $\judgebalance[\Gamma, x]{g'}{\zero}$. 

    As induction hypothesis, we have a set $G'$ such that for all $\gamma'$ for $\Gamma,x$ 
    we have $\gamma'(g')$ is based in $\gamma'(G')$. 

    Let $G = G'[\fix{x}{g'}/x] \cup \setof{\fix{x}{g'}}$. 

    Suppose we have a grounding substitution $\gamma$ for $\Gamma$ finitely based in $X$. 

    Now, we want to show that $\gamma(g)$ is finitely based in $\gamma(G) \cup X$.  

    First, observe that if we let $\gamma' = \gamma, \gamma(\fix{x}{g})$, then $\gamma'(g')$
    is based in $\gamma'(G')$, which is a subset of $\gamma(G)$. 

    Now, consider an arbitrary string $s$. If it is empty, then $\deriv{\epsilon}{\gamma(g))} = g \in \gamma(G)$. 

    Otherwise, $s = \sigma\cdot s'$. Now observe that 
    \begin{mathpar}
      \begin{array}{lcl}
        \deriv{s}{\gamma(\fix{x}{g'})} 
        & = & \deriv{s'}{\deriv{\sigma}{\gamma(\fix{x}{g'})}} \\
        & = & \deriv{s'}{\deriv{\sigma}{\gamma(g')}[\gamma(\fix{x}{g'})/x]} \\
        & = & \deriv{s'}{\deriv{\sigma}{\gamma'(g')}} \\
      \end{array}
    \end{mathpar}

    Since we know that $\deriv{\sigma}{\gamma'(g')}$ is derived from
    the basis $\gamma'(G') \cup X$, we know that 
    $\deriv{s'}{\deriv{\sigma}{\gamma'(g')}}$ is also derived from the
    basis $\gamma'(G') \cup X$, and hence is derived from $\gamma(G) \cup X$. 
  \end{case}

  \begin{case}{$\judgebalance{\lft{a}x\rgt{b}}{\zero}$}
    In this case, let $G = \setof{\lft{a}, \rgt{b}}$. 

    Now, suppose we have a grounding substitution $\gamma$ based in $X$. 

    Now suppose that we have an arbitrary string $s$. 

    If $s$ is empty, the derivative is the trivial $\lft{a}\cdot\gamma(x)\cdot\rgt{b}$. 
    Since $\gamma(x)$ is based in $X$, there is some derivation of it from $X$ -- call
    it $g_x$. Then $\lft{a}\cdot g_x \cdot \rgt{b}$ is based in $G \cup X$. 

    If $s$ is non-empty, then it is some string $\sigma\cdot s'$. If $\sigma$ is 
    not $\lft{a}$, then this is trivial. Otherwise, we have 
    \begin{mathpar}
      \begin{array}{lcl}
        \deriv{s}{\lft{a}\cdot g_x \cdot \rgt{b}} 
        & = & \deriv{s'}{\deriv{\lft{a}}{\lft{a}\cdot g_x \cdot \rgt{b}}} \\
        & = & \deriv{s'}{g_x \cdot \rgt{b}} \\
      \end{array}
    \end{mathpar}
  \end{case}
    
  Since both $g_x$ and $\rgt{b}$ are based in $G \cup X$, all their derivatives
  are based in $G \cup X$. 
\end{caseblock}
\end{proof}


In fact, we actually need a stronger theorem than the above. 






\end{document}
