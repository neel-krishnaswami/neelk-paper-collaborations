\chapter{Verifying Interactive Programs}

\section{Introduction}

In many interactive programs, there are mutable data structures which
change over time, and which must maintain some relationships with one
another. For example, in a web browser, we need to present a web page
both as a tree data structure for scripts to manipulate, and display a
graphical image for the human user to view. Any change made to the
tree by a script must be reflected in a change to the image that the
human sees --- the two structures must remain synchronized.

Likewise, in a spreadsheet, each cell contains a formula, which may
refer to other cells, and whenever the user changes a cell, all of the
cells which transitively depend upon it must be updated. Since
spreadsheets can get very large, this should ideally be done in a lazy
way, so that only the cells visible on the screen, and the cells
necessary to compute them, are themselves recomputed.

Typically, these dependencies are written using what is called the
\emph{subject-observer} pattern. A mutable data structure (the
subject) maintains a list of all of the data structures whose
invariants depend upon it (the observers), and whenever it changes, it
calls a function on each of those observers to update them in response
to the change. (And in turn, the observers of the subject may be
subjects of still other observers, ultimately forming DAGs of
notifications.)

While natural, these programs are very challenging to verify in a
modular way. The reason is that there are two directions of
dependency, both of which matter for program proof. First, our program
invariant must have ownership over the subject's data (its
\emph{footprint}) in order to prove the correctness of code modifying
the subject. This direction of ownership is natural to verify with
separation logic.

However, we must explicitly maintain the \emph{other} direction of
dependency as well --- we track everything which depends upon the
subject, and modify them appropriately whenever the subject changes.
However, the natural program invariant now becomes a global property:
we need to know the full dependency graph covering all subjects and
observers, so that we can say that the reads and is-read-by relations
are relational transposes of one another. The global nature of this
invariant means that a naive correctness proof will not respect the
modular structure of the program --- if we modify the dependency graph
in any way, we now have to re-verify the entire program!

However, the intention of the subject-observer pattern is precisely to
allow the program to remain oblivious to the exact number and nature
of the observers, which allows the programmer to add new observers
without disturbing the behavior of the rest of the program.  Our goal,
then, is to find a way of taking this piece of practical software
engineering wisdom, and casting it into formal terms amenable to
proof.

Concretely, our contributions are as follows: 

\begin{itemize}
  \item We define a library with a monadic API for writing
    demand-driven computations with dynamic dependencies and local
    state, and which is implemented as higher-order functions
    dynamically creating networks of imperative callbacks.

    We then give an ``abstract semantics'' for this
    library, structured as a set of separation logic lemmas about our
    dataflow library. These lemmas permit \emph{modular} correctness
    proofs about programs using this API, even in the face of the fact
    that the program invariants must be defined globally upon the
    whole callback network.

    The key idea is to distinguish between the direct footprint of a
    command, and the program state which can depends upon that
    footprint. The lemmas are then phrased so that they refer only to
    the direct footprint of each command in the API. In addition, we
    structure our lemmas to justify an unusual frame property for our
    abstract semantics, which we can use to verify different parts of
    an imperative dataflow network separately.

    Unlike typical frame properties, the frame in our frame rule is
    not the same in the pre- and the post-states. Instead, the two
    sides of the frame are related by a \emph{ramification operator}
    (so named in analogy to the ``ramification problem'' in AI), which
    explains how local changes can alter our knowledge of the rest of
    the heap.

  \item To illustrate the utility of this proof technique, we verify
    an imperative implementation of combinators implementing stream
    transducers in the style of functional reactive programming. 

    Ultimately, clients can reason about the behavior of the imperative
    implementation ``as if'' it were purely functional, even though it
    is implemented using local state and imperative callback
    procedures.
\end{itemize}

\section{Demand-Driven Notification Networks}

A simple intuition for a ``demand-driven notification network'' is to
think of it as a generalized spreadsheet. We have a collection of
cells, each of which contain program expressions whose evaluation may
refer to other cells. When a cell is read, the expression within the
cell is evaluated, possibly triggering the evaluation of other cells
in a cascade. Furthermore, each cell memoizes its expression, so that
repeated reads won't trigger re-evaluation, and maintains a set of
dependencies so that when the code within a cell is changed, it and
everything that depends on it invalidates the memoized value.

\subsection{Implementing Notification Networks}

\begin{figure}
\mbox{}
\begin{specification}
\nextline $\codetype{A} = \monad{(A \times \cellset)}$ \nextline[1em]
$\celltype{A} = \{$\=$code: \reftype{\codetype{A}};$ \nextline
                   \>$value: \reftype{\opttype{A}};$ \nextline
                   \>$reads: \reftype{\cellset};$ \nextline
                   \>$obs:   \reftype{\cellset}\;$ \nextline
                   \>$id:    \N\}$ \nextline[1em]

$ecell = \exists \alpha:\star.\; \celltype{\alpha}$ \nextline[1em]

$\ctext{return} : \forall \alpha:\star.\; \alpha \to \codetype{\alpha}$ \nextline
$\ctext{return}\;x = \comp{\pair{x}{\ctext{emptyset}}}$ \nextline[1em]

$\ctext{bind} : \forall \alpha,\beta:\star.\; \codetype{\alpha} \to (\alpha \to \codetype{\beta}) \to \codetype{\beta}$ \nextline
$\ctext{bind}\;e\;f = [$\=$\letv{(v,r_1)}{e}{}$ \nextline
                        \>$\letv{(v',r_2)}{f\;v}{}$ \nextline
                        \>$\;\pair{v'}{\ctext{union}\;r_1\;r_2}]$\nextline[1em]

$\ctext{read} : \forall \alpha:\star.\; \celltype{\alpha} \to \codetype{\alpha}$ \nextline
$\ctext{read}\;a = [$\=$\letv{o}{\comp{!a.value}}{}$ \nextline
                     \>$\ctext{run}\;\ctext{case}(o,$ \nextline
                     \>\qquad\= $\ctext{Some}\;v \to \comp{\pair{v}{\ctext{singleton}\;a}},$ \nextline
                     \>      \> $\ctext{None} \to [$\=$\letv{exp}{\comp{!a.code}}{}$ \nextline
                     \>      \>                     \>$\letv{(v,r)}{exp}{}$ \nextline
                     \>      \>                     \>$\letv{\_}{\comp{a.value := v}}{}$\nextline
                     \>      \>                     \>$\letv{\_}{\comp{a.reads := r}}{}$ \nextline
                     \>      \>                     \>$\letv{\_}{\ctext{setiter}\;(\ctext{add\_observer}\;a)\;r}{}$ \nextline
                     \>      \>                     \>$\;\pair{v}{\ctext{singleton}\;a}])$ \nextline[1em]

$\getref : \forall \alpha : \reftype{\alpha} \to \codetype{\alpha}$ \nextline
$\getref r = \comp{\letv{v}{\comp{!r}}{\pair{v}{\ctext{emptyset}}}}$ \nextline[1em]

$\setref : \forall \alpha : \reftype{\alpha} \to \alpha \to \codetype{\unittype}$ \nextline
$\setref r\;v = \comp{\letv{dummy}{\comp{r := v}}{\pair{\unit}{\ctext{emptyset}}}}$ \nextline[1em]

$\newcell : \forall \alpha:\star.\; \codetype{\alpha} \to \monad{\celltype{\alpha}}$ \nextline
$\newcell\;\alpha\;code = [$\=$\letv{id}{!counter}{}$ \nextline
                                   \>$\letv{\_}{\comp{counter := n + 1}}{}$ \nextline
                                   \>$\letv{code}{\newref{\codetype{\alpha}}{code}}{}$ \nextline
                                   \>$\letv{value}{\newref{\opttype{\alpha}}{\ctext{None}}}{}$ \nextline
                                   \>$\letv{reads}{\newref{\cellset}{\ctext{emptyset}}}{}$ \nextline
                                   \>$\letv{obs}{\newref{\cellset}{\ctext{emptyset}}}{}$ \nextline
                                   \>$\; (code, value, reads, obs, id)]$ 
\end{specification}
\caption{Implementation of Notification Networks}
\label{notification-implementation}
\end{figure}

\begin{figure}
\mbox{}
\begin{specification}
\nextline
$\updatecell : \forall \alpha:\star.\; \codetype{\alpha} \to \celltype{\alpha} \to \monad{\unittype}$\nextline
$\updatecell\;\alpha\;exp\;a = 
     [$\=$\letv{\_}{\ctext{mark\_unready}\;\pack{\alpha}{a}}{}$ \nextline
       \>$a.code := exp]$ \nextline[1em]

$\ctext{mark\_unready} : ecell \to \monad{\unittype}$ \nextline
$\ctext{mark\_unready}\;cell =\; $\=$\ctext{unpack}(\alpha, a) = cell\; \ctext{in}$\nextline
\>  $[$\=$\letv{os}{\comp{!a.obs}}{}$ \nextline
\>     \>$\letv{rs}{\comp{!a.reads}}{}$ \nextline
\>     \>$\letv{\_}{\ctext{iterset}\;\ctext{mark\_unready}\;os}{}$ \nextline
\>     \>$\letv{\_}{\ctext{iterset}\;(\ctext{remove\_obs}\;cell)\;rs}{}$ \nextline
\>     \>$\letv{\_}{\comp{a.value := \ctext{None}}}{}$ \nextline
\>     \>$\letv{\_}{\comp{a.reads := \ctext{emptyset}}}{}$ \nextline
\>     \>$a.obs   := \ctext{emptyset}]$ 
\end{specification}
\caption{Implementation of Notification Networks}
\label{notification-implementation-update}
\end{figure}

Our API for creating notification networks is given in
Figure~\ref{notification-implementation}. First, we'll describe
the interface, and then discuss its implementation. 

The interface exposes two basic abstract data types, $\ctext{cell}$
and $\ctext{code}$.

The type $\celltype{A}$ is the type of dynamic data values. A cell
contains a reference to a piece of code, a possible memoized value,
plus enough information to correctly invalidate its memoized value
when the cell's dependencies change. We can create a new cell by
calling $\newcell e$, which returns a brand new cell with the
code expression $e$ inside it. We can also modify a cell with 
the command $\updatecell\;cell\;exp$, which modifies the cell
$cell$ by installing the new expression $exp$ in it. 

The type $\codetype{A}$ is a monadic type, representing the type of
computations that can read cells. It supports the usual operations
$\return e$ and $\bind e\; (\semfun{x}{e'})$, which embed a pure value
into the $\ctext{code}$ type and implement sequential composition,
respectively. In addition, the primitive operations on this monad 
include reading a cell with the $\readcell cell$ function call, and 
reading and modifying local state with the $\getref r$ and $\setref r\;v$
operations. 
 
The actual implementation is also given in
Figure~\ref{notification-implementation}. The abstract type of code is
implemented using the underlying monad of imperative commands, so that
$\codetype{A}$ is implemented with the type $\monad{(A \times
  \cellset)}$.  The intuition is that when we evaluate a term we are
allowed to read some cells along the way, and so must return a set of
all the cells that we read in order to do proper dependency
management. So, $\cellset$ is a type representing sets of
(existentially-quantified) cells.  (The precise specification of
$\cellset$ is given in Appendix A, since describing it is a
distraction from the main development.)

Cells are represented with a 5-tuple. There is a reference pointing to
the code expression, as well as a value field pointing to an optional
value. The value field will be set to $\ctext{None}$ if the cell is in
an unready, un-memoized state, and will be $\ctext{Some}\;v$ if the
cell's code has already been evaluated to a value $v$. In addition there are
two fields representing the dependencies. If the code expression has
been evaluated and a memoized value generated, then the $reads$ field
will point to the set of cells that the computation directly read
while computing its value. Otherwise it will point to the empty
set. Conversely, the field $obs$ contains the cell's observers --- the
set of cells that have read the current cell as part of their own
computations. Obviously, this is only non-empty when the cell has been
evaluated. Finally, each cell also has an integer id field, which is a
unique numeric identifier for every cell that is created by the
library. It allows us to compare cells (even of different type) for
equality, which is needed for dependency management.

The $\return$ operation for the library simply returns its argument
value and the empty set, since it doesn't read any cells. Likewise,
$\bind e\;f$ will evaluate the first argument and pass the returned
value to the function $f$. It will return the function's return value,
together with the union of the two read sets. $\getref r$ and $\setref r\;v$
simply read and update the reference, and return empty read sets, since
neither of them read any cells. 

Interesting things first happen with the $\readcell e$ operation. This
function will first check to see if the cell has a memoized value
ready. If it does, we return that immediately. Otherwise, we evaluate
the cell's code, and update the current cell's value and read set. In
addition, each cell that was read in the evaluation of the code (i.e.,
the set returned as the second component of the monadic type's return
value) also has its observer set updated with the newly-ready current
cell. Now, if any of the dependencies change, they will be able to
invalidate the current cell, which observes them. Note that the
dependencies between cells are all dynamic --- we cannot examine the
inside of a code expression to find its ``free cells'', and so we rely
upon the invariant that a code expression will return every cell it
read, in addition to its return value.

Further interesting things happen with the $\newcell\;cmd$
operation.  It creates a new cell value, setting the code field with
the argument $cmd$, and generating an id by dereferencing and
incrementing the variable $counter$. The $counter$ variable occurs
freely in this definition, because it is a piece of state global to
this module, and must be initialized by whatever initialization
routine first constructs the whole module as an existential package.
Since $counter$ is otherwise private, we can generate unique
identifiers by incrementing it as we create new cells. 

Finally, the $\updatecell\;cell\;cmd$ operation updates a cell
$cell$ with a new code expression $cmd$. (As an aside, it's worth
noting that this is a genuine, unavoidable, use of higher-order store:
we make use of pointers to code, including the ability to dynamically
modify them.) Once we modify a cell, any memoized value it has is no
longer necessarily correct.

Therefore, we have to drop the memoized value of the cell, and any
cell that transitively observes the cell. This is what the
$\ctext{mark\_unready}$ function does. Given a cell, it takes all of the
observers of the current cell and recursively makes all of
them unready. Then it removes the current cell from the observer sets of
all the cells it reads, and then it nulls out the current cell's
memoized value, as well as setting its read and observer sets to
empty. Notice that there is no explicit base case to the recursive
call; if there are any cycles in the dependency graph, invalidation
could go into an infinite loop. 

So far, we have described the implementation invariants incrementally.
Before proceeding to describe them formally, we will state them again
informally, all in one place:

\begin{itemize}
  \item Every cell must have a unique numeric identifier
  \item Every cell is either ready, or unready. 
  \item Every ready cell has a memoized value, and maintains 
    two sets, one containing every cell that it reads, and the
    other containing every cell it is observed by. 
  \item Every unready cell has no memoized value, and has 
    both an empty read set and an empty observer set. 
  \item The overall dependency graph among the valid cells must form a
    directed acyclic graph. 
  \item The reads and the observers must be the same, only 
    pointing in opposite directions.
\end{itemize}

Formalizing these constraints is relatively straightforward, but we
have the problem that these constraints are global in nature:
we can't be sure that the dependency graph is acyclic without having
it all available to examine, and likewise we can't in general know
that a cell is in the read set of everything in its observed set
without knowing the whole graph. Handling this difficultly is one of
the primary contributions of this work. 

\section{The Abstract Semantics of Notifications}

\subsection{The Structure of the Global Invariant}

The key to getting around our difficulties lies in the difference
between the implementation of $\updatecell$, and of $\ctext{read}$.
$\updatecell$ calls $\ctext{mark\_unready}$, which recursively follows
the observers. The $\ctext{read}$ function, on the other hand,
proceeds in the opposite direction --- it evaluates code expressions,
recursively descending into the footprint of its command. The opposite
direction these two functions look is why we end up needing a global
invariant: we need to know that these two directions are in harmony
with one another.

Now, note that the type of $\ctext{mark\_unready}$ is simply the monadic
type $\monad{\unittype}$, which precludes it from being called from within
a $\codetype{A}$. This means that when we are evaluating a code
expression, we will never actually follow the observer fields --
we'll only patch them as needed, whenever we evaluate a
cell and change it from unready to ready.  As a result, an abstract
description of the heap which \emph{does not explicitly mention
the observer sets} will prove sufficient for reasoning about
the behavior of $\codetype{A}$ expressions.

With this plan, we introduce \emph{abstract heap formulas}, which are
syntactic descriptions of the state of part of the cell heap. These
syntactic expressions are given by the following grammar:
\begin{displaymath}
  \begin{array}{lcl}
    \phi & ::= & I \bnfalt \phi \otimes \psi \bnfalt \cellpos{a}{e}{v}{r} \bnfalt \cellneg{a}{e}\\
         &  |  & \localref{r}{v} 
  \end{array}
\end{displaymath}

Informally, a formula $I$ represents an empty abstract heap, and a
formula $\phi \otimes \psi$ represents an abstract heap that can be
broken into two disjoint parts $\phi$ and $\psi$. We will only
consider formulas modulo the associativity and commutativity of
$\otimes$, and take $I$ to be the unit of this binary operator.

The atomic form $\localref{r}{v}$ says that $r$ is a piece of local
state owned by the network, currently with value $v$. There are two
atomic forms representing cells. $\cellneg{a}{e}$ says that $a$ is a
cell with code $e$, which is unready to deliver a value --- it needs
to be re-evaluated before it can yield a value. $\cellpos{a}{e}{v}{r}$
says that $a$ is a cell with code $e$, and that may be ready to deliver
the value $v$, assuming that all the cells in its read set $r$ are themselves
ready. If anything it reads is known to be unready, then it is unready
itself. (We will sometimes write $\celleither{a}{e}$ when we do not care
whether $a$ is ready or not.)

First, notice the must/may flavor of this reading. The formula
$\cellneg{a}{e}$ says that $a$ \emph{must} be unready.  The formula
$\cellpos{a}{e}{v}{r}$ says that $a$ \emph{may} have be ready,
conditional on the readiness of the elements of its read set
$r$. Second, notice that the backwards dependencies are entirely
missing from these formulas. We have simply left out the other half of
the dependency graph from this description. Forgetting this
information will be critical for local reasoning.

We have emphasized that the straightforward invariant is not obviously
modular. Before we can elaborate any further on this point, we will
need to look at the formal statement of the heap invariant. We
introduce the predicate $G(\phi)$, which describes the entire heap of
cells allocated by our library, and which satisfy both the conditions
described in the previous section, and the additional constraint that
the cell heap agree with $\phi$.\footnote{This is why we insisted that
  the abstract heap formulas are syntactic objects --- this permits us
  to define predicates on them by induction over the structure of the
formula.}


\begin{tabbing}
    $G(\phi) \triangleq \exists H \in CellHeap.\; Inv(H, \phi)$ \\ [1em]

$Inv(H, \phi) \triangleq $ \\
\;\;\= $$\=$ R_H^\dagger = O_H \land R_H^+ \mbox{ strict partial order }$ \\
    \> \> $\land\; R_H \subseteq V_H \times V_H \land unique(H)$ \\
    \> \> $\land\; \satisfies{H}{\phi} \land heap(H)$ \\
\end{tabbing}

The auxiliary definitions we used in this definition are all given in
Figure~\ref{heap-invariant}. 

We first assert the existence of a cell heap $H$, which is a
collection of cells, together with a function mapping each cell to a
code expression, a possible value, a read set, an observed set, and an
identifier, which satisfies the overall invariant $Inv$.

In the first two lines of $Inv(H, \phi)$, we assert all of the global 
conditions in terms of the mathematical cell heap $H$. First, we assert that 
the relational transpose $(\cdot)^\dagger$ of the reads relation $R_H$ is the
observes relation $O_H$, which enforces the condition that the reads
and observe relations be the same, only pointing in opposite
directions (i.e., if $a$ reads $b$, then $b$ is observed by
$a$). Then, we require that the transitive (but not reflexive) closure
of the reads relation, $R^+_H$ form a strict partial order. Strictness
enforces the condition that there be no cycles in the dependence graph
(because otherwise there would be elements $a$, such that $(a, a) \in
R^+_H$).  Next, we require that the reads relation $R_H$ is a subset of
the Cartesian product $V_H \times V_H$ of the set of cells with values
$V_H$. This ensures that a) there are no dependencies on unready
cells, and b) all unready cells have empty read and observe
sets. Finally, we ask that all of the cells in $H$ have unique
identifiers --- $unique(H)$ asserts that the identifier field is one
half of an isomorphism between the cells in $H$, and the natural
numbers from 0 to the size of $H$.

In the third line, we begin by requiring that the cell heap $H$ satisfy
the abstract heap formula $\phi$, which formalizes the informal
reading of the abstract heap formulas given earlier. This satisfaction
relation follows the general style of separation logic quite closely; 
in a sense, our abstract heap formulas are giving a domain-specific
version of separation logic.

The last clause $heap(H)$ finally connects the cell heap, which is a purely
mathematical object, to the actual low-level heap the implementation
uses. We ask that the global counter reference $counter$ point to an integer
field equal to the size of the cell heap, and then use the iterated
separating conjunction $\forall^*$ to require that for each cell in
the cell heap, we have pointers to the appropriate code, value, read
and observer fields. The read and observer fields point to values of
type $\cellset$, each of which represent the appropriate sets of cells. 


\begin{figure}
\mbox{}
\begin{tabbing}
$CellHeap = \Sigma$\=$ D \in \powersetfin{ecell}.$ \\
               \>$(\Pi (\pack{\alpha}{\_}) \in D. ($\=${\codetype{\alpha}} \;\times$
                                         ${\opttype{\alpha}} \;\times$ 
                                         ${\powersetfin{ecell}} \;\times$ 
                                         ${\powersetfin{ecell}} \;\times$ 
                                         $\N)$ \\[1em]
       

$code = \pi_1$ \\
$value = \pi_2$ \\
$reads = \pi_3$ \\
$obs = \pi_4$ \\
$identity = \pi_5$ \\[1em]

$V_{(D, h)} = \comprehend{c \in D}{\exists v.\; value(h(c)) = \ctext{Some}(v)}$ \\
$R_{(D, h)} = \comprehend{(c,c') \in D}{ c' \in reads(h(c)) }$ \\
$O_{(D, h)} = \comprehend{(c,c') \in D}{ c' \in obs(h(c)) }$ \\[1em]

$unique(D,h) = \exists$\=$i : Fin(|D|) \to D.$\\
                       \>$i \circ (identity \circ h) = id \; \land (identity \circ h) \circ i = id$ \\[1em]

$\satisfies{(D,h)}{\phi} = sat((D,h), D, h)$ \\[1em]

$sat(H, D, \localref{r}{v}) = \top$ \\
$sat(H, D, I) = \top$ \\
$sat(H, D, \phi \otimes \psi) = \exists D_1, D_2.\;$\=$D = D_1 \uplus D_2 
                                                      \land sat(H, D_1, \phi) 
                                                      \land sat(H, D_2, \psi)$ \\
$sat(H, D, \cellneg{a}{e}) = a \in D \land code(h(a)) = e \land a \not \in V_H$ \\
$sat(H, D, \cellpos{a}{e}{v}{r}) =\; $\=$ a \in D \land code(h(a)) = e \;\land$ \\
      \>$\mathrm{if}($\=$r \cap V_H = r,$ \\
      \>     \>$value(h(a)) = \ctext{Some}\;v \land reads(h(a)) = r,$ \\
      \>     \>$a \not\in V_H)$\\[1em]
 

$heap(D,h) = $ \\
\;\;$counter \pointsto |D| \;* $ \\
\;\;$\forall^* (\pack{\tau}{c}\mbox{ as }cell) \in D.\;$\=$\exists v_r, v_o : \cellset.\;$ \\
                         \>$c.code \pointsto code(h(cell))   \;* $ \\
                         \>$c.value \pointsto value(h(cell)) \;* $ \\
                         \>$c.reads \pointsto v_r \;* $ \\
                         \>$c.obs   \pointsto v_o \;* $ \\
                         \>$c.id    = identity(h(cell)) \;\land$ \\
                         \>$set(D, v_r, reads(h(cell))) \;\land$ \\
                         \>$set(D, v_o, obs(h(cell)))$ 
\end{tabbing}

\caption{Definitions for Heap Invariant}
\label{heap-invariant}
\end{figure}

The global character of this invariant should be evident; we need to
talk about \emph{all} of the cells in the heap in order to state our
invariants. So it is not immediately clear that we have made much
progress towards a modular proof technique. However, we are actually
very close: with just two more ideas, we will be able to give a
solution to this problem.

\subsection{Frame Properties via Polymorphism}

As we mentioned earlier, our abstract heap formulas essentially give
us a small domain-specific separation logic. This means that in order
to reason locally over cell heaps, we need to find an
application-specific version of the frame rule for our library. 

To do this, we will adapt some ideas proposed by
Benton~\cite{benton}, and Birkedal and Yang~\cite{birkedal-yang}. They
suggested interpreting the frame rule of separation logic as a form of
quantification --- instead of having a separate frame rule that allows
adding a frame to any triple, they proposed that all of the atomic
rules of the program logic be replaced with rules possessing an extra
quantifier ranging over ``the rest of the heap'':

\begin{mathpar}
  \inferrule*[right=Example]
          { }
          { \forall R.\; \setof{ (e \pointsto v) * R } \;e := v'\; \setof{ (e \pointsto v') * R}}
\end{mathpar}

This quantifier is propagated through the proof, and any use of the
frame rule can be interpreted as instantiating the universal
quantifier appropriately. The reason this idea is fruitful for us is
that it will allow us to give a frame rule, even though the underlying
semantics of our library does not actually satisfy any analogues of
the traditional safety monotonicity and frame lemmas. For example, the
$\updatecell$ operation certainly does not act locally --- it
recursively traverses the observers set, possibly mutating a very
large part of the cell graph.

\subsubsection{Correctness of $\updatecell$}

Despite this issue, we can prove the soundness of the following triple
specifying $\updatecell$.

\begin{prop}{(Update Rule)}
For all cells $o$ and code expressions $e$ and $e'$, the following
triple is provable: 

\begin{tabbing}
$\forall \psi:\formula.\; $\=$\setof{G(\celleither{o}{e} \otimes \psi)}$ \\
                           \>$\runcmd {\updatecell\;o\;e}$ \\
                           \>$\setof{a:1.\; G(\cellneg{o}{e} \otimes \psi)}$
\end{tabbing}
\end{prop}

\textbf{Proof Strategy.} The key to this proof is the conditional
interpretation of the $\cellpos{c}{e}{v}{r}$ formula. When we evaluate
the $\updatecell$ command, we recursively find every cell which
depends on $o$, and modify it to be unready.

Now consider any positive cell formula in $\psi$ which reads $o$,
directly or indirectly. The satisfaction relation for $\phi$ tells us
that a positive formula must have everything in its read set be
ready, in order to represent a ready cell. So by changing $o$'s
formula to the unready state, we no longer require that positive
formula to represent a ready cell. As a result, we can leave the
entire frame $\psi$ untouched, even though the physical heap it
represents may have been (quite drastically) modified. 

However, before we can give a proper proof of this theorem, we need to
specify and prove correct the $\ctext{mark\_unready(c)}$ procedure,
which does the bulk of the work of the update function. The purpose of
this function is to set every cell transitively reachable from $c$ to
the unready state.

As with the proofs in the previous chapter, these follow the pattern 
of a lemma about partial orders, a lemma connecting it to the satisfaction
relation, and finally a correctness proof of the procedure. 


\begin{lemma}{(Transitive Invalidation Preserves Order Structure)}
Suppose we have $H = (D,h)$ such that 
\begin{enumerate}
\item $R^+_H$ is a strict partial order 
\item $R_H \subseteq V_H \times V_H$
\item $R^\dagger_H = O_H$ 
\item $\mathit{unique}(H)$
\end{enumerate}

Now let $U = \comprehend{c' \in D}{(c',c) \in R^*_H}$ to be the set of
cells which (transitively) read $c$, and define $h'$ to have the
following components:

\begin{itemize}
\item $\mathit{code}(h') = \mathit{code}(h)$
\item $\mathit{value}(h') = \semfun{c'}{\IfThenElse{c'\in U}{\None}{\mathit{value}(h(c'))}}$
\item $\mathit{reads}(h') = \semfun{c'}{\IfThenElse{c'\in U}{\emptyset}{\mathit{reads}(h(c'))}}$
\item $\mathit{obs}(h') = \semfun{c'}{\IfThenElse{c'\in U}{\emptyset}{\mathit{obs}(h(c')) - U}}$
\item $\mathit{identity}(h') = \mathit{identity}(h)$
\end{itemize}

\noindent Then it is the case that $H' = (D,h')$ satisfies the five properties below. 
\begin{enumerate}
\item $R^+_{H'}$ is a strict partial order 
\item $V_{H'} = V_H - U$
\item $R_{H'} \subseteq V_{H'} \times V_{H'}$
\item $R^\dagger_{H'} = O_{H'}$ 
\item $\mathit{unique}(H')$
\end{enumerate}
\end{lemma}

\begin{proof}
\begin{enumerate}
\item $R^+_{H'}$ is a strict partial order 
  \begin{tabbedproof}
    \oo This follows if $R^+_{H'}$ is transitive relation without any $(a,a) \in R^+_H$ \\
    \oo Since it is a transitive closure, it is a transitive relation \\
    \oo To show that there is no $a \in D$ such that $(a,a) \in R^+_H$, \\
    \ox we will show that $R^+_{H'} \subseteq R^+_H$ \\
    \oo Assume that $(a_0,b) \in R^+_{H'}$ \\
    \oo Then there is a sequence $a_0, \ldots, a_k$ such $b = a_k$ and each $a_{i+1} \in \mathit{reads}(h'(a_i))$ \\
    \oo Suppose we have an arbitrary $a_i, a_{i+1}$, so $a_{i+1} \in \mathit{reads}(h'(a_i))$ \\
    \oo Hence it follows that $a_i \not\in U$, since otherwise $\mathit{reads}(h'(a_i)) = \emptyset$ \\
    \oo Hence it tollows that $\mathit{reads}(h'(a_i)) = \mathit{reads}(h(a_i))$ \\
    \oo Hence $a_0, \ldots, a_k$ such $b = a_k$ and each $a_{i+1} \in \mathit{reads}(h(a_i))$ \\
    \oo Hence $(a_0, b) \in R^+_H$ \\
    \oo Hence $a_0 \not= b$, since $R^+_H$ strict partial order 
  \end{tabbedproof}

\item $V_{H'} = V_H - U$
  \begin{tabbedproof}
    \oo Suppose $a \in V_{H'}$ \\
    \ooo Then $\mathit{value}(h'(a)) = \Some(v)$ for some $v$ \\
    \ooo Hence $a \not\in U$ \\
    \ooo Hence $\mathit{value}(h'(a)) = \mathit{value}(h(v))$  \\
    \ooo Hence $a \in V_H$ \\
    \ooo Hence $a \in V_{H} - U$ \\
    \oo Conversely, suppose $a \in V_{H} - U$ \\
    \ooo Then $\mathit{value}(h(a)) = \Some(v)$ for some $v$ \\
    \ooo But since $a \not\in U$, we know $\mathit{value}(h'(a)) = \mathit{value}(h(a)) = \Some(v)$ \\
    \ooo Hence $a \in V_{H'}$ 
  \end{tabbedproof}

\item $R_{H'} \subseteq V_{H'} \times V_{H'}$
  \begin{tabbedproof}
    \oo Assume $(a,b) \in R_{H'}$ \\
    \oo Hence $b \in \mathit{reads}(h'(a))$ \\
    \oo Hence we know that $a \not\in U$ \\
    \oo Hence we know that $b \in \mathit{reads}(h(a))$ \\
    \oo Hence we know that $a \in V_H$\\
    \oo Hence we know that $a \in V_H - U$ \\
    \oo Hence we know that $a \in V_{H'}$ \\
    \oo Since $U$ is transitively-closed, we know that if $b \in U$, then $a \in U$ \\
    \oo Since $a \not\in U$, we know that $b \not\in U$ \\
    \oo Hence we know that $b \in V_H - U$ \\
    \oo Hence we know that $b \in V_{H'}$ 
  \end{tabbedproof}

\item $R^\dagger_{H'} = O_{H'}$ 
  \begin{tabbedproof}
    \oo Suppose that $(a, b) \in R^\dagger_{H'}$. \\
    \ooo We want to show that $(a, b) \in O_{H'}$ \\
    \ooo We know that $(b, a) \in R_{H'}$ \\
    \ooo We know that $a \in \mathit{reads}(h'(b))$ \\
    \ooo Since $R_{H'} \subseteq V_{H'} \times V_{H'}$, we know $a \not\in U$ and $b \not \in U$ \\
    \ooo Hence $a \in \mathit{reads}(h(b))$ \\ 
    \ooo Hence $b \in \mathit{obs}(h(a))$ \\
    \ooo Hence $b \in \mathit{obs}(h'(a))$ \\
    \ooo Hence $(a,b) \in O_{H'}$ \\
    \oo Suppose that $(a, b) \in O_{H'}$. \\
    \ooo We want to show that $(a,b) \in R^\dagger_{H'}$, so we want $(b,a) \in R_{H'}$ \\
    \ooo Since $(a,b) \in O_{H'}$, we know $b \in \mathit{obs}(h'(a))$ \\
    \ooo Hence $a \not\in U$ and $b \in \mathit{obs}(h(a)) - U$ \\
    \ooo So $b \in \mathit{obs}(h(a))$ and $b \not \in U$ \\
    \ooo So $(a,b) \in O_H$ \\
    \ooo So $(b,a) \in R_H$, and so $a \in \mathit{reads}(h(b))$ \\
    \ooo Since $b \not\in U$, $\mathit{reads}(h'(b)) = \mathit{reads}(h(b))$ \\
    \ooo Therefore $a \in \mathit{reads}(h'(a))$, and so $(b,a) \in R_{H'}$ \\
    \ooo Therefore $(a,b) \in R^\dagger_{H'}$ 
  \end{tabbedproof}

\item $\mathit{unique}(h) = \mathit{unique}(h')$.

This is immediate, since $\mathit{identity}(h) = \mathit{identity}(h')$ 
\end{enumerate}
\end{proof}


\begin{lemma}{(Updating the Abstract Heap)}
Suppose we have $H = (D,h)$ and $H, D', \models \phi \otimes
\celleither{c}{e}$ and $c \in D$, and let $U = \comprehend{c' \in
  D}{(c,c') \in R^*_H}$ to be the set of cells which (transitively)
read $c$.

Now, define $h'$ to have the following components
\begin{itemize}
\item $\mathit{code}(h') = \mathit{code}(h)$
\item $\mathit{value}(h') = \semfun{c'}{\IfThenElse{c'\in U}{\None}{\mathit{value}(h(c'))}}$
\item $\mathit{reads}(h') = \semfun{c'}{\IfThenElse{c'\in U}{\emptyset}{\mathit{reads}(h(c'))}}$
\item $\mathit{obs}(h') = \semfun{c'}{\IfThenElse{c'\in U}{\emptyset}{\mathit{obs}(h(c'))}}$
\item $\mathit{identity}(h') = \mathit{identity}(h)$
\end{itemize}

It is the case that $(D, h'), D' \models \phi$. 
\end{lemma}

\begin{proof}
\begin{tabbedproof}
\oo Assume we have $H, D' \models \phi \otimes \celleither{c}{e}$ \\
\oo Then we have $D_1, D_2$ such that $D_1 \uplus D_2 = D'$ and $H, D_1 \models \phi$ and $H, D_2 \models \celleither{c}{e}$ \\
\oo Note that this means $c$ is not in the domain of $\phi$ \\
\oo First, consider $(D,h), D_1 \models \phi$ \\
\ooo We will show by induction that $(D,h'), D_1 \models \phi$ \\
\ooo Case $\phi = I$: \\
\oooo In this case, by the definition of satisfaction, $(D,h), D_1 \models I$ \\
\ooo Case $\phi = \psi \otimes \theta$: \\
\oooo In this case, we have $D_1, D_2$ such that $D_1 = D_1 \uplus D_2$ and \\
\oooox $(D,h), D_1 \models \psi$ \\
\oooox $(D,h), D_2 \models \theta$ \\
\oooo By induction, we know that \\
\oooox $(D,h'), D_1 \models \psi$ \\
\oooox $(D,h'), D_2 \models \theta$ \\
\oooo Hence by the definition of satisfaction, $(D,h'), D \models \psi \otimes \theta$ \\
\ooo Case $\phi = \cellneg{a}{e}$: \\
\oooo In this case, we know $a \in D_1$ and $\mathit{code}(h(a)) = e$ and $a \not\in V_{(D,h)}$ \\
\oooo Since $R_H \subseteq V_H \times V_H$, it follows  $U = \emptyset$ \\
\oooo Hence $h' = h$ \\
\oooo Hence $(D,h'), D_1 \models \cellneg{a}{e}$ \\
\ooo Case $\phi = \cellpos{a}{e}{v}{r}$: \\
\oooo Now, consider whether $r \subseteq V_H$ \\
\oooo If $r \subseteq V_H$: \\
\ooooo We know $a \in D_1$ and $\mathit{code}(h(a)) = e$ and 
 o     $\mathit{value}(h(a)) = \Some(v)$ and $\mathit{reads}(h(a)) = r$ \\
\ooooo So $a \in V_H$. \\
\ooooo Now consider whether $a \in U$ \\
\ooooo If $a \in U$: \\
\oooooo First, note $a \not\in V_{(D,h')}$ \\
\oooooo Then $(c, a) \in R^*_H$ \\
\oooooo Since $c \not= a$ (since $c$ is not in the domain of $\phi$), we know $(c,a) \in R^+_H$ \\
\oooooo Hence there is a $d \in r$ such that $d \in U$ \\
\oooooo Hence $r \not\subseteq V_{(D, h')}$ \\
\oooooo Hence $(D,h'), D_1 \models \cellpos{a}{e}{v}{r}$ \\
\ooooo If $a \not\in U$: \\
\oooooo Then note $a \in V_{(D,h')}$ \\
\oooooo Furthermore, $(c, a) \not\in R^*_H$ \\
\oooooo Hence there is no $d \in r$ such that $(c, d) \in R^*_H$  \\
\oooooo Hence $r \cap U = \emptyset$ \\
\oooooo Hence $r \subseteq V_{(D,h')}$ \\
\oooooo Hence $(D,h'), D_1 \models \cellpos{a}{e}{v}{r}$ \\
\oooo If $r \not\subseteq V_H$: \\
\ooooo Then we know $a \in D_1$ and $\mathit{code}(h(a)) = e$ and $a \not\in V_H$ \\
\ooooo Since $R_H \subseteq V_H \times V_H$, it follows  $U = \emptyset$ \\
\ooooo Hence $h' = h$ \\
\ooooo Hence $(D,h'), D_1 \models \cellpos{a}{e}{v}{r}$ \\
\oo Next, consider $(D,h), D_2 \models \celleither{c}{e}$: \\
\ooo Since $(c, c) \in R^*_H$,  we know $c \in U$ \\
\ooo Hence it follows $c \not\in V_{(D, h')}$ \\
\ooo Hence $(D,h'), D_2 \models \cellneg{c}{e}$ \\
\oo Now, it follows that $(D,h'), D' \models \phi \otimes \cellneg{c}{e}$ \\ 
\end{tabbedproof}
\end{proof}


\begin{lemma}{(The $\ctext{mark\_unready}$ procedure preserves order structure)}
Suppose $H = (D,h)$ where $R^+_H$ is a strict partial order, $O^\dagger_H = R_H$,
$R_H \subseteq V_H \times V_H$ and $\mathit{unique}(H)$. Furthermore, suppose 
$U = \comprehend{c' \in D}{(c,c') \in R^*_H}$ to be the set of cells which (transitively)
read $c$.

Now, define $h'$ to have the following components
\begin{itemize}
\item $\mathit{code}(h') = \mathit{code}(h)$
\item $\mathit{value}(h') = \semfun{c'}{\IfThenElse{c'\in U}{\None}{\mathit{value}(h(c'))}}$
\item $\mathit{reads}(h') = \semfun{c'}{\IfThenElse{c'\in U}{\emptyset}{\mathit{reads}(h(c'))}}$
\item $\mathit{obs}(h') = \semfun{c'}{\IfThenElse{c'\in U}{\emptyset}{\mathit{obs}(h(c'))}}$
\item $\mathit{identity}(h') = \mathit{identity}(h)$
\end{itemize}

Then $\ctext{mark\_unready}$ function satisfies the following specification:

\begin{displaymath}
\mspec{\mathit{heap}(H)}{\ctext{mark\_unready}}{a:\unittype}{\mathit{heap}(D,h')}
\end{displaymath}
  
\end{lemma}

\begin{proof}
We will be to prove this function using the fixed point induction
rule, using precisely this specification. (In fact, the function is
totally correct, since it is always called on arguments higher up in
the partial ordering on cells, but tracking the termination metric in
detail obscures the key ideas.)

Now we'll proceed line-by-line through the function body of $\ctext{mark\_unready}(c)$: 

\begin{tabbedproof}
\oo Suppose $\mathit{Inv}(H, \phi \otimes \celleither{c}{e})$ \\
\oo Then we know \\
\oox $R^\dagger_H = O_H$ \\
\oox $R^+_H$ strict partial order \\
\oox $R_H \subseteq V_H \times V_H$ \\
\oox $\mathit{unique}(H)$ \\
\oox $\mathit{satisfies}(H, \phi)$ \\
\oox $\mathit{heap}(H)$ \\
\ooo Consider whether $c$ is in $V_H$ \\
\ooo Suppose $c \not\in V_H$: \\
\oooo Then $H'$ is equal to $H$ \\
\oooo Since $R_H \subseteq V_H \times V_H$, we know $\mathit{reads}(h'(c)) = \mathit{obs}(h'(c)) = \emptyset$ \\
\oooo $[\unpack{\alpha}{a}{c}{}$ \\
\oooo Now, we know that $c = \pack{\alpha}{a}$ \\
\oooo $\letv{os}{!a.obs}{}$ \\
\oooo $\letv{rs}{!a.reads}{}$ \\
\oooo From the definition of $\mathit{heap}(H)$, we know that  \\
\oooo $\mathit{set}(D, os, \emptyset)$ and $\mathit{set}(D, rs, \emptyset)$ \\
\oooo Simplifying using the axioms for sets, lines 8 and 9 are no-ops \\
\oooo $\letv{\_}{[a.value := \None]}{}$ \\
\oooo $\letv{\_}{[a.reads := \emptyset]}{}$ \\
\oooo $a.obs := \emptyset]$ \\
\oooo None of these assignments have any effect on the validity of $\mathit{heap}(H')$ \\
\ooo Consider whether $c \in V_H$: \\
\oooo $[\unpack{\alpha}{a}{c}{}$ \\
\oooo Now, we know that $c = \pack{\alpha}{a}$ \\
\oooo $\letv{os}{!a.obs}{}$ \\
\oooo $\letv{rs}{!a.reads}{}$ \\
\oooo From the definition of $\mathit{heap}(H)$, we know that  \\
\oooo $\mathit{set}(D, os, \mathit{obs}(h(c)))$ and $\mathit{set}(D, rs, \mathit{reads}(h(c)))$ \\
\oooo Now, by axiom in the cellset interface, we know that $\ctext{iterseq\;mark\_unready}\;os$ \\
\ooox is equal to a sequence of calls to $\ctext{mark\_unready}$, once for each element of $\mathit{obs}(h(c))$\\
\oooo By induction on the size of $\mathit{obs}(h(c))$, we end in a state with $h'$ such that \\
\oooox $\mathit{value}(h' ) = \semfun{c'}{\IfThenElse{c'\in \mathit{obs}(h(c))}{\None}{\mathit{value}(h(c'))}}$ \\
\oooox $\mathit{reads}(h') = \semfun{c'}{\IfThenElse{c'\in \mathit{obs}(h(c))}{\emptyset}{\mathit{reads}(h(c'))}}$ \\
\oooox $\mathit{obs}(h') = \semfun{c'}{\IfThenElse{c'\in \mathit{obs}(h(c))}{\emptyset}{\mathit{obs}(h(c'))}}$ \\
\oooo Note that we need the the fact that invalidation preserves order structure to  \\
\ooox make the induction go through. \\
\oooo Hence in $H' = (D,h')$, every $c'$ strictly above $c$ in $H$ is now not in $V_{H'}$ \\ 
\oooo Since $R_H$ was a strict partial order, $c$ is still in $V_{H'}$ \\
\oooo Therefore consider $h''$ such that   \\
\oooox $\mathit{value}(h'') = \semfun{c'}{\IfThenElse{c' = c)}{\None}{\mathit{value}(h'(c'))}}$ \\
\oooox $\mathit{reads}(h'') = \semfun{c'}{\IfThenElse{c' = c)}{\emptyset}{\mathit{reads}(h'(c'))}}$ \\
\oooox $\mathit{obs}(h'') = \semfun{c'}{\IfThenElse{c'\in \mathit{obs}(h(c))}{\emptyset}{\mathit{obs}(h'(c'))}}$ \\
\oooo Likewise, by axiom in the cellset interface, we know that $\ctext{iterseq}\;(\ctext{remove\_obs}\;cell)\;rs$ \\
\ooox is equal to a sequence of calls to $\ctext{remove\_obs}$, once for each element of $\mathit{reads}(h'(c))$\\
\oooo $\letv{\_}{[a.value := \None]}{}$ \\
\oooo $\letv{\_}{[a.reads := \emptyset]}{}$ \\
\oooo $a.obs := \emptyset]$ \\
\oooo We know that $c$ occurs only in $rs$ since $R^\dagger_{H'} = O_{H'}$, and so \\ 
\oooo these assignments ensure that $\mathit{heap}(D, h'')$ is satisfied. \\
\end{tabbedproof}
\end{proof}

\begin{lemma}{(Correctness of $\ctext{mark\_unready}$)}
The $\ctext{mark\_unready}$ function satisfies the following specification:   
\begin{displaymath}
\mspec{G(H, \phi \otimes \celleither{c}{e})}{\ctext{mark\_unready}}{a:\unittype}{\exists H'.\;G(H', \phi \otimes \cellneg{c}{e})}
\end{displaymath}
\end{lemma}

\begin{proof}
  This follows immediately from the previous lemma, together with the lemma about updating the 
abstract heap. 
\end{proof}


\begin{lemma}{(Updating Negative Formulas)}
Suppose we have  $H = (D,h)$ and $H, D' \models \phi \otimes \cellneg{c}{e}$. Then, if
we define $h'$ such that $\mathit{code}(h'(c)) = e'$ and is equal to $h$ otherwise, 
it follows that with $H' = (D,h')$, we have $H', D' \models \phi \otimes \cellneg{c}{e'}$. 
\end{lemma}

\begin{proof}
  \begin{tabbedproof}
    \oo Assume $H, D' \models \phi \otimes \cellneg{c}{e}$. \\
    \ooo So we have $D_1, D_2$ such that $D' = D_1 \uplus D_2$ and $H, D_1 models \phi$ and $H, D_2 \models \cellneg{c}{e}$ \\
    \ooo Since $H, D_2 \models \cellneg{c}{e}$, we know that $c \in D_2$ and $c \not\in D_1$ \\
    \ooo Now proceed by induction on $\phi$: \\
    \ooo Case $\phi = I$: \\
    \oooo In this case, it is immediate that $H', D_1 \models I$ \\
    \ooo Case $\phi = \psi \otimes \theta$: \\
    \oooo In this case, we have $D_3, D_4$ such that $D_1 = D_3 \uplus D_4$ and  \\
    \oooox $H, D_3 \models \psi$ and $H, D_4 \models \theta$ \\
    \oooo So by induction we have $H', D_3 \models \psi$ and $H', D_4 \models \theta$ \\
    \oooo Hence $H', D_1 \models \phi$\\
    \ooo Case $\phi = \cellneg{c'}{e}$: \\
    \oooo We know $c' \in D_1$ \\
    \oooo We know that $c' \not= c$. Hence $\mathit{code}(h'(c')) = \mathit{code}(h(c))$ \\
    \oooo Hence $H', D_1 \models \cellneg{c'}{e}$ \\
    \ooo Case $\phi = \cellpos{c'}{e}{v}{r}$: \\
    \oooo We know that $c' \in D_1$ and hence $c \not= c'$ \\
    \oooo Hence $\mathit{code}(h'(c')) = \mathit{code}(h(c))$ \\
    \oooo Furthermore, $V_{H'} = V_H$ since $\mathit{value} \circ h' = \mathit{value} \circ h$\\
    \oooo Also $\mathit{reads} \circ h' = \mathit{reads} \circ h$ \\
    \oooo Hence $H', D_1 \models \cellpos{c'}{e}{v}{r}$: \\
    \ooo Therefore $H', D_1 \models \phi$ \\
    \ooo Now, we want to show $H', D_2 \models \cellneg{c}{e'}$ \\
    \oooo We know $c \in D_2$ \\
    \oooo Furthermore, $\mathit{code}(h'(c)) = e'$ \\
    \oooo Hence $H', D_2 \models \cellneg{c}{e'}$ \\
    \ooo Hence $H', D' \models \phi \otimes \cellneg{c}{e'}$ 
  \end{tabbedproof}
\end{proof}

\begin{lemma}{(Update Rule)}
For all cells $o$ and code expressions $e$ and $e'$, the following
triple is provable: 

\begin{tabbing}
$\forall \psi:\formula.\; $\=$\setof{G(\celleither{o}{e} \otimes \psi)}$ \\
                           \>$\runcmd {\updatecell\;o\;e}$ \\
                           \>$\setof{a:1.\; G(\cellneg{o}{e} \otimes \psi)}$
\end{tabbing}
\end{lemma}

\begin{proof}
This follows immediately from first applying the specification of $\ctext{mark\_unready}$, 
and then using the lemma that updating negative lemmas works as expected. 
\end{proof}


\subsubsection{Correctness of $\newcell$}

We can prove the soundness of a similar specification for $\newcell$ as
well:

\begin{prop}{(New Cell Rule)}
For all code expressions $e$, the following specification is provable: 
\begin{tabbing}
$\forall \psi:\formula.\; $\=$\setof{G(\psi)}$ \\
                           \>$\run {\newcell\;e}$ \\
                           \>$\setof{a:\celltype{A}.\; G(\cellneg{a}{e} \otimes \psi)}$
\end{tabbing}
\end{prop}

\begin{proof}
This is much easier than $\updatecell$: we just need to allocate a new
numeric id for the new cell, and show that the extended cell heap
continues to satisfy all of the expected properties.

Concretely, suppose that $G(\psi) = \mathit{Inv}{(H, \psi)}$ for some
$H = (D,h)$. Now, by the invariant, we know that each cell in $D$ has 
a unique numeric id somewhere in the range from $0$ to $|D|-1$. Then,
on lines 29-30, we increment the global counter by 1, and let $id = |D|$. 
Then, on lines 31-34, we allocate a pointer $\mathit{code}$ to the code $e$, a pointer
$\mathit{value}$ to $\None$ (to indicate the unitialized state), as well as pointers to 
$\mathit{read}$ and $\mathit{obs}$ to empty read and observer sets. 

At line 35, all of these values are bound to variables in scope, so we
can define $H' = (D',h')$, where $\mathit{ec} = \pack{\tau}{\mathit{(code, value, read, obs, id)}}$, 
and 
\begin{displaymath}
(D',h') = (D \cup \setof{\mathit{ec}}, h' = [h|\mathit{ec}: (e, \None, \emptyset, \emptyset, id)])
\end{displaymath}

Then, it is easy to show that the modified heap realizes $H'$ --- the
only fact that does not carry over immediately are the predicates
establishing the the read and observer sets are implemented
correctly. This is because they held for world $D$, and we are now in
world $D'$. Happily, we required as an axiom that $(W \subseteq W')
\implies \mathit{set}(W, v, S) \implies \mathit{set}(W', v, S)$.

Finally, we need to show that $\cellneg{a}{e} \otimes \psi$ is
satisfied by $H'$. This follows from an easy induction on $\psi$:
since $h'$ is just an extension of $h$ with $V_{H'} = V_H$, none
of the conditionals or function calls in the cell predicates have
different results, which means that the truth-values they define
are unchanged. 

Then we can hide $H'$ behind an existential to establish the postcondition. 
\end{proof}

\begin{figure}
\mbox{}
\begin{mathpar}
  \inferrule*[right=Ready]
            {\forall a' \in r.\; \exists v.\; \ready{\phi}{a'}{r}}
            {\ready{\phi \otimes \cellpos{a}{e}{v}{r}}{a}{v}}
  \\
  \\
  \inferrule*[right=UnreadyPos]
            {\exists a' \in r.\; \unready{\phi}{a}}
            {\unready{\phi \otimes \cellpos{a}{e}{v}{r}}
                     {a}}
  \and
  \inferrule*[right=UnreadyNeg]
            { }
            {\unready{\phi \otimes \cellneg{a}{e}}{a}}
\end{mathpar}
\caption{Ready and Unready Judgments}
\label{readiness}
\end{figure}

\begin{figure}
\mbox{}
  \begin{displaymath}
    \begin{array}{lcl}
      \closed{I}{s} & = & \top \\
      \closed{\phi \otimes \psi}{s} & = & \closed{\phi}{s} \land \closed{\psi}{s} \\ 
      \closed{\localref{r}{v}}{s} & = & \top \\
      \closed{\cellneg{a}{e}}{s} & = & \top \\
      \closed{\cellpos{a}{e}{v}{r}}{s} & = & r \subseteq s \\
    \end{array}
  \end{displaymath}
\caption{Closedness predicate}
\label{closedness}  
\end{figure}

\begin{figure}
\mbox{}
  \begin{displaymath}
    \begin{array}{lcl}
      R(s, I)                 & = & I \\
      R(s, \phi \otimes \psi) & = & R(s, \phi) \otimes R(s, \psi) \\
      R(s, \localref{r}{v})   & = & \localref{r}{v} \\
      R(s, \cellneg{a}{e})    & = & \cellneg{a}{e} \\
      R(s, \cellpos{a}{e}{v}{r}) & = & \left\{\begin{array}{ll}
                                                \cellpos{a}{e}{v}{r} 
                                              & \mbox{if } s \cap r = \emptyset \\
                                                \cellneg{a}{e}
                                              & \mbox{otherwise}
                                              \end{array}
                                       \right.
    \end{array}
  \end{displaymath}
\caption{Definition of the Ramification Operator $R$}
\label{ramify-def}
\end{figure}

\subsection{Ramified Frame Properties}

Ironically, this strategy is sufficient for $\newcell$and
$\updatecell$, but is not adequate for defining a frame property
for $\codetype{A}$ expressions. 

As an example, suppose that we want to evaluate the formula $\readcell
a$, in a cell heap described by $\cellneg{a}{\return 5}$.  Clearly,
this is a sufficient footprint, and we expect to a) get the return
value 5, and b) see the cell formula change to $\cellpos{a}{\return
  5}{5}{\emptyset}$.  However, the fact that we are now changing cells
from negative to positive means that the conditional character of
readiness, which worked in our favor with $\updatecell$ and
$\newcell\!\!$, now works against us.

In particular, suppose that we run this command with a framed abstract heap
formula $\psi = \cellpos{b}{\readcell a}{17}{\setof{a}}$. Now, the
whole starting heap will be:
\begin{displaymath}
\cellneg{a}{\return 5} \otimes \cellpos{b}{\readcell a}{17}{\setof{a}}  
\end{displaymath}
In any heap satisfying this formula, $b$ will be unready, because it depends 
on an unready cell. But when we execute $\readcell a$, simply copying $\psi$ 
into the post-state will give us the cell formula:
\begin{displaymath}
\cellpos{a}{\return 5}{5}{\emptyset} \otimes \cellpos{b}{\readcell a}{17}{\setof{a}}
\end{displaymath}
That is, our satisfaction relation now expects $b$ to be ready and have the 
value 17, even though $\readcell a$ never touches $b$ at all!

Clearly, we cannot expect to be able simply copy the same frame formula into 
the pre- and the post-condition states in the specification of commands like 
$\readcell a$. 

To deal with this problem, we look back to McCarthy's original paper
introducing the frame problem~\cite{mccarthy}. There, he described the
frame problem as the problem of how to specify what parts of a state
were \emph{unaffected} by the action of a command, which inspired the
name of the frame rule in separation logic. In that paper, he also
described the \emph{qualification problem}. He observed that many
commands (such as a flipping a light switch turning on a light bulb)
have numerous implicit preconditions (such as there being a bulb in
the light socket), and dubbed the problem of identifying these
implicit preconditions the qualification problem. 

Some years later, \citet{finger} observed that the qualification
problem has a dual: actions can have indirect effects that are not
explicitly stated in their specification (e.g., turning on the light can
startle the cat). He called the problem of deducing these implicit
consequences the ``ramification problem'' --- is there a simple way to
represent all of the indirect consequences of an action?

We can understand our difficulty as an instance of the ramification
problem. When we evaluate a code expression, we may read some unready
cells and send them from an unready state in the precondition to a ready
state in the postcondition. However, we may have had some cell formulas in
our frame which claimed their corresponding cells were unready purely
because one of the cells in our footprint was unready. Therefore, when
we update the footprint, we must modify the frame formula to account
for the ramifications of our update in the footprint. So even though
the actual physical storage representing the frame doesn't change at all, 
we need to modify our abstract formula to reflect our updated state
of knowledge. 

In our case, \emph{all} of the effects on the frame will arise from
the cells we flip from unready to ready. Thus, given the set of cells
which became ready, we can repair the framing formula by taking each
positive cell formula, and setting it to a negative state if its read
set includes anything that went from unready to ready. We define the
ramification operator $R(s, \psi)$ in Figure~\ref{ramify-def}.  It is
a simple structural induction over a framing formula, whose only
action is to replace the positive cell formulas in $\psi$ whose read
sets intersect with $s$ with a corresponding negative cell formula.
The ramification operator has a number of useful properties, which are
most easily expressed after we have introduced a few auxiliary
judgments and predicates.

In Figure~\ref{readiness} we define the two judgments $\unready{\phi}{o}$
and $\ready{\phi}{o}{v}$, which establish whether a cell is ready or
unready, from the syntactic structure of $\phi$. 

\begin{prop}{(Soundness of $\ready{\phi}{o}{v}$ and $\unready{\phi}{o}$)}
For all $\phi, o,$ and $H$ such that $H = (D,h)$:

\begin{itemize}
\item $(Inv(H, \phi) \land \ready{\phi}{o}{v}) \implies value(h(o)) = \ctext{Some}\;v$
\item $(Inv(H, \phi) \land \unready{\phi}{o}) \implies o \not\in V_H$
\end{itemize}
\end{prop}

In Figure~\ref{closedness}, we define the $\closed{\phi}{s}$ predicate,
which asserts that every cell formula in $\phi$ reads at most the
cells in $s$. Now, we can summarize the interactions between the 
ramification operator $R$ and abstract heap formulas as follows: 

\begin{prop}{(Interaction Properties)}
Given sets of cells $s$ and $u$, cell $o$, value $v$, and formula $\phi$, we have
that:
\begin{itemize}
\item $R(s, R(u, \phi)) = R(s \cup u, \phi)$
\item If $\unready{\phi}{o}$, then $\unready{R(u, \phi)}{o}$ 
\item If $\ready{R(u, \phi)}{o}{v}$, then $\ready{phi}{o}{v}$ 
\item If $R(u, \phi)$ and $\closed{\phi}{s}$, then $R(u, \phi) = R(u \cap s, \phi)$ 
\end{itemize}
\end{prop}

All of these facts can be proved with simple inductive arguments. 

The first property means that if we evaluate two expressions, we can
simply combine their ramification effects without having to worry
about the order that they were evaluated in. The second and third let
us know that a ramification cannot make us forget a cell is unready,
nor can it make anything ready that was not ready before. The last
property permits us to constrain the effect of a ramification --- if we
know that two parts of the abstract heap formula do not read each
other at all, we can deduce that ramifications from one will not
affect the other.

\begin{prop}{(Entailments)}
Define $\phi \vdash \theta$ to mean that for all $H$ and $D$, that if $H, D \models \phi$ then 
$H, D \models \theta$. 

\begin{itemize}
\item For all $\phi, \theta$, we have $\phi \otimes \theta \vdash \phi$
\item For all $\phi, \phi', \psi$, if $\phi \vdash \phi'$ then $\phi \otimes \psi \vdash \phi' \otimes \psi$  
\item If $\unready{\phi}{c}$ then $\phi \dashv\vdash R(\setof{c}, \phi)$
\item If $\unready{\phi \otimes \celleither{c}{e}}{c}$ then $\phi \otimes \celleither{c}{e} \dashv\vdash \phi \otimes \cellneg{c}{e}$
\end{itemize}
\end{prop}

\begin{proof}
\begin{itemize}
\item For all $\phi, \theta$, we have $\phi \otimes \theta \vdash \phi$
\begin{tabbedproof}
\oo Assume we have $\phi, \theta$ and $H, D \models \phi \otimes \theta$ \\
\oo Now we inductively show that for all $D' \supseteq D$, we have $H, D \models \phi$ implies $H, D' \models \phi$ \\
\ooo Case $\phi = I$: \\
\oooo Immediate \\
\ooo Case $\phi = \localref{r}{v}$: \\
\oooo Immediate\\
\ooo Case $\phi = \psi \otimes \theta$: \\
\oooo If $D' \supseteq D$, then there is a $D''$ such that $D' = D \uplus D''$ \\
\oooo By inversion, we have $D_1$ and $D_2$ with $D = D_1 \uplus D_2$ such that \\
\ooox $H, D_1 \models \psi$ and $H, D_2 \models \theta$ \\
\oooo By induction, we know that $H, D_1 \uplus D'' \models \psi$ \\
\oooo Since $D''$ is disjoint from $D$, we know it is disjoint from $D_1$ and $D_2$ \\
\oooo Hence $D_1 \uplus D''$ is disjoint from $D_2$ \\
\oooo Hence $H, D_1 \uplus D'' \uplus D_2 \models \psi \otimes \theta$ \\
\oooo Hence $H, D' \models \phi$ \\
\ooo Case $\phi = \cellneg{c}{e}$: \\
\oooo Since $c \in D$, we know $c \in D'$ \\
\oooo Hence $H, D' \models \cellneg{c}{e}$ \\
\ooo Case $\phi = \cellpos{c}{e}{v}{r}$: \\
\oooo Since $c \in D$, we know $c \in D'$ \\
\oooo Hence $H, D' \models \cellneg{c}{e}$ \\
\oo Now note that we have $D_1, D_2$ such that $D = D_1 \uplus D_2$ and \\
\ox $H, D_1 \models \phi$ and $H, D_2 \models \theta$ \\
\oo Since $D \supseteq D_1$, we know that $H, D \models \phi$ \\
\end{tabbedproof}

\item For all $\phi, \phi', \psi$, if $\phi \vdash \phi'$ then $\phi \otimes \psi \vdash \phi' \otimes \psi$  
\begin{tabbedproof}
\oo Assume we have $\phi \vdash \phi'$ \\
\oo Now, assume we have $H, D$ such that $H,D \models \phi \otimes \psi$ \\
\ooo So we know that there are $D_1, D_2$ such that $D = D_1 \uplus D_2$ and \\
\oox $H, D_1 \models \phi$ and $H, D_2 \models \psi$ \\
\ooo Since $\phi \vdash \phi'$, we know $H, D_1 \models \phi'$ \\
\ooo Hence $H, D_1 \uplus D_2 \models \phi' \otimes \psi$ \\
\ooo Hence $H, D \models \phi' \otimes \psi$ \\
\end{tabbedproof}


\item If $\unready{\phi}{c}$ then $\phi \dashv\vdash R(\setof{c}, \phi)$
\begin{tabbedproof}
\oo Assume $\unready{\phi}{c}$, and that we have $H$ and $D$. \\
\oo We want to show that $H, D \models \phi$ iff $H, D \models R(\setof{c}, \phi)$ \\
\oo $\Rightarrow$: Assume $H, D \models \phi$ \\
\ooo Now, we proceed by induction on $\phi$: \\
\ooo Case $\phi = I$: \\
\oooo Since $R(\setof{c}, I) = I$, this case is immediate \\
\ooo Case $\phi = \localref{r}{v}$: \\
\oooo Since this is always forced, this case is immediate \\
\ooo Case $\phi = \sigma \otimes \theta$: \\
\oooo By definition, we know there are $D_1, D_2$ such that $D = D_1 \uplus D_2$ and \\
\ooox $H, D_1 \models \sigma$ and $H, D_2 \models \theta$ \\
\oooo By induction $H, D_1 \models R(\setof{c}, \sigma)$ and $H, D_2 \models R(\setof{c}, \theta)$ \\
\oooo Hence $H, D \models R(\setof{c}, \sigma) \otimes R(\setof{c}, \theta)$ \\
\oooo Hence $H, D \models R(\setof{c}, \sigma \otimes \theta)$ \\
\ooo Case $\phi = \cellneg{c'}{e}$: \\
\oooo Since $R(\setof{c}, \cellneg{c'}{e}) = \cellneg{c'}{e}$, this case is immediate \\
\ooo Case $\phi = \cellpos{c'}{e'}{v'}{r'}$: \\
\oooo Consider whether $c \in r'$: \\
\oooo If $c \not\in r'$: \\
\ooooo Then $R(\setof{c}, \cellpos{c'}{e'}{v'}{r'}) = \cellpos{c'}{e'}{v'}{r'}$ and this case is immediate \\
\oooo If $c \in r'$: \\
\ooooo Since $\unready{c}{e}$ is sound, we know that $c \not\in V_H$. \\ 
\ooooo Hence $r' \not\subseteq V_H$, and so we know that $c' \not\in V_H$ \\
\ooooo Furthermore, we know that $c' \in D$, and $\mathit{code}(h(c')) = e'$, \\
\oooox so we know $H, D \models \cellneg{c'}{e'}$ \\
\ooooo Since $c \in r'$, we know $R(\setof{c}, \cellpos{c'}{e'}{v'}{r'}) = \cellneg{c'}{e'}$ \\
\ooooo Hence $H, D \models R(\setof{c}, \cellpos{c'}{e'}{v'}{r'})$ \\
\oo $\Leftarrow$: Assume $H, D \models R(\setof{c}, \phi)$ \\
\ooo Now proceed by induction on $\phi$: \\
\ooo Case $\phi = I$: \\
\oooo Since $R(\setof{c}, I) = I$, this case is immediate \\
\ooo Case $\phi = \localref{r}{v}$: \\
\oooo Since $R(\setof{c}, \localref{r}{v}) = \localref{r}{v}$, this case is immediate \\
\ooo Case $\phi = \sigma \otimes \theta$: \\
\oooo We know $R(\setof{c}, \sigma \otimes \theta) = R(\setof{c}, \sigma) \otimes R(\setof{c}, \theta)$ \\
\oooo Hence we know there are $D_1, D_2$ such that $D = D_1 \uplus D_2$ and \\
\ooox $H, D_1 \models R(\setof{c}, \sigma)$ and $H, D_2 \models R(\setof{c}, \theta)$ \\
\oooo By induction $H, D_1 \models \sigma$ and $H, D_2 \models \theta$ \\
\oooo Hence $H, D \models \sigma \otimes \theta$ \\
\ooo Case $\phi = \cellneg{c'}{e}$: \\
\oooo Since $R(\setof{c}, \cellneg{c'}{e}) = \cellneg{c'}{e}$, this case is immediate \\
\ooo Case $\phi = \cellpos{c'}{e'}{v'}{r'}$: \\
\oooo Consider whether $c \in r'$: \\
\oooo If $c \not\in r'$: \\
\ooooo Then $R(\setof{c}, \cellpos{c'}{e'}{v'}{r'}) = \cellpos{c'}{e'}{v'}{r'}$ and this case is immediate \\
\oooo If $c \in r'$: \\
\ooooo Since $\unready{c}{e}$ is sound, we know that $c \not\in V_H$. \\ 
\ooooo We know $H, D \models R(\setof{c}, \cellpos{c'}{e'}{v'}{r'}) = \cellneg{c'}{e'}$ \\
\ooooo Hence $c' \not\in V_H$ \\
\ooooo But since $c \in r'$, we know $H, D \models \cellpos{c'}{e'}{v'}{r'}$ \\
\end{tabbedproof}



\item If $\unready{\phi \otimes \cellpos{c}{e}{v}{r}}{c}$ then $\phi \otimes \cellpos{c}{e}{v}{r} \dashv\vdash \phi \otimes \cellneg{c}{e}$
\begin{tabbedproof}
\oo Assume $\unready{\phi \otimes \cellpos{c}{e}{v}{r}}{c}$  and $H, D$ \\
\oo Now we want to show $H, D \models \phi \otimes \cellpos{c}{e}{v}{r}$ if and only if \\
\ox $H, D \models \phi \otimes \cellneg{c}{e}$ \\
\oo $\Rightarrow$: Assume $H, D \models \phi \otimes \cellpos{c}{e}{v}{r}$ \\
\ooo So we have $D_1, D_2$ such that $D = D_1 \uplus D_2$ and \\
\oox $H, D_1 \models \phi$ and $H, D_2 \models \cellpos{c}{e}{v}{r}$ \\
\ooo From the soundness of $\unready{c}{e}$, we know that $c \not \in C_H$ \\
\ooo Hence we know that $H, D_2 \models cellneg{c}{e}$ \\
\ooo Hence we know that $H, D \models \phi \otimes \cellneg{c}{e}$ \\
\oo $\Leftarrow$: Assume $H, D \models \phi \otimes \cellneg{c}{e}$ \\
\ooo So we have $D_1, D_2$ such that $D = D_1 \uplus D_2$ and \\
\oox $H, D_1 \models \phi$ and $H, D_2 \models \cellpos{c}{e}{v}{r}$ \\
\ooo We want to show $H, D \models \phi \otimes \cellpos{c}{e}{v}{r}$ \\
\ooo By inversion on $\unready{\phi \otimes \cellpos{c}{e}{v}{r}}{c}$ we know $\unready{\phi}{d}$ for some $d \in r$ \\
\ooo By soundness of $\unready{\phi}{d}$, we know that $d \not\in V_H$ \\
\ooo Hence we know that $H, D_2 \models \cellpos{c}{e}{v}{r}$ \\
\ooo Hence we know that $H, D \models \phi \otimes \cellpos{c}{e}{v}{r}$ \\
\end{tabbedproof}
\end{itemize}
\end{proof}



\subsection{The Abstract Semantics of Expressions}

Now we can finally define the abstract semantics of the code
expression monad, which we give in Figure~\ref{abs-semantics}.

As before, we describe the effect of an expression $e$ with a Hoare
triple, prefixed with a quantification over all possible frames
$\psi$. Then we assert that from a state $G(\phi \otimes \psi)$,
running $e$ will give us a state $G(\phi' \otimes R(u, \psi))$ ---
that is, we must update the frame with the ramification $u$. Note in
particular that the framing formulas may \emph{differ} in the pre- and
the post-conditions. For composite commands (such as $\bind e\;f$) we
give their specifications as implications over the specifications of
their subcomponents.

In the specification \textsc{AUnit}, we give a specification for the
$\return v$ command, which simply returns its argument and neither
reads nor updates any cells or state. 

The \textsc{ABind} rule explains how sequential composition works for
an expression $\bind e\;f$ --- as expected, we evaluate the first
monadic argument, and pass the result to the functional argument, and
evaluate that. The read and update sets are simply the union of the
two executions. Reading a cell comes in two variants, \textsc{AReady}
and \textsc{AUnready}. If a cell is ready (using the
$\ready{\phi}{c}{v}$ judgment), we simply return its memoized value
without any further computation, and do not need to use a ramification
to update the frame. On the other hand, if a cell is unready (from the
$\unready{\phi}{c}$ judgment), we need to evaluate its code body, and
then update the cell with its new value. So we need to know what the
evaluation of its body can do. Note that we have to apply the
ramification operator to $\phi'$ in the postcondition in the
consequence of \textsc{AUnready}, because the cell we are reading goes
from unready to ready itself. 

We can also read and write local state (with the \textsc{AGetRef} and
\textsc{ASetRef} specifications), which do not have any effect on the
cells. Finally, we have the \textsc{AConseq} rule, which gives us a
version of the rule of consequence from ordinary Hoare logic.

Note that the use of the ready and unready judgments, together with
the entailment relation on abstract heaps, means that we can reason
``syntactically'' about the behavior of cell-manipulating programs: we
do not need to know what the concrete model (or concrete
implementation) when we are proving the correctness of client
programs. We will see this in the next section, which illustrates that
this interface really does give us a genuinely modular way of
reasoning about dataflow networks.

\begin{prop}{(Soundness of Abstract Semantics)}

All of the rules of the abstract semantics in Figure~\ref{abs-semantics} are
provable within our specification logic. 
\end{prop}

At this point, we can now reason about the behavior of the imperative
notification library in terms of its action on the abstract heap. The
combination of quantification and ramification give us a domain-specific 
frame property, which allow us to modularly prove the correctness of programs 
that construct and produce notifications.


\begin{figure}
\mbox{}
\begin{mathpar}
\begin{array}{ll}  
\mbox{\textsc{AUnit}} & 
\forall \psi.\; \mspec{G(\psi)}
                     {\return v}
                     {a}{G(\psi) \land \exists z.\; a = (v, z) \land \mathit{set}(\emptyset, z, \emptyset)} 
\\[1em]

\mbox{\textsc{ABind}} & 
\forall \psi.\; \mspec{G(\phi \otimes \psi)}
                     {e}
                     {a}{G(\phi' \otimes R(u', \psi)) \land \exists z.\;a = (v', r') \land \mathit{set}(r', z, r')} 
                \specand \\
&  \forall \psi.\; \mspec{G(\phi' \otimes \psi)}
                        {f\;v'}
                        {a}{G(\phi'' \otimes R(u'', \psi)) \land \exists z.\; a = (v'', z) \land \mathit{set}(r'', z, r'')}\\
&  \specimp \\
&  \begin{array}{ll}
     \forall \psi. & \left<G(\phi \otimes \psi)\right> \\
                   & \bind e\;f \\
                   &  \left<a.\;G(\phi'' \otimes R(u' \cup u'', \psi)) \land \exists z.\;a = (v'', z) \land \mathit{set}(r' \cup r'', z, r' \cup r'')\right> \\
   \end{array}
\\[2em]

\mbox{\textsc{AReady}} & 
  \setof{\ready{\phi}{c}{v}} \specimp \\
& \forall \psi.\; \mspec{G(\phi \otimes \psi)}
                       {\readcell c}
                       {a}{G(\phi \otimes \psi) \land \exists z.\;a = (v, z) \land \mathit{set}(\setof{c}, z, \setof{c})} 
\\[1em]

\mbox{\textsc{AUnready}} & 
  \setof{\unready{\phi \otimes \celleither{c}{e}}{c}} \specand \\
& \forall \psi.\; \mspec{G(\phi \otimes \psi)}
                       {e}
                       {a}{G(\phi' \otimes R(u, \psi)) \land \exists z.\; a = (v, z) \land \mathit{set}(r, z, r)} \\
& \specimp \\
& \begin{array}{ll}
   \forall \psi. & \left<G(\phi \otimes \celleither{c}{e} \otimes \psi)\right> \\
                 & \readcell c \\
                 & \left<a.\; 
                     \begin{array}{l}
                       G(R(\setof{c}, \phi') \otimes \cellpos{c}{e}{v}{r} \otimes R(u \cup \setof{c}, \psi)) 
                        \;\land \\
                        \exists z.\;a = (v, z) \land \mathit{set}(\setof{c}, z, \setof{c})
                     \end{array}\right> 
  \end{array}
\\[3em]

\mbox{\textsc{AGetRef}}
& \begin{array}{ll}
    \forall \psi.\; 
    &  \left<G(\localref{r}{v} \otimes \psi)\right> \\
    &  \getref r \\
    &  \left<a.\; G(\localref{r}{v} \otimes \psi) 
                  \land  \exists z.\;a = (v,z) \land \mathit{set}(\emptyset, z, \emptyset)
       \right> \\
     \end{array}
\\[2em]

\mbox{\textsc{ASetRef}}
& \begin{array}{ll}
    \forall \psi.\; 
    &  \left<G(\localref{r}{v'} \otimes \psi)\right> \\
    &  \setref r\;v \\
    &  \left<a.\; G(\localref{r}{v} \otimes \psi) 
                  \land  \exists z.\;a = (v,z) \land \mathit{set}(\emptyset, z, \emptyset)
       \right> \\
     \end{array}
\\[2em]

% \mbox{\textsc{ANewCell}}
% & \forall \psi.\; \mspec{G(\psi)}{\newcell e}{(c,z)}{G(\cellneg{c}{e} \otimes \psi) \land \mathit{set}(\emptyset, z, \emptyset)}
% \\[1em]

\mbox{\textsc{AConseq}}
& \setof{\phi' \vdash \phi} \specand \setof{\theta \vdash \theta'} \specand \\
& \forall \psi.\; \mspec{G(\phi \otimes \psi) \land P}{e}{(x,z)}{G(\theta\otimes R(u, \psi)) \land Q} \\
& \specimp \\
& \forall \psi.\; \mspec{G(\phi' \otimes \psi) \land P}{e}{(x,z)}{G(\theta'\otimes R(u, \psi)) \land Q} \specand \\

\end{array}
\end{mathpar}
\caption{Abstract Semantics of Notifications}
\label{abs-semantics}
\end{figure}





\subsubsection{Proving the correctness of \textsc{AUnit}}
\begin{prop*}{(The \textsc{AUnit} specification is sound)}
The following triple is derivable:
\begin{displaymath}
\forall \psi.\; \mspec{G(\psi)}
                     {\return v}
                     {a}{G(\psi) \land \exists z.\; a = (v, z) \land \mathit{set}(\emptyset, z, \emptyset)} 
\end{displaymath}
\end{prop*}

\begin{proof}
\begin{tabbedproof}
\oo Assume we have $\psi$ and a prestate $G(\psi)$ \\
\oo Now consider the body of $\return v$ \\
\oo $[(v, \mathsf{emptyset})]$ \\
\oo Hence we know that $\exists z.\; a = (v, z) \land \mathit{set}(\emptyset, z, \emptyset)$ \\
\ox and $G(\psi)$ \\
\end{tabbedproof}
\end{proof}

\subsubsection{Proving the correctness of \textsc{ABind}}

\begin{prop*}{(The \textsc{ABind} specification is sound)}
The following specification is derivable:
\begin{displaymath}
\begin{array}{l}
\forall \psi.\; \mspec{G(\phi \otimes \psi)}
                     {e}
                     {a}{G(\phi' \otimes R(u', \psi)) \land \exists z.\;a = (v', r') \land \mathit{set}(r', z, r')} 
                \specand \\
\forall \psi.\; \mspec{G(\phi' \otimes \psi)}
                        {f\;v'}
                        {a}{G(\phi'' \otimes R(u'', \psi)) \land \exists z.\; a = (v'', z) \land \mathit{set}(r'', z, r'')}\\
specimp \\
\begin{array}{ll}
     \forall \psi. & \left<G(\phi \otimes \psi)\right> \\
                   & \bind e\;f \\
                   &  \left<a.\;G(\phi'' \otimes R(u' \cup u'', \psi)) \land \exists z.\;a = (v'', z) \land \mathit{set}(r' \cup r'', z, r' \cup r'')\right> \\
   \end{array}
\end{array}
\end{displaymath}
\end{prop*}

\begin{proof}
\begin{tabbedproof}
\oo Assume $\forall \psi.\; \mspec{G(\phi \otimes \psi)}
                     {e}
                     {a}{G(\phi' \otimes R(u', \psi)) \land \exists z.\;a = (v', r') \land \mathit{set}(r', z, r')}$ \\
\oo Assume $\forall \psi.\; \mspec{G(\phi' \otimes \psi)}
                        {f\;v'}
                        {a}{G(\phi'' \otimes R(u'', \psi)) \land \exists z.\; a = (v'', z) \land \mathit{set}(r'', z, r'')}$ \\
\oo Assume we have $\psi$, and a prestate $G(\phi \otimes \psi)$ \\
\ooo Now consider the body of $\bind$ \\
\ooo $[\letv{(v, z_1)}{e}{}$ \\
\ooo So we know $G(\phi' \otimes R(u', \psi)) \land v = v' \land \mathit{set}(r', z_1, r')$ \\
\ooo Simplifying $v$ away, we continue with \\
\ooo $\letv{(v, z_2)}{f\;v'}{}$ \\
\ooo Now we know $G(\phi'' \otimes R(u'', R(u', \psi))) \land v = v'' \land \mathit{set}(r', z_1, r') \land \mathit{set}(r'', z_2, r'')$ \\
\ooo Hence with $z = \mathsf{union}\;z_1\;z_2$ we know $\mathit{set}(r' \cup r'', z, r' \cup r'')$ \\
\ooo $(v, \mathsf{union}\;z_1\;z_2)]$ \\
\ooo Hence $G(\phi'' \otimes R(u' \cup u'', \psi)) \land \exists z.\; a = (v'', z) \land \mathit{set}(r' \cup r'', z, r' \cup r'')$ 
\end{tabbedproof}
\end{proof}

\subsubsection{Proving the correctness of \textsc{AReady}}

In this subsection, we will prove the following proposition: 

\begin{prop*}{(The \textsc{AReady} specification is sound)}
The following specification holds: 
\begin{displaymath}
\begin{array}{ll}
  \setof{\ready{\phi}{c}{v}} \specimp \\
& \forall \psi.\; \mspec{G(\phi \otimes \psi)}
                       {\readcell c}
                       {a}{G(\phi \otimes \psi) \land \exists z.\;a = (v, z) \land \mathit{set}(\setof{c}, z, \setof{c})} 
\end{array}
\end{displaymath}
\end{prop*}

\begin{proof}
\begin{tabbedproof}
\oo Assume $\ready{\phi}{c}{v}$ and a $\psi$ \\
\ooo Now assume we have a precondition $G(\phi \otimes \psi)$ \\
\ooo So there is an $H = (D,h)$ such that $\mathit{Inv}(H, \phi \otimes \psi)$ holds \\
\ooo So we know that $H, D \models \phi \otimes \psi$ and $\mathit{heap}(H)$ \\
\ooo So we know that $c \pointsto \mathit{value}(h(c))$ \\
\ooo From soundness we know that $\mathit{value}(h(c)) = \Some(v)$ \\
\ooo $[\letv{o}{[!c.value]}{}$ \\
\ooo So we know that $o = \Some(v)$ \\
\ooo Now we can simplify the case statement and continue \\
\ooo $(v, \mathsf{singleton}\;c)]$ \\
\ooo So we know that $\exists z.\;a = (v, z) \land \mathit{set}(\setof{c}, z, \setof{c})$ \\
\oox and $\mathit{Inv}(H, \phi \otimes \psi)$ holds \\
\ooo So $G(H, \phi \otimes \psi)$ and $\exists z.\;a = (v, z) \land \mathit{set}(\setof{c}, z, \setof{c})$ hold
\end{tabbedproof}
\end{proof}

\subsubsection{Proving the correctness of \textsc{AUnready}}

In this subsection, we will prove the following proposition:

\begin{prop*}{(Soundness of the \text{AUnready} specification)}
The following triple holds:
\begin{displaymath}
\begin{array}{ll}
\mbox{\textsc{AUnready}} & 
  \setof{\unready{\phi \otimes \celleither{c}{e}}{c}} \specand \\
& \forall \psi.\; \mspec{G(\phi \otimes \psi)}
                       {e}
                       {a}{G(\phi' \otimes R(u, \psi)) \land \exists z.\; a = (v, z) \land \mathit{set}(r, z, r)} \\
& \specimp \\
& \begin{array}{ll}
   \forall \psi. & \left<G(\phi \otimes \celleither{c}{e} \otimes \psi)\right> \\
                 & \readcell c \\
                 & \left<a.\; 
                     \begin{array}{l}
                       G(R(\setof{c}, \phi') \otimes \cellpos{c}{e}{v}{r} \otimes R(u \cup \setof{c}, \psi)) 
                        \;\land \\
                        \exists z.\;a = (v, z) \land \mathit{set}(\setof{c}, z, \setof{c})
                     \end{array}\right> 
  \end{array}
\end{array}
\end{displaymath}
\end{prop*}

This follows the standard pattern of (1) proving that the update
preserves the relevant order structure, (2) proving the new abstract
formula continues models the updated abstract heap, and finally (3)
showing the code actually implements this update. 


\begin{lemma}{(Reading an Unready Cell Preserves Order Structure)}
Suppose that $H = (D,h)$ and $c \in D - V_H$. Then for any subset $r
\subseteq V_H$ and value $v$, define $h'$ so that
\begin{itemize}
\item $\mathit{code} \circ h' = \mathit{code} \circ h$ 
\item $\mathit{value} \circ h' = \semfun{c'}{\IfThenElse{c' = c}{\Some(v)}{\mathit{value}(h(c'))}}$ 
\item $\mathit{reads} \circ h' = \semfun{c'}{\IfThenElse{c' = c}{r}{\mathit{reads}(h(c'))}}$ 
\item $\mathit{obs} \circ h' = \semfun{c'}{\IfThenElse{c' \in r}{\mathit{obs}(h(c')) \cup \setof{c}}{\mathit{obs}(h(c'))}}$ 
\item $\mathit{identity} \circ h' = \mathit{identity} \circ h$
\end{itemize}
\noindent Then it is the case that $H' = (D,h')$ satisfies the five properties below. 
\begin{enumerate}
\item $V_{H'} = V_H \cup \setof{c}$
\item $R^+_{H'}$ is a strict partial order 
\item $R_{H'} \subseteq V_{H'} \times V_{H'}$
\item $R^\dagger_{H'} = O_{H'}$ 
\item $\mathit{unique}(H') = \mathit{unique}(H)$
\end{enumerate}
\end{lemma}

\begin{proof}
\begin{enumerate}
\item $V_{H'} = V_H \cup \setof{c}$ 
  \begin{tabbedproof}
    \oo So we want to show that $a \in V_{H'}$ iff $a \in V_H \cup \setof{c}$ \\
    \oo Assume that $a \in V_{H'}$ \\
    \ooo So we know that $\mathit{value}(h'(a)) = \Some(u)$ for some $u$ \\
    \ooo Now consider whether $a$ is $c$ \\
    \ooo Suppose $a = c$: \\
    \oooo Then $a \in \setof{c}$, and hence $a \in V_H \cup \setof{c}$ \\
    \ooo Suppose $a \not= c$: \\
    \oooo Then we know that $\mathit{value}(h'(a)) = \mathit{value}(h(a))$ \\
    \oooo Since $\mathit{value}(h'(a)) = \Some(u)$, we know $a \in V_H$ \\
    \oooo Hence $a \in V_H \cup \setof{c}$ \\
    \oo Assume that $a \in V_H \cup \setof{c}$ \\
    \ooo Now consider whether $a$ is $c$ \\
    \ooo Suppose $a = c$: \\
    \oooo Then $\mathit{value}(h'(a)) = \Some(v)$ \\
    \oooo Therefore $a \in V_{H'}$ \\
    \ooo Suppose $a \not= c$: \\
    \oooo Then $a \in V_H$ \\
    \oooo Also, $\mathit{value}(h'(a)) = \mathit{value}(h(a))$ \\
    \oooo Therefore there is a $u$ such that $\mathit{value}(h'(a)) = \Some(u)$ \\
    \oooo Hence $a \in V_{H'}$ \\
  \end{tabbedproof}

\item $R^+_{H'}$ is a strict partial order 
  \begin{tabbedproof}
    \oo This follows if $R^+_{H'}$ is a transitive, irreflexive relation \\
    \oo Since it is a transitive closure, it is a transitive relation \\
    \oo So we want to show there is no $a \in D$ such that $(a,a) \in R^+_{H'}$ \\
    \oo Consider an arbitrary $(a_0, b) \in R^+_{H'}$ \\
    \oo Hence there is a sequence $a_0, \ldots, a_k$ such that $b = a_k$ and each $a_{i+1} \in \mathit{reads}(h'(a_i))$ \\
    \oo Now consider whether $c$ is equal to any of the $a_i$ \\
    \oo Suppose $a_i \not= c$ for all $0 \leq i \leq k$: \\
    \ooo Then in this case, it follows that $\mathit{reads}(h'(a_i)) = \mathit{reads}(h'(a_i))$ for all $i$\\
    \ooo Then $(a_0, a_k) \in R^+_H$ \\
    \ooo Thn $a_0 \not= a_k$ since $R^+_H$ is irreflexive \\
    \oo Suppose $a_i = c$ for some $0 \leq i \leq k$: \\
    \ooo Note $\mathit{reads}(h'(a)) \subseteq V_H$ for all $a$  \\
    \ooo Since $c \not\in V_H$, it follows $c \not\in \mathit{reads}(h'(a))$ for any $a$ \\
    \ooo Hence $i = 0$, and $c \not= a_j$ for any $j > 0$ \\
    \ooo Therefore $a \not= b$ for any sequence of length greater than 1 \\
    \ooo Since $r \subseteq V_H$, it follows that  $a \not\in \mathit{reads}(h(a))$ \\
    \ooo Hence $a \not= b$ for sequences of length 1, too \\
  \end{tabbedproof}

\item $R_{H'} \subseteq V_{H'} \times V_{H'}$ 
  \begin{tabbedproof}
    \oo We want to show that for all $(a,b)$, if $b \in \mathit{reads}(h'(a))$, then $a \in V_{H'}$ and $b \in V_{H'}$ \\
    \oo Assume $b \in \mathit{reads}(h'(a))$ \\
    \ooo Now consider whether $a = c$  \\
    \ooo Suppose $a = c$: \\
    \oooo Then $a \in V_{H'}$ \\
    \oooo Since $\mathit{reads}(h'(c)) = r$, we know $r \subseteq V_H$ \\
    \oooo Since $V_{H} \subseteq V_{H'}$, it follows $b \in V_{H'}$ \\
    \ooo Suppose $a \not= c$: \\
    \oooo Then $\mathit{reads}(h'(a)) = \mathit{reads}(h(a))$ \\
    \oooo Then $b \in \mathit{reads}(h(a))$, and so $(a,b) \in R_H$ \\
    \oooo Since $R_H \subseteq V_H \times V_H$, we know $a \in V_H$ and $b \in V_H$ \\
    \oooo Since $V_{H} \subseteq V_{H'}$, we know $a \in V_{H'}$ and $b \in V_{H'}$ \\
  \end{tabbedproof}

\item $R^\dagger_{H'} = O_{H'}$ 
  \begin{tabbedproof}
    \oo We want to show that for all $(a,b)$, we have $(a,b) \in R^\dagger_{H'}$ iff $(a,b) \in O_{H'}$ \\
    \oo Assume $(a,b) \in R^\dagger_{H'}$ \\
    \ooo Then $(b, a) \in R_{H'}$ \\
    \ooo So $a \in \mathit{reads}(h'(b))$ \\
    \ooo We want to show that $b \in \mathit{obs}(h'(a))$ \\
    \ooo Consider whether $b = c$ \\
    \ooo Suppose $b = c$: \\
    \oooo Then $a \in r$, since $\mathit{reads}(h'(b)) = r$ \\
    \oooo Therefore $\mathit{obs}(h'(a)) = \mathit{obs}(h(a)) \cup \setof{c}$ \\
    \oooo Hence $b \in \mathit{obs}(h'(a))$ \\
    \ooo Suppose $b \not= c$: \\
    \oooo Then $\mathit{reads}(h'(b)) = \mathit{reads}(h(b))$ \\
    \oooo So $a \in \mathit{reads}(h(b))$ \\
    \oooo Hence $b \in \mathit{obs}(h(a))$ \\
    \oooo Since $\mathit{obs}(h(x)) \subseteq \mathit{obs}(h(x))$ for all $x$, $b \in \mathit{obs}(h'(a))$ \\
    \oo Assume $(a,b) \in O_{H'}$ \\
    \ooo Then $b \in \mathit{obs}(h'(a))$ \\
    \ooo We want to show that $a \in \mathit{reads}(h'(b))$ \\
    \ooo Consider whether $b = c$ \\
    \ooo Suppose $b = c$: \\
    \oooo Now consider whether $a \in r$ \\
    \oooo Suppose $a \in r$: \\
    \ooooo Then by definition $a \in \mathit{reads}(h'(b))$ \\
    \oooo Suppose $a \not\in r$: \\
    \ooooo Then $\mathit{obs}(h'(a)) = \mathit{obs}(h(a))$ \\
    \ooooo So $b \in \mathit{obs}(h(a))$ \\
    \ooooo But $\mathit{obs}(h(a)) \subseteq V_H$, and $b = c \not\in V_H$ \\
    \ooooo So this case is impossible \\
    \ooo Suppose $b \not= c$: \\
    \oooo Consider whether $a = c$: \\
    \oooo Suppose $a = c$: \\
    \ooooo This case is impossible since $c \not\in V_H$ and $\mathit{obs}(h'(x)) = \emptyset$ for any $x \not\in V_H$ \\
    \oooo Suppose $a \not= c$: \\
    \ooooo Then it follows that $b \in \mathit{obs}(h(a))$ \\
    \ooooo Then it follows that $a \in \mathit{reads}(h(b))$ \\
    \ooooo Therefore $a \in \mathit{reads}(h'(b))$ 
  \end{tabbedproof}

\item $\mathit{unique}(H') = \mathit{unique}(H)$

This is immediate since $\mathit{identity} \circ h' = \mathit{identity} \circ h$.
\end{enumerate}
\end{proof}

\begin{lemma}{(Reading an Unready Cell, Semantically)}
Suppose that $H = (D,h)$ and $H, D' \models \phi \otimes
\celleither{c}{e}$ and $c \in D' - V_H$. Then for any subset $r
\subseteq V_H$ and value $v$, define $h'$ so that
\begin{itemize}
\item $\mathit{code} \circ h' = \mathit{code} \circ h$ 
\item $\mathit{value} \circ h' = \semfun{c'}{\IfThenElse{c' = c}{\Some(v)}{\mathit{value}(h(c'))}}$ 
\item $\mathit{reads} \circ h' = \semfun{c'}{\IfThenElse{c' = c}{r}{\mathit{reads}(h(c'))}}$ 
\item $\mathit{obs} \circ h' = \semfun{c'}{\IfThenElse{c' \in r}{\mathit{obs}(h(c')) \cup \setof{c}}{\mathit{obs}(h(c'))}}$ 
\item $\mathit{identity} \circ h' = \mathit{identity} \circ h$
\end{itemize}
Then it follows that for $H' = (D,h')$, we have $H', D' \models R(\setof{c}, \phi) \otimes \cellpos{c}{e}{v}{r}$.
\end{lemma}

\begin{proof}
  \begin{tabbedproof}
    \oo Assume $H, D' \models \phi \otimes \celleither{c}{e}$ and $c \in D' - V_H$ \\
    \ooo Then there are $D_1, D_2$ with $D' = D_1 \uplus D_2$ and $H, D_1 \models \phi$ and $H, D_2 \models \celleither{c}{e}$ \\
    \ooo Then $c \in D_2$ and $c \not \in D_1$, and $\mathit{value}(h(c)) = \None$ \\
    \ooo By assumption, $\mathit{value}(h'(c)) = \Some(v)$ and $\mathit{reads}(h'(c)) = r$ \\
    \ooo Hence $H', D_2 \models \cellpos{c}{e}{v}{r}$ \\
    \ooo Now proceed by induction on $\phi$, letting the support $D_1$ be a parameter \\
    \ooo Case $\phi = I$: \\
    \oooo By definition $H', D_1 \models I$ \\
    \ooo Case $\phi = \psi \otimes \theta$: \\
    \oooo So we know there are $D_3, D_4$ such that $D_1 = D_3 \uplus D_4$ and \\
    \oooox $H, D_3 \models \psi$ and \\
    \oooox $H, D_4 \models \theta$ \\
    \oooo By induction, we know that \\
    \oooox $H', D_3 \models R(\setof{c}, \psi)$ and \\
    \oooox $H', D_4 \models R(\setof{c}, \theta)$ \\
    \oooo Hence $H', D_1 \models R(\setof{c}, \psi) \otimes R(\setof{c}, \theta)$ \\
    \oooo Hence $H', D_1 \models R(\setof{c}, \psi \otimes \theta)$ \\

    \ooo Case $\phi = \cellneg{c'}{e'}$: \\
    \oooo So we know that $c' \not\in V_H$ and $c' \not= c$ and $\mathit{code}(h(c')) = e'$ and $c' \in D_1$\\
    \oooo Hence $c' \not\in V_{H'}$ \\
    \oooo Hence $H', D_1 \models \cellneg{c'}{e'}$ \\
    \oooo Hence $H', D_1 \models R(\setof{c}, \cellneg{c'}{e'})$ \\

    \ooo Case $\phi = \cellpos{c'}{e'}{v'}{r'}$: \\
    \oooo Now consider whether $r' \subseteq V_H$ \\
    \oooo Suppose $r' \subseteq V_{H}$: \\
    \ooooo So $\mathit{value}(h(c')) = \Some(v')$ and $\mathit{reads}(h(c')) = r'$ and
           $\mathit{code}(h(c')) = e'$ and $a \in D$ \\
    \ooooo Since $c \not \in D_1$, we know $c' \not= c$ \\
    \ooooo Therefore $\mathit{value}(h'(c')) = \Some(v')$ \\
    \ooooo Therefore $\mathit{reads}(h'(c')) = r'$ \\
    \ooooo Since $V_{H'} \supseteq V_H$, it follows that $r' \cap V_{H'} = r'$ \\
    \ooooo Therefore $H', D_1 \models \cellpos{c'}{e'}{v'}{r'}$ \\
    \ooooo Furthermore, since $r' \subseteq V_H$, we know $c \not\in r'$ \\
    \ooooo Hence $R(\setof{c}, \cellpos{c'}{e'}{v'}{r'}) = \cellpos{c'}{e'}{v'}{r'}$ \\
    \oooo Suppose $r' \not\subseteq V_{H}$: \\
    \ooooo Then $c' \not\in V_H$ and $c' \not= c$\\
    \ooooo So $c' \not \in V_{H'}$ \\
    \ooooo Now, consider whether $c \in r'$: \\
    \ooooo Suppose $c \in r'$: \\
    \oooooo Since $c' \not \in V_{H'}$, we know $H', D_1 \models \cellneg{c'}{e'}$ \\
    \oooooo Hence $H', D_1 \models R(\setof{c}, \cellpos{c'}{e'}{v'}{r'})$ \\
    \ooooo Suppose $c \not\in r'$: \\
    \oooooo Then since $r' \not\subseteq V_H$, there is $x \in r'$ such that $x \not \in V_H$ and $x \not= c$ \\
    \oooooo Therefore $r' \not\subseteq V_{H'}$ \\
    \oooooo Therefore $H', D_1 \models \cellpos{c'}{e'}{v'}{r'}$ \\
    \oooooo Therefore $H', D_1 \models R(\setof{c}, \cellpos{c'}{e'}{v'}{r'})$ 
  \end{tabbedproof}
\end{proof}

\begin{prop*}{(Soundness of the \text{AUnready} specification)}
The following triple holds:
\begin{displaymath}
\begin{array}{ll}
\mbox{\textsc{AUnready}} & 
  \setof{\unready{\phi \otimes \celleither{c}{e}}{c}} \specand \\
& \forall \psi.\; \mspec{G(\phi \otimes \psi)}
                       {e}
                       {a}{G(\phi' \otimes R(u, \psi)) \land \exists z.\; a = (v, z) \land \mathit{set}(r, z, r)} \\
& \specimp \\
& \begin{array}{ll}
   \forall \psi. & \left<G(\phi \otimes \celleither{c}{e} \otimes \psi)\right> \\
                 & \readcell c \\
                 & \left<a.\; 
                     \begin{array}{l}
                       G(R(\setof{c}, \phi') \otimes \cellpos{c}{e}{v}{r} \otimes R(u \cup \setof{c}, \psi)) 
                        \;\land \\
                        \exists z.\;a = (v, z) \land \mathit{set}(\setof{c}, z, \setof{c})
                     \end{array}\right> 
  \end{array}
\end{array}
\end{displaymath}
\end{prop*}

\begin{proof}
\begin{tabbedproof}
\oo Assume $\unready{\phi \otimes \celleither{c}{e}}{c}$ \\
\oo Assume $\forall \psi.\; 
       \mspec{G(\phi \otimes \psi)}
            {e}
            {a}{G(\phi' \otimes R(u, \psi)) \land \exists z.\; a = (v, z) \land \mathit{set}(r, z, r)} $ \\
\oo Assume we have some $\psi$ \\
\ooo Assume we are in a prestate $G(\phi \otimes \psi)$ \\
\ooo So there is an $H = (D,h)$ such that $\mathit{Inv}(H, \phi \otimes \psi)$ holds \\
\ooo Hence we know that \\
\ooox $R^\dagger_H = O_H$ \\
\ooox $R^+_H$ strict partial order \\
\ooox $R_H \subseteq V_H \times V_H$ \\
\ooox $\mathit{unique}(H)$ \\
\ooox $H, D \models \phi \otimes \psi$ \\
\ooox $\mathit{heap}(H)$ \\
\ooo Since $\mathsf{unready}$ is sound, we know that $\mathit{value}(h'(c)) = \None$ \\
\ooo Hence we also know that $H, D \models \phi \otimes \cellneg{c}{e} \otimes \psi$ \\
\ooo We also know that $c.\mathit{value} \pointsto \None$ \\
\ooo $[\letv{o}{!a.\mathit{value}}{}$ \\
\ooo Now we additionally know that $o = \None$ \\
\ooo Hence we can simplify the remaining program to eliminate the case \\
\ooo $\letv{exp}{!a.code}{}$ \\
\ooo From the definition of $\mathit{heap}$, we know that $exp = \mathit{code}(h(c))$ \\
\ooo From the fact that $H, D \models \phi \otimes \cellneg{c}{e} \otimes \psi$, \\
\oox we know $\mathit{code}(h(c)) = e$ \\
\ooo $\letv{(v',z)}{exp}{}$ \\
\ooo Using our assumption about $e$, and setting $\psi$ to $\cellneg{c}{e} \otimes \psi$, \\
\ooo our poststate is $G(\phi' \otimes R(u, \cellneg{c}{e} \otimes \psi)) \land v = v' \land \mathit{set}(r, z, r)$ \\
\ooo Simplifying away the $v'$, we get $\mathit{set}(r, z, r)$ and $G(\phi' \otimes \cellneg{c}{e} \otimes R(u, \psi))$ \\
\ooo Now take $H' = (D,h')$ and $h'$ as in the semantic update lemma \\
\ooo We know $H', D \models R(\setof{a}, \phi' \otimes \cellpos{c}{e}{v}{r} \otimes R(u, \psi))$\\
\ooo So we know $H', D \models R(\setof{a}, \phi') \otimes \cellpos{c}{e}{v}{r} \otimes R(u \cup \setof{a}, \psi))$ \\
\ooo Furthermore we know that this $H'$ preserves the relevant order structure \\
\ooo $\letv{\_}{[a.value := v']}{}$ \\
\ooo $\letv{\_}{[a.reads := z]}{}$ \\
\ooo $\letv{\_}{\mathsf{setiter}\;(\mathsf{add\_observer}\;a)\;z}{}$ \\
\ooo These commands establish $\mathit{heap}(H')$ \\
\ooo The last requires an induction based on the size of $r$ \\ 
\oox and the unfolding axiom in the cellset interface \\
\ooo Now we know $\mathit{Inv}(H', R(\setof{a}, \phi') \otimes \cellpos{c}{e}{v}{r} \otimes R(u \cup \setof{a}, \psi))$ \\
\ooo So we know $G(R(\setof{a}, \phi') \otimes \cellpos{c}{e}{v}{r} \otimes R(u \cup \setof{a}, \psi))$ \\
\ooo $(v, z)]$ \\
\ooo So $\exists z.\;a = (v,z) \land \mathit{set}(\setof{c}, z, \setof{c})$ 
\end{tabbedproof}
\end{proof}

\subsubsection{Proving the correctness of \textsc{AConseq}}

\begin{prop*}{(The correctness of the \textsc{AConseq} specification)}
The following specification is valid:
\begin{displaymath}
\begin{array}{l}
\setof{\phi' \vdash \phi} \specand \setof{\psi \vdash \psi'} \specand \\
\forall \psi.\; \mspec{G(\phi \otimes \psi) \land P}{e}{(x,z)}{G(\theta\otimes R(u, \psi)) \land Q} \\
\specimp \\
\forall \psi.\; \mspec{G(\phi' \otimes \psi) \land P}{e}{(x,z)}{G(\theta'\otimes R(u, \psi)) \land Q} \specand \\
\end{array}
\end{displaymath}
\end{prop*}

\begin{proof}
\begin{tabbedproof}
\oo Assume we know $\phi' \vdash \phi$ and $\psi \vdash \psi'$ \\
\oo Furthermore assume $\forall \psi.\; \spec{G(\phi \otimes \psi) \land P}{e}{(x,z)}{G(\theta\otimes R(u, \psi)) \land Q}$ \\
\ooo Now assume $\psi$, and that we are in a prestate $G(\phi' \otimes \psi) \land P$ \\
\ooo So we know there is an $H$ such that $\mathit{Inv}(H, \phi' \otimes \psi)$ \\
\ooo Since $\phi' \models \phi$, we know that $H, D \models \phi \otimes \psi$ \\
\ooo Hiding the existential again, we know that $G(\phi \otimes \psi) \land P$ \\
\ooo $e$
\ooo Now by assumption we know $G(\theta \otimes R(u, \psi)) \land Q$ \\
\ooo So we know there is an $H$ such that $\mathit{Inv}(H, \theta \otimes \psi)$ \\
\ooo Since $\theta \vdash \theta'$, we know that $\mathit{Inv}(H, \theta' \otimes \psi)$ \\
\ooo Hiding the existential, we get the poststate $G(\theta'\otimes R(u, \psi)) \land Q$ \\
\end{tabbedproof}
\end{proof}

\section{Implementing Functional Reactive Programming}

In this section, we will see how to verify an imperative
implementation of a simple synchronous functional reactive programming
system.

\subsection{Specifying Functional Reactive Programs}

\emph{Functional Reactive Programming}~\cite{frp} is a style of
writing interactive programs based on the idea of \emph{stream
  transducers}.  The idea is to model a time-varying input signal of
type $A$ as an infinite stream of $A$'s, and to model an interactive
system as a function that takes a stream of inputs $\stream{A}$ and
yields a stream of outputs $\stream{B}$. Note that a stream can be
viewed either as an infinite sequence of values, or isomorphically as
a function from natural numbers to values (i.e., a function from times
to values). In our discussion, we'll switch freely between these two
views, using the most convenient viewpoint.\footnote{Given an infinite stream $vs$, we will use use $take\;n\;vs$ to denote
the finite list consisting of the first $n$ elements of the stream
$vs$. Correspondingly, $drop\;n\;vs$ is the infinite stream with $vs$
with its first $n$ elements cut off. With a function $f$, $map\;f\;vs$
maps $f$ over the elements of $vs$, and given another infinite stream
$us$, the call $zip\;us\;vs$ returns the infinite stream of pairs of
elements of $us$ and $vs$. If $v$ is an element, $v \cdot vs$ will 
denote consing $v$ to the front of $vs$, and if $xs$ is a finite list, then
$xs \cdot vs$ will denote appending the finite sequence $xs$ to the
front of $vs$. Finally, we will write $vs_n$ to denote the $n$-th element
of the stream $vs$.}

However, not all functions $\stream{A} \to \stream{B}$ are legitimate
stream transducers; we need to restrict our attention to \emph{causal}
stream transducers. A transducer is causal if we can compute the first
$n$ elements of the output after having read at most $n$ elements of
the input. 

\begin{tabbing}
$causal(f : \stream{A} \to \stream{B}) \equiv$ \\
\;\;\= $\exists \hat{f} : \listtype{A} \to \listtype{B}.\;\forall as:\stream{A}, n:\N.$ \\
    \> \;\;$take\;n\;(f\;as) = \hat{f}\;(take\;n\;as)$ 
\end{tabbing}

If we are given a causal transducer $p$, we will write $\hat{p}$ to
indicate the corresponding list function which computes its finite
approximations. Then, we can define a family of combinators acting on
causal transducers, which we give in Figure~\ref{transducer-semantics}.

\begin{figure}
\mbox{}
\begin{tabbing}
$\ST{A}{B} = \comprehend{f \in \stream{A} \to \stream{B}}{causal(f)}$\\[1em]

$lift : (A \to B) \to \ST{A}{B}$ \\
$lift\;f\;as = map\;f\;as$ \\[1em]

$seq  : \ST{A}{B} \to \ST{B}{C} \to \ST{A}{C}$ \\
$seq\;p\;q = q \circ p$ \\[1em]

$par  : \ST{A}{B} \to \ST{C}{D} \to \ST{A \times C}{B \times D}$ \\
$par\; p\;q\;abs = zip\; (p\;(map\;\pi_1\;abs))\;(q\;(map\;\pi_2\;abs))$\\[1em]

$switch : \N \to \ST{A}{B} \to \ST{A}{B} \to \ST{A}{B}$ \\
$switch\;k\;p\;q = \semfun{as}{(take\;k\;(p\;as))\cdot(q\;(drop\;k\;as))}$ \\[1em]

$loop : A \to \ST{A\times B}{A \times C} \to \ST{B}{C}$ \\
$loop\;a_0\;p = (map\;\pi_2) \circ (cycle\;a_0\;p)$ \\[1em]

$cycle : A \to \ST{A\times B}{A \times C} \to \ST{B}{A \times C}$ \\
$cycle\;a_0\;p = \lambda bs.\;\lambda n.\;last(gen\;a_0\;p\;v\;n)$ \\[1em]

$gen : A \to \ST{A\times B}{A \times C} \to \listtype{(A \times C)}$\\
$gen\;a_0\;p\;bs\;0 \;\;\; = \hat{p}\; [(a_0, bs_0)]$ \\
$gen\;a_0\;p\;bs\;(n+1) = $ \\
\;\;$\hat{p}\;(zip (a_0 \cdot (map\;\pi_1\;(gen\;a_0\;p\;bs\;n)))\;
                                        (take\;(n+2)\;bs))$ 
\end{tabbing}
\caption{Semantics of Stream Transducers}
\label{transducer-semantics}
\end{figure}

The operation $lift\;f$ creates a stream transducer that simply maps
the function $f$ over its input. Calls to $seq\;p\;q$ are sequential
composition: it feeds the output of $p$ into the input of $q$. The
operator $par\;p\;q$ defines parallel composition --- it takes a
stream of pairs, and feeds each component to its arguments,
respectively, and then merges the two output streams to produce the
combined output stream. The function $switch\;k\;p\;q$ is a very
simple ``switching combinator''.  It behaves as if it were $p$ for the
first $k$ time steps, and then behaves as if it were $q$, only
starting with the input stream beginning at time $k$.

The combinator $loop\;a_0\;p$ is a feedback operation. It acts
upon a transducer $p$ which takes pairs of $A$s and $B$s, and yields
pairs of $A$s and $C$s. It turns it into a combinator that takes $B$s
to $C$s, by giving $p$ the value $a_0$ (and its $B$-input) on the
first time step, and uses the output $A$ at time $n$ as the input $A$
at time $n+1$. This is useful for constructing transducers that do
things like sum their inputs over time, and other stateful operations. 

Because this function involves feedback, it should not be surprising
that it makes use of the causal nature of its argument operation. The
$loop$ function is defined in terms of $cycle$, which also returns the
sequence of output $A$s, and $cycle$ is defined in terms of $gen$,
which is a function that given an argument $n$ returns a list of
outputs for the time steps from $0$ to $n$. Notice that
$gen\;a_0\;p\;bs\;n$ will always return $n+1$ elements (e.g., at
argument 0, it will return a 1 element list containing the output at
time step 0), which means that the call to $last$ in $cycle$ is
actually safe. In order to calculate $gen$, we need to recursively
calculate the outputs for all smaller time steps, and this is what
$\hat{p}$ is needed for --- it is what lets us know that $p$ has a good
finite approximation.

All of these definitions are familiar to functional programmers, and
there are many techniques to prove properties of these functions ---
coinductive proofs, the $take$-lemma of \citet{bird-wadler}, arguments based on
the isomorphism between streams and functions from natural
numbers. All of these serve to make proving properties about stream
transducers very pleasant. For example, one property we will need in
the next section is the following:

\begin{lemma}{(Loop Unrolling)} We have that 
  \begin{displaymath}
    cycle\;a_0\;p\;bs = f\;(zip\;(a_0\cdot(map\;\pi_1\;(cycle\;a_0\;p\;bs)))\;bs)
  \end{displaymath}
\end{lemma}

\begin{proof}
  This is easily proved using Bird and Wadler's $take$-lemma, which
  says that two streams are equal if all their finite prefixes are
  equal.
\end{proof}


\subsection{Realizing Stream Transducers with Notifications}

\begin{figure}
\mbox{}
\begin{tabbing}
$\ST{A}{B} \equiv \celltype{A} \to \monad{\celltype{B}}$ \\[1em]

$\liftop : (A \to B) \to \ST{A}{B}$ \\
$\liftop\;f\;input = $ \\
\;\; $\newcell\; (\bind\;(\readcell input)\; (\fun{x}{A}{\return (f\;x)}))$ \\[1em]

$\composeop : \ST{A}{B} \to \ST{B}{C} \to \ST{A}{C}$ \\
$\composeop p\;q\;input = [$\=$\letv{middle}{p\;input}$ \\
                            \>$\letv{output}{q\;middle}$ \\ 
                            \>$\;output]$ \\[1em]

$\parop : \ST{A}{B} \to \ST{C}{D} \to \ST{A \times C}{B \times D}$ \\
$\parop p \; q \; input = $ \\
\;\;$[$\=$\ctext{letv}\;a = \newcell\; (\bind$\=$(\readcell\;input)$ \\
     \>                                   \>$(\fun{x}{A\times B}{\return (\fst{x})}))$ \\
     \>$\ctext{letv}\;b = {p\;a}{}$ \\
     \>$\ctext{letv}\;c = \newcell\; (\bind$\=$(\readcell\;input)\;$\\ 
     \>                                   \>$(\fun{x}{A\times B}{\return (\snd{x})}))$ \\
     \>$\ctext{letv}\;d = {q\;b} = $ \\
     \>$\ctext{letv}\;output = \newcell\; ($\=$\bind (\readcell b)\; (\lambda b:B.$ \\
     \>                                   \>$\bind (\readcell d)\; (\lambda d:D.$ \\
     \>                                   \>$\;\;\return \pair{b}{d})))] \;\ctext{in}$ \\
     \>$\;output]$ \\[1em]

$\switchop : \N \to \ST{A}{B} \to \ST{A}{B} \to \ST{A}{B}$ \\
$\switchop k\;p\;q\; input =  $ \\
\;\;$[$\=$\letv{r}{\newref{\N}{0}}{}$ \\
    \>$\letv{a}{p\;input}$ \\
    \>$\letv{b}{p\;input}$ \\
    \>$\ctext{letv}\; out = \newcell\; ($\=$\bind (\getref r) \;(\lambda i:\N.\;$ \\
    \>                                 \>$\bind (\setref r\;(i+1)) \; (\lambda q:\unittype.$ \\
    \>                                 \>$\;\;\ctext{if}(i < k, \readcell a, \readcell b)))) \;\ctext{in}$ \\
    \>$\;\;out]$\\[1em]

$\loopop : A \to \ST{A\times B}{A\times C} \to \ST{B}{C}$ \\
$\loopop a_0\; p \; input = $ \\
\;\;$[$\=$\letv{r}{\newref{A}{a_0}}{}$ \\
    \>$\ctext{letv}\; ab = \newcell\; ($\=$\bind (\readcell input)\; (\lambda b:B.$ \\
    \>                                \>$\bind (\getref r)\;       (\lambda a:A.$ \\
    \>                                \>$\;\; \return \pair{a}{b}))) \;\ctext{in}$ \\
    \>$\letv{ac}{p\;ab}{}$ \\
    \>$\ctext{letv}\;c = \newcell\; ($\=$\bind (\readcell ac) \;(\lambda v:A \times C.$ \\
    \>                              \>$\bind (\setref r\;(\fst{v})) \;(\lambda q:\unittype.$ \\
    \>                              \>$\;\;\return (\snd{v}))))\;\ctext{in}$ \\
    \>$\;\;c]$ 
\end{tabbing}
\caption{Imperative Stream Transducers}
\label{imperative-transducer-semantics}
\end{figure}

While the definitions in the previous subsection yield very clean
proofs, they are not suitable as implementations --- for example,
$loop$ recomputes an entire history at each time step! We can derive
better implementations by thinking about how imperative, event-driven
programming works.

The intuition underlying event-driven programming is that a stream
transducer is implemented with the combination of a notification
network, and an \emph{event loop}.  The event loop is a
(possibly-infinite) loop which updates an input cell at teach time
step, to reflect the events that occurred on that time step, and then
it reads the output cell of the network. When the input cell is
updated, invalidations are propagated throughout the dependency
network, and when the outputs are read, exactly the necessary
re-computations are performed.

We will shortly formalize exactly this idea, but we will first discuss
the implementation given in
Figure~\ref{imperative-transducer-semantics} in informal terms. Here,
we define the type of imperative stream transducers as a function type
$\celltype{A} \to \monad{(\celltype{B})}$. This type should be read as
saying that the implementation is a function that, given an input cell
of type $A$, will \emph{construct} a dataflow notification network
realizing the corresponding transducer, and whose return value is the
output cell of type $B$ that the event loop should read. 

The simplest example of this is $\liftop\;f$. It will take an input
cell $input$, and build a new cell which reads $input$, and return $f$
applied to that value. Likewise, given two imperative implementations $p$
and $q$, $\composeop\;p\;q$ will take an input cell, and feed the
input to $p$ to build a network whose output is named $middle$, and
will then give $middle$ to $q$ to get the final output cell. The
overall network will be network built by the calls to both $p$ and
$q$, which interact through $p$'s network putting a value in $middle$,
and $q$'s network reading it.

The operation $\switchop\;k\;p\;q$ is the first example that uses 
local state. Given an $input$ cell, we first build networks corresponding
to $p$ and to $q$ (with outputs $a$ and $b$, respectively). Then we
create a local reference $r$, initialized to $0$. Then we build a cell $out$,
whose code reads and increments $r$, and which will read $a$ or $b$ depending
on whether the reference's contents are less than or equal to $k$. Notice
that the demand-driven nature of evaluation means that we never redundantly
evaluate $p$ or $q$'s networks --- we only ever execute one of them. 

Finally, the operation $\loopop a_0\;p$ builds a feedback network by
explicitly creating a reference to hold an accumulator parameter. It
constructs a local reference initialized to $a_0$, and then constructs
a cell $ab$ which reads the input and the local reference to produce a
pair of type $A \times B$. This cell is given to $p$, to construct a
network with an output cell $ac$, yielding pairs of type $A \times
C$. Finally, we construct the overall output cell $c$, which reads
$ac$ and updates the local reference with a new value of type $A$, and
returns a value of type $C$. The use of a local reference (rather than
a cell) to store the current state of $A$ is essential, because we need
to maintain the acyclicity of the dataflow graph. 

\subsection{Specifying Transducers}

\begin{specification}
\nextline $\mathit{Transduce}(vs, i, \phi, o, ws)  =  $
\nextline $\forall \theta, n.\; \unready{\theta}{i} \implies \unready{\theta \otimes \phi_n}{o} \specand$ 
\nextline $\forall \theta, n.\; \ready{\theta}{i}{vs_n} \implies \ready{\theta \otimes \phi_{n+1}}{o}{ws_n} \specand$
\nextline $\forall n.\; \closed{\phi_n}{\domain{\phi_n} \cup \setof{i}} \specand$ 
\nextline $\forall n.\; o \in \domain{\phi_n} \specand$
\nextline $\forall n.\; \unready{R(\setof{i}, \phi_n)}{o} \specand$
\nextline\;\; $\forall n, \theta, \theta', u \subseteq \domain{\theta}.$  
\nextline\qquad\=$(\ready{\theta}{i}{v_n} \land \theta = \theta' \land u = \emptyset \specor
                         \unready{\theta}{i} \land i \in u) \specand$ 
\nextline\> $\ready{\theta'}{i}{v_n} \specand \closed{\theta'}{\domain{\theta'}} \specand$
\nextline\> $\forall \psi.\;$\=$\left<G(\theta \otimes \psi)\right>$ 
\nextline\>\> $\readcell i$
\nextline\>\> $\left<a.\;a = (vs_n, \setof{i}) \land G(\theta' \otimes R(u,\psi)\right>$ 
\nextline\> $\specimp$ 
\nextline\> $\exists \setof{o} \subseteq u' \subseteq \domain{\phi_n}.\;  \forall \psi.\;$\=$\left<G(\theta \otimes R(\setof{i}, \phi_n) \otimes \psi)\right>$ 
\nextline\>\>$\readcell o$ 
\nextline\>\>$\left<a.\;a = (ws_n, \setof{o}) \land 
                        G(\theta' \otimes \phi_{n+1} \otimes R(u \cup u', \psi))\right>$ 
\end{specification}


\begin{specification}
\nextline $\mathit{Realize}(\mathsf{\hat{f}}, f) = $ 
\nextline\;\;\= $\forall \psi, vs.\; \spec{G(\psi)}{\mathsf{\hat{f}}\;i}{a}{\exists \phi.\;G(\psi \otimes \phi_0) \land \mathit{Transduce}(vs, i, \phi, a, f\;vs)}$
\end{specification}

\subsection{Correctness Proofs}

\begin{prop}{(FRP Correctness)}
Then, the following specifications are provable: 
\begin{enumerate}
\item $\forall f:A\to B.\; \mathit{Realize}(\liftop f, \mathit{lift}\;f)$
\item $\forall p, f, q, g.\;\mathit{Realize}(p, f) \specand \mathit{Realize}(q, g) \specimp \mathit{Realize}(\composeop p\;q, \mathit{compose}\;f\;g)$
\item $\forall p, f, q, g.\;\mathit{Realize}(p, f) \specand \mathit{Realize}(q, g)
                       \specimp \mathit{Realize}(\parop p\;q, par\;f\;g)$
\item $\forall k, p, f, q, g.\;\mathit{Realize}(p, f) \specand \mathit{Realize}(q, g)
                          \specimp \mathit{Realize}(\switchop k\;p\;q, switch\;k\;f\;g)$
\item $\forall a_0, p, f.\; \mathit{Realize}(p, f) \specimp \mathit{Realize}(\loopop\;a_0\;p, loop\;a_0\;f)$
\end{enumerate}

\end{prop}

\noindent To prove these properties, we will first prove transduction lemmas for each kind of 
network, and then show that each operator creats an appropriate network. 

\subsubsection{Correctness of $\mathsf{lift}$}

\begin{lemma}{(The $\mathsf{lift}$ network)}
It is the case that $\mathit{Transduce}(vs, i, \phi, c, \mathit{lift}\;f\;vs)$ holds, when
\begin{itemize}
\item $\phi = \semfun{n}{\cellpos{c}{e}{ws_n}{\setof{i}}}$, where $ws = x \cdot (f\;vs)$ for some dummy $x$ and
\item $e = \bind (\readcell i)\; (\semfun{v}{\return (f\;v)})$
\end{itemize}
\end{lemma}

\begin{proof}
\begin{itemize}
\item First, it is clear that for all $\theta$ and $n$, if $\unready{\theta}{i}$, then $\unready{\theta \otimes \phi_n}{c}$, since $i$ is in the read set of $\phi_n$. 
\item Second, it is clear that for all $\theta$ and $n$, if $\ready{\theta}{i}{v_n}$, then $\ready{\theta \otimes \phi_n}{c}{(f\;v)_n}$, since the read set of $\phi_n$ is $i$, which is by hypothesis ready. 
\item Third, it is immediately clear that for all $n$, $\closed{\phi_n}{\setof{i} \cup \domain{\phi_n}}$,
since $\phi_n$ has a single cell whose read set contains only $i$. 
\item Fourth, for all $n$, we know that $R(\setof{i}, \phi_n) = \cellneg{c}{e}$, which obviously satisfies $\unready{R(\setof{i}, \phi_n)}{c}$ 
\end{itemize}
Now we need to show the implication over triples. 
\begin{tabbedproof}
\oo Assume we have $n$, $\theta$, $\theta'$ and $u$. \\
\oo Assume that either $\ready{\theta}{i}{v_n}$ and $\theta = \theta'$ and $u = \emptyset$,  \\
\oo or $\unready{\theta}{i} \land i \in u$ \\
\oo Assume that $\closed{\theta'}{\domain{\theta'}}$ and that $\ready{\theta'}{i}{v_n}$ \\
\oo Assume for all $\psi$, we have \\
\ox  $\mspec{G(\theta \otimes \psi)}{\readcell i}{a}{a = ((f\;v)_n, \setof{c}) 
      \land G(\theta' \otimes R(u,\psi))}$ \\
\oo Now assume we have a $\psi$ and a prestate $G(\theta \otimes R(\setof{i}, \phi_n) \otimes \psi)$ \\
\oo We know $R(\setof{i}, \phi_n) = \cellneg{c}{e}$ \\
\oo So we know $\unready{\theta \otimes R(\setof{i}, \phi_n) \otimes \psi}{c}$ \\
\oo By the \textsc{AUnready}, \textsc{ABind}, and \textsc{AUnit} rules, we end in a state \\
\oo $G(R(u',\theta') \otimes \cellpos{c}{e}{f\;v_n}{\setof{i}} \otimes R(u \cup u',\psi)) \land a = (f\;v_n, \setof{o})$ \\
\oo where $u' = \setof{c}$ \\
\oo Since $c$ does not occur in $\theta'$ or else false is entailed, we know $c \not\in \domain{\theta'}$ \\
\oo Since $\theta'$ is closed with respect to its domain, $R(u',\theta') = \theta'$ \\
\oo Note that $f\;v_n = (\mathit{lift}\;f\;v)_n$, hence we have the conclusion we want. \\
\end{tabbedproof}

\end{proof}

\subsubsection{Correctness of $\mathsf{compose}$}

\begin{lemma}{(The $\mathsf{compose}$ network)}
If it is the case that $\mathit{Transduce}(vs, i, \phi, m, f\;vs)$ holds, and that
$\mathit{Transduce}(f\;vs, m, \sigma, o, g(f\;vs))$ holds, then it is the case that
$\mathit{Transduce}(vs, i, \phi \otimes \sigma, o, g\;(f\;vs))$ holds.
\end{lemma}

\begin{proof}
\begin{itemize}
\item First, we want to show that for all $\theta, n$, if $\unready{\theta}{i}$ then $\unready{\theta \otimes \phi_n \otimes \sigma_n}{o}$. 

  To show this assume $\unready{\theta}{i}$. Then we know from $\mathit{Transduce}(vs, i, \phi, m, f\;vs)$
  that $\unready{\theta \otimes \phi_n}{m}$. Then we know from $\mathit{Transduce}(f\;vs, m, \sigma, o, g(f\;vs))$
  that $\unready{\theta \otimes \phi_n \otimes \sigma_n}{o}$. 

\item Second, we want to show that for all $\theta, n$, if
  $\ready{\theta}{i}{vs_n}$ then $\ready{\theta \otimes \phi_n \otimes
  \sigma_{n+1}}{o}{(f\;vs)_n}$.

  Assume $\ready{\theta}{i}{vs_n}$. 

  Then we know from $\mathit{Transduce}(vs, i, \phi, m, f\;vs)$ that
  $\ready{\theta \otimes \phi_{n+1}}{m}{(f\;vs)_n}$. Then we know from
  $\mathit{Transduce}(f\;vs, m, \sigma, o, g(f\;vs))$ that
  $\ready{\theta \otimes \phi_{n+1} \otimes
    \sigma_{n+1}}{o}{(g\;(f\;vs))_n}$.

\item Third we want to show that $o \in \domain{\phi_n \otimes \sigma_n}$. Since $o \in \domain{\sigma_n}$,
  it follows immediately that $o \in \domain{\phi_n \otimes \sigma_n}$. 

\item Fourth, we want to show that $\closed{\phi_n \otimes \sigma_n}{\domain{\phi_n \otimes \sigma_n} \cup \setof{i}}$. We know that  $\closed{\phi_n}{\domain{\phi_n} \cup \setof{i}}$ and 
$\closed{\sigma_n}{\domain{\sigma_n} \cup \setof{m}}$. So we know that $\closed{\phi_n \otimes \sigma_n}{\domain{\phi_n \otimes \sigma_n} \cup \setof{i,m}}$. Since $m \in \domain{\phi_n}$, we have that
$\closed{\phi_n \otimes \sigma_n}{\domain{\phi_n \otimes \sigma_n} \cup \setof{i}}$
\end{itemize}

Now, let's prove the entailment of specifications. 

\begin{tabbedproof}
\oo Assume we have $\theta, \theta', n$, and $u$. \\
\oo Assume that either $\ready{\theta}{i}{v_n}$ and $\theta = \theta'$ and $u = \emptyset$,  \\
\oo or $\unready{\theta}{i} \land i \in u$ \\
\oo Assume that $\closed{\theta'}{\domain{\theta'}}$ \\
\oo Assume that $\ready{\theta'}{i}{v_n}$ and $\closed{\theta'}{\domain{\theta'}}$ \\
\oo Assume for all $\psi$, we have \\
\ox  $\mspec{G(\theta \otimes \psi)}{\readcell i}{a}{a = ((f\;v)_n, \setof{c}) 
      \land G(\theta' \otimes R(u,\psi)) }$ \\
\oo Assume we have a $\psi$. Now, we use the hypothesis above, together \\
\oo with the fact that $\mathit{Transduce}(f\;vs, m, \sigma, o, g(f\;vs))$ holds, \\
\oo to conclude that there is a $u'$ such that $\setof{m} \subseteq u' \subseteq \domain{\phi_n}$ and \\
\ox $\left<G(\theta \otimes R(\setof{i}, \phi_n) \otimes \psi)\right>$ \\
\ox $\readcell m$ \\
\ox $\left<a.\;G(\theta' \otimes \phi_{n+1} \otimes R(u \cup u',\psi)
             \land  a = ((f\;v)_n, \setof{m})\right>$ \\
\oo Note that since $\theta'$ is closed with respect to its own domain and $\phi_n$ is closed with \\
\oo respect to $i$ and its own domain, we have $\closed{\theta' \otimes \phi_{n+1}}{\domain{\theta' \otimes \phi_{n+1}}}$ \\
\oo Note also that $m \in u \cup u'$ and $\unready{\theta \otimes R(\setof{i}, \phi_n)}{m}$ \\
\oo Furthermore, since $\ready{\theta'}{i}{v_n}$, we know $\ready{\theta' \otimes \phi_{n+1}}{m}{(f\;v)_n}$ \\
\oo Hence from $\mathit{Transduce}(f\;vs, m, \sigma, o, g(f\;vs))$, we can conclude that \\
\oo there is a $u''$ such that $\setof{o} \subseteq u'' \subseteq \domain{\sigma_n}$ and for all $\psi$ \\
\ox $\left<G(\theta \otimes R(\setof{i}, \phi_n) \otimes R(\setof{m}, \sigma_n) \otimes \psi)\right>$ \\
\ox $\readcell o$ \\
\ox $\left<a.\;G(\theta' \otimes \phi_{n+1} \otimes \sigma_{n+1} \otimes R(u \cup u' \cup u'',\psi)
             \land a = ((f\;v)_n, \setof{o})\right>$ \\
\oo Since $\unready{\theta \otimes R(\setof{i}, \phi_n)}{m}$, we know that \\
\oo $\unready{\theta \otimes R(\setof{i}, \phi_n) \otimes \sigma_n}{m}$ \\
\oo Hence $\theta \otimes R(\setof{i}, \phi_n) \otimes \sigma_n \vdash R(\setof{m}, \theta \otimes R(\setof{i}, \phi_n) \otimes \sigma_n)$ \\
\oo Hence $\theta \otimes R(\setof{i}, \phi_n) \otimes \sigma_n \vdash \theta \otimes R(\setof{i}, \phi_n) \otimes R(\setof{m}, \sigma_n)$ \\
\oo Since $i \not\in \domain{\sigma_n} \cup \setof{m}$, we know $R(\setof{i}, \sigma_n) = \sigma_n$ \\
\oo Hence $\theta \otimes R(\setof{i}, \phi_n) \otimes R(\setof{i}, \sigma_n) \vdash \theta \otimes R(\setof{i}, \phi_n) \otimes R(\setof{m}, \sigma_n)$ \\
\oo Hence $\theta \otimes R(\setof{i}, \phi_n \otimes \sigma_n) \vdash \theta \otimes R(\setof{i}, \phi_n) \otimes R(\setof{m}, \sigma_n)$ \\
\oo Hence we can conclude that \\
\ox $\left<G(\theta \otimes R(\setof{i}, \phi_n \otimes \sigma_n) \otimes R(\setof{m}, \sigma_n) \otimes \psi)\right>$ \\
\ox $\readcell o$ \\
\ox $\left<a.\;G(\theta' \otimes \phi_{n+1} \otimes \sigma_{n+1} \otimes R(u \cup u' \cup u'',\psi)
             \land a = ((f\;v)_n, \setof{o})\right>$ \\
\oo Note that $u' \cup u'' \subseteq \domain{\phi_n \otimes \sigma_n}$, which is the existential witness
\end{tabbedproof}
\end{proof}

\subsubsection{Correctness of $\mathsf{par}$}

\begin{lemma}{(The $\mathsf{par}$ network)}
If it is the case that $\mathit{Transduce}(v, i, \phi, b, f\;v)$ holds, and that
$\mathit{Transduce}(v, i, \sigma, c, g\;v)$ holds, then it is the case that
$\mathit{Transduce}(v, i, \phi \otimes \sigma \otimes \omega, o, \mathit{par}\;f\;g\;v)$ holds,
where 

\begin{itemize}
\item $\omega = \semfun{n}{\cellpos{o}{e}{ws_n}{\setof{b,c}}}$, where $ws = x \cdot (\mathit{par}\;f\;g\;v)$ for some dummy $x$ and
\item $e = \bind (\readcell a)\; (\semfun{x}{\bind (\readcell b)\; (\semfun{y}{\return (x,y)})})$
\end{itemize}
\end{lemma}

\begin{proof}
\begin{itemize}
\item We want to show that $\unready{\theta}{i}$ implies $\unready{\theta \otimes \phi_n \otimes \sigma_n \otimes \omega_n}{o}$ 

  Assume that $\unready{\theta}{i}$ holds. Then we know by hypothesis
  that $\unready{\theta \otimes \phi_n}{b}$ holds. This lets us conclude
  that $\unready{\theta \otimes \phi_n \otimes \omega_n}{o}$ holds. From this,
  it follows that $\unready{\theta \otimes  \phi_n \otimes \sigma_n \otimes \omega_n}{o}$.

\item We want to show that $\ready{\theta}{i}{v_n}$ implies $\ready{\theta \otimes \phi_{n+1} \otimes \sigma_{n+1} \otimes \omega_{n+1}}{o}{(\mathit{par}\;f\;g\;v)_n}$ 

  Assume that $\ready{\theta}{i}{v_n}$ holds. Then we know that 
  $\ready{\theta \otimes \phi_{n+1}}{b}{(f\;v)_n}$ holds, and that 
  $\ready{\theta \otimes \sigma_{n+1}}{c}{(g\;v)_n}$ holds. 

  So we know that $\ready{\theta \otimes \phi_{n+1} \otimes \sigma_{n+1} \otimes \omega_{n+1}}{b}{(f\;v)_n}$ holds.

  So we know that $\ready{\theta \otimes \phi_{n+1} \otimes \sigma_{n+1} \otimes \omega_{n+1}}{c}{(g\;v)_n}$ holds.

  Hence $\ready{\theta \otimes \phi_{n+1} \otimes \sigma_{n+1} \otimes \omega_{n+1}}{o}{(\mathit{par}\;f\;g\;v)_n}$ holds.

\item We want to show that $\closed{\phi_n \otimes \sigma_n \otimes \omega_n}{\domain{\phi_n \otimes \sigma_n \otimes \omega_n} \cup \setof{i}}$ 

  We know $\closed{\phi_n}{\domain{\phi_n} \cup \setof{i}}$. 
  We know $\closed{\sigma_n}{\domain{\sigma_n} \cup \setof{i}}$. 
  We know $\closed{\omega_n}{\domain{\omega_n} \cup \setof{b,c}}$. 

  So $\closed{\phi_n \otimes \sigma_n \otimes \omega_n}{\domain{\phi_n \otimes \sigma_n \otimes \omega_n} \cup \setof{i, b, c}}$ .

  But $b \in \domain{\phi_n}$ and $c \in \domain{\sigma_n}$, so 
   $\closed{\phi_n \otimes \sigma_n \otimes \omega_n}{\domain{\phi_n \otimes \sigma_n \otimes \omega_n} \cup \setof{i}}$. 

\item We want to show that $o \in \domain{\omega_n}$. This is immediate. 
\end{itemize}

\begin{tabbedproof}
\oo Assume we have $\theta, \theta', n$, and $u$. \\
\oo Assume that either $\ready{\theta}{i}{v_n}$ and $\theta = \theta'$ and $u = \emptyset$,  \\
\oo or $\unready{\theta}{i} \land i \in u$ \\
\oo Assume that $\closed{\theta'}{\domain{\theta'}}$ \\
\oo Assume that $\ready{\theta'}{i}{v_n}$ and $\closed{\theta'}{\domain{\theta'}}$ \\
\oo Assume for all $\psi$, we have \\
\ox  $\mspec{G(\theta \otimes \psi)}{\readcell i}{a}{a = ((f\;v)_n, \setof{c}) 
      \land G(\theta' \otimes R(u,\psi)) }$ \\
\oo Since $\mathit{Transduce}(v, i, \phi, b, f\;v)$, we can conclude that \\
\oo there is a $u'$ such that $\setof{b} \subseteq u' \subseteq \domain{\phi_n}$, \\
\oo $\forall \psi.\;\mspec{G(\theta \otimes R(\setof{i},\phi_n) \otimes \psi)}{\readcell b}{a}{a = ((f\;v)_n, \setof{b}) \land G(\theta' \otimes \phi_{n+1} \otimes R(u \cup u', \psi))}$ \\
\oo Now, note that $\ready{\theta'}{i}{v_n}$, so by rule \textsc{AReady} we can conclude that \\
\oo $\forall \psi.\;\mspec{G(\theta' \otimes \psi)}{\readcell i}{a}{a = (v_n, \setof{i}) \land G(\theta' \otimes \psi)}$ \\
\oo So from $\mathit{Transduce}(v, i, \sigma, c, f\;v)$, we can conclude that\\
\oo there is a $u''$ such that $\setof{c} \subseteq u'' \subseteq \domain{\sigma_n}$ and \\
\oo $\forall \psi.\;\mspec{G(\theta' \otimes R(\setof{i},\sigma_n) \otimes \psi)}{\readcell c}{a}{a = ((g\;v)_n, \setof{c}) \land G(\theta' \otimes \phi_{n+1} \otimes R(u'', \psi))}$ \\
\oo Now let $u''' = u' \cup u'' \cup \setof{o}$ \\
\oo So we want to show that \\
\oo $\forall \psi.\;$\=$\left<G(\theta \otimes R(\setof{i},\phi_n \otimes \sigma_n \otimes \omega_n) \otimes \psi)\right>$ \\
\oo \> ${\readcell c}$ \\
\oo \> $\left<{a.\;a = ((\mathit{par}\;f\;g\;v)_n, \setof{c}) \land G(\theta' \otimes \phi_{n+1} \otimes \sigma_{n+1} \otimes \omega_{n+1} \otimes R(u'', \psi))}\right>$ \\
\oo Since $c$ is unready in the precondition, we need to use the \textsc{AUnready} rule. \\
\oo So consider the expression $e$, in a state \\
\oo $G(\theta \otimes R(\setof{i},\phi_n \otimes \sigma_n) \otimes \psi)$ \\
\oo Now, to use the \textsc{ABind} rule, consider  $\readcell b$. By hypothesis, we end up in a state \\
\oo $G(\theta' \otimes \phi_{n+1} \otimes R(u' \cup \setof{i},\sigma_n) \otimes R(u', \psi)) \land (x,r_1) = ((f\;v)_n, \setof{b})$ \\
\oo Since the domains of $\phi$ and $\sigma$ are disjoint, this is equivalent to (pulling out $(x,r_1) = ((f\;v)_n, \setof{b})$) \\
\oo Also, since $i \in u'$, \\
\oo $G(\theta' \otimes \phi_{n+1} \otimes R(\setof{i},\sigma_n) \otimes R(u', \psi))$ \\
\oo Now, using the \textsc{ABind} rule again, consider $\readcell b$. By hypothesis, we end up in a state \\
\oo $G(\theta' \otimes R(u'',\phi_{n+1}) \otimes \sigma_{n+1} \otimes R(u' \cup u'', \psi)) \land (y,r_2) = ((g\;v)_n, \setof{b, c})$ \\
\oo Since the domains of $\phi$ and $\sigma$ are disjoint, this is equivalent to (pulling out $(y,r_2) = ((g\;v)_n, \setof{b, c})$) \\
\oo $G(\theta' \otimes \phi_{n+1} \otimes \sigma_{n+1} \otimes R(u' \cup u'', \psi)) \land (y, r_2) = ((g\;v)_n, \setof{b,c})$ \\
\oo Now, by the \textsc{AReturn} rule and the definition of $\mathit{par}$, we get \\
\oo $G(\theta' \otimes \phi_{n+1} \otimes \sigma_{n+1} \otimes R(u' \cup u'', \psi)) \land a = ((\mathit{par}\;f\;g\;v)_n, \setof{b,c})$ \\
\oo So the final state is \\
\oo $G(R(\setof{c}, \theta' \otimes \phi_{n+1} \otimes \sigma_{n+1}) \otimes \omega_{n+1} \otimes R(\setof{c} \cup u' \cup u'', \psi)) \land a = ((\mathit{par}\;f\;g\;v)_n, \setof{c})$ \\
\oo Since $c$ is not in the domain of $\theta', \phi_{n+1},$ or $\sigma_{n+1}$, and these are all suitably closed\\
\oo $G(\theta' \otimes \phi_{n+1} \otimes \sigma_{n+1} \otimes \omega_{n+1} \otimes R(u''', \psi)) \land a = ((\mathit{par}\;f\;g\;v)_n, \setof{c})$ \\
\end{tabbedproof}
\end{proof}

\subsubsection{Correctness of $\mathsf{switch}$}

\begin{lemma}{(The $\mathsf{par}$ network)}
If it is the case that for all $v$, $\mathit{Transduce}(v, i, \phi, b,
f\;v)$ holds, and that for all $v$,
$\mathit{Transduce}(\mathit{drop}\;k\;v, i, \sigma, c, g\;v)$ holds,
then it is the case that $\mathit{Transduce}(v, i, \omega, o,
\mathit{switch}\;k\;f\;g\;v)$ holds, where

\begin{itemize}
\item $\omega = \semfun{n}{\left\{\begin{array}{ll}
                                    \localref{r}{n} \otimes \phi_n \otimes R(\setof{i}, \sigma_0) \otimes \delta_n 
                                    & \mbox{if } n < k \\
                                    \localref{r}{n} \otimes R(\setof{i}, \phi_k) \otimes \sigma_{n-k} \otimes \delta_n 
                                    & \mbox{otherwise} \\
                                   \end{array}\right.}$
\item $\delta_n = \left\{\begin{array}{ll}
                          \cellpos{o}{e}{(\mathit{switch}\;f\;g\;v)_n}{\setof{b}} & \mbox{if } n < k\\
                          \cellpos{o}{e}{(\mathit{switch}\;f\;g\;v)_n}{\setof{c}} & \mbox{otherwise} \\
                         \end{array}
                 \right.$
\item $e = \bind (\getref r)\; (\semfun{n}{\bind (\setref r\;(n+1))\; (\semfun{\unit}{\IfThenElse{n < k}{\readcell b}{\readcell c}})})$
           

\end{itemize}
\end{lemma}

\begin{proof}
\begin{itemize}
\item First, we need to show that $\unready{\theta}{i}$ implies $\unready{\theta \otimes \omega_n}{o}$. 

  \begin{tabbedproof}
    \oo To prove this, assume $\unready{\theta}{i}$ and consider whether $n < k$:\\
    \oo If $n < k$:\\
    \ooo Then $\omega_n = \localref{r}{n} \otimes \phi_n \otimes R(\setof{i}, \sigma_0) \otimes \delta_n$ \\
    \ooo So we know that $\unready{\theta \otimes \phi_n}{b}$ holds \\
    \ooo So we know that $\unready{\theta \otimes \omega_n}{b}$ holds \\
    \ooo Since $\delta_n = \cellpos{o}{e}{(\mathit{switch}\;f\;g\;v)_n}{\setof{b}}$, we can see that \\
    \ooo $\unready{\theta \otimes \omega_n}{b}$ \\
    \oo If $n \geq k$: \\
    \ooo Then $\omega_n = \localref{r}{n} \otimes R(\setof{i}, \phi_k) \otimes \sigma_{n-k} \otimes \delta_n$ \\
    \ooo So we know that $\unready{\theta \otimes \sigma_{n-k}}{c}$ holds \\
    \ooo So we know that $\unready{\theta \otimes \omega_n}{c}$ holds \\
    \ooo Since $\delta_n = \cellpos{o}{e}{(\mathit{switch}\;f\;g\;v)_n}{\setof{c}}$, we can see that \\
    \ooo $\unready{\theta \otimes \omega_n}{c}$ \\
  \end{tabbedproof}

\item We want to show that $\ready{\theta}{i}{v_n}$ implies $\ready{\theta \otimes \omega_{n+1}}{o}{(\mathit{par}\;f\;g\;v)_n}$. 

  \begin{tabbedproof}
    \oo To prove this, assume $\ready{\theta}{i}{v_n}$ and consider whether $n < k$:\\
    \oo If $n < k$:\\
    \ooo Then $\omega_n = \localref{r}{n} \otimes \phi_n \otimes R(\setof{i}, \sigma_0) \otimes \delta_n$ \\
    \ooo So we know that $\ready{\theta \otimes \phi_n}{b}{(f\;v)_n}$ holds \\
    \ooo So we know that $\ready{\theta \otimes \omega_n}{b}{(f\;v)_n}$ holds \\
    \ooo Since $\delta_n = \cellpos{o}{e}{(\mathit{switch}\;f\;g\;v)_n}{\setof{b}}$, we can see that \\
    \ooo $\ready{\theta \otimes \omega_n}{b}{(\mathit{switch}\;f\;g\;v)_n}$ \\
    \oo If $n \geq k$: \\
    \ooo Then $\omega_n = \localref{r}{n} \otimes R(\setof{i}, \phi_k) \otimes \sigma_{n-k} \otimes \delta_n$ \\
    \ooo So we know that $\ready{\theta}{i}{(\mathit{drop}\;k\;v)_{n-k}}$ \\
    \ooo So we know that $\ready{\theta \otimes \sigma_{n-k}}{c}{(g\;v)_{n-k}}$ holds \\
    \ooo So we know that $\ready{\theta \otimes \omega_n}{c}{(g\;v)_{n-k}}$ holds \\
    \ooo Since $\delta_n = \cellpos{o}{e}{(\mathit{switch}\;f\;g\;v)_n}{\setof{c}}$, we can see that \\
    \ooo $\ready{\theta \otimes \omega_n}{b}{(\mathit{switch}\;f\;g\;v)_n}$ \\
  \end{tabbedproof}

\item Now we want to show that $\closed{\omega_n}{\domain{\omega_n} \cup \setof{i}}$. 

  \begin{tabbedproof}
    \oo Suppose $n < k$:\\
    \ooo Then $\omega_n = \localref{r}{n} \otimes \phi_n \otimes R(\setof{i}, \sigma_0) \otimes \delta_n$ \\
    \ooo So $\closed{\phi_n}{\domain{\phi_n} \cup \setof{i}}$ and \\
    \ooox $\closed{\sigma_0}{\domain{\sigma_n} \cup \setof{i}}$ so $\closed{R(\setof{i}, \sigma_0)}{\domain{R(\setof{i}, \sigma_n)} \cup \setof{i}}$ and \\
    \ooox $\closed{\delta_n}{\setof{b}}$ \\
    \ooo Since $b \in \domain{\phi_n}$, it follows that $\closed{\omega_n}{\domain{\omega_n} \cup \setof{i}}$ \\
    \oo Suppose $n \geq k$:\\
    \ooo Then $\omega_n = \localref{r}{n} \otimes R(\setof{i}, \phi_k) \otimes \sigma_{n-k} \otimes \delta_n$ \\
    \ooo So $\closed{\sigma_{n-k}}{\domain{\sigma_{n-k} \cup \setof{i}}}$ and \\
    \ooox $\closed{\phi_k}{\domain{\phi_k} \cup \setof{i}}$ so $\closed{R(\setof{i}, \phi_k)}{\domain{R(\setof{i}, \phi_k)} \cup \setof{i}}$ and \\
    \ooox $\closed{\delta_n}{\setof{c}}$ \\
    \ooo Since $c \in \domain{\sigma_{n-k}}$, it follows that $\closed{\omega_n}{\domain{\omega_n} \cup \setof{i}}$  \end{tabbedproof}

\item Next, we want to show that $o \in \domain{\omega_n}$, which is immediate. 
\end{itemize}

Now we will show the implication over triples. 
\begin{tabbedproof}
\oo Assume we have $\theta, \theta', n$, and $u$. \\
\oo Assume that either $\ready{\theta}{i}{v_n}$ and $\theta = \theta'$ and $u = \emptyset$,  \\
\oo or $\unready{\theta}{i} \land i \in u$ \\
\oo Assume that $\closed{\theta'}{\domain{\theta'}}$ \\
\oo Assume that $\ready{\theta'}{i}{v_n}$ and $\closed{\theta'}{\domain{\theta'}}$ \\
\oo Assume for all $\psi$, we have \\
\ox  $\mspec{G(\theta \otimes \psi)}{\readcell i}{a}{a = ((f\;v)_n, \setof{c}) 
      \land G(\theta' \otimes R(u,\psi)) }$ \\
\oo Now suppose $n < k$: \\
\ooo In this case, $e$ in $\delta_n$ simplifies to \\
\oooo $e = \bind (\getref r)\; (\semfun{n}{\bind (\setref r\;(n+1))\; (\semfun{\unit}{\readcell b})})$ \\
\ooo Now assume we have $\psi$ and note that  \\
\oooo since we know $\mathit{Transduce}(v, i, \phi, b, (f\;v)_n)$, we can conclude that \\
\oooo there is a $u'$ such that $\setof{b} \subseteq u' \subseteq \domain{\phi_n}$ such that \\
\oooo $\left<G(\theta \otimes \localref{r}{n+1} \otimes R(\setof{i}, \phi_n) \otimes R(\setof{i}, \sigma_0) \otimes \psi)\right>$ \\
\oooo $\readcell b$\\
\oooo $\left<a.\;G(\theta' \otimes \localref{r}{n+1} \otimes \phi_{n+1} \otimes R(u' \cup \setof{i}, \sigma_0) \otimes R(u', \psi))
      \land a = ((f\;v)_n, \setof{b})\right>$ \\
\ooo Choose a witness to the existential equal to $u' \cup \setof{o}$ and consider the prestate \\
\ooo $G(\theta \otimes R(\setof{i}, \omega_n) \otimes \psi)$ \\
\ooo We know $R(\setof{i}, \omega_n) = \theta \otimes \localref{r}{n} \otimes R(\setof{i}, \phi_n) \otimes R(\setof{i}, \sigma_0) \otimes \delta_n$ \\
\ooo Now, we know that $\unready{\theta \otimes \omega_n \otimes \psi}{o}$, since $\delta_n$'s read set \\
\ooo contains $b$, which is unready \\
\ooo So to evaluate $\readcell o$, we need to use the \textsc{AUnready} rule \\
\ooo So we need to evaluate $e$ in the state \\
\ooo $G(\theta \otimes \localref{r}{n} \otimes R(\setof{i}, \phi_n) \otimes R(\setof{i}, \sigma_0) \otimes \psi)$ \\
\ooo We begin with the \textsc{ABind} rule, which asks us to evaluate $\getref r$, which gives us \\
\ooo $G(\theta \otimes \localref{r}{n} \otimes R(\setof{i}, \phi_n) \otimes R(\setof{i}, \sigma_0) \otimes \psi) \land (n_1,r_1) = (n,\emptyset)$ \\
\ooo So now we need to evaluate $\bind (\setref r\;(n+1))\; (\semfun{\unit}{\readcell b})$ in \\
\ooo $G(\theta \otimes \localref{r}{n+1} \otimes R(\setof{i}, \phi_n) \otimes R(\setof{i}, \sigma_0) \otimes \psi)$ \\
\ooo Using the \textsc{ABind} rule, we need to evaluate $\setref r\;(n+1)$, which yields  \\
\ooo $G(\theta \otimes \localref{r}{n+1} \otimes R(\setof{i}, \phi_n) \otimes R(\setof{i}, \sigma_0) \otimes \psi)$ \\
\ooo with the need to consider $\readcell b$ \\
\ooo Using the triple we derived above, we get \\
\ooo $G(\theta' \otimes \localref{r}{n+1} \otimes \phi_{n+1} \otimes R(u' \cup \setof{i}, \sigma_0) \otimes R(u', \psi))
      \land a = ((f\;v)_n, \setof{b})$ \\
\ooo So then finishing the \textsc{AUnready} rule, we have a state \\
\ooo $G(R(\setof{o}, \theta' \otimes \localref{r}{n+1} \otimes \phi_{n+1} \otimes R(u' \cup \setof{i}, \sigma_0) \otimes R(u', \psi)) \otimes \delta_{n+1}) \land a = ((f\;v)_n, \setof{o})$\\
\ooo Simplifying using the closure properties, we get \\
\ooo $G(\theta' \otimes \localref{r}{n+1} \otimes \phi_{n+1} \otimes R(u' \cup \setof{i}, \sigma_0) \otimes \delta_{n+1} \otimes R(u' \cup \setof{o}, \psi))) \land a = ((f\;v)_n, \setof{o})$\\
\ooo which is \\
\ooo $G(\theta' \otimes \localref{r}{n+1} \otimes \phi_{n+1} \otimes R(u' \cup \setof{i}, \sigma_0) \otimes \delta_{n+1} \otimes R(u' \cup \setof{o}, \psi))) \land a = ((f\;v)_n, \setof{o})$\\
\ooo Since $(f\;v)_n = (\mathit{switch}\;k\;f\;g\;v)_n$, we have the conclusion \\
\oo Now suppose $n \geq k$: \\
\ooo In this case, $e$ in $\delta_n$ simplifies to \\
\oooo $e = \bind (\getref r)\; (\semfun{n}{\bind (\setref r\;(n+1))\; (\semfun{\unit}{\readcell c})})$ \\
\ooo Now assume we have $\psi$ and note that  \\
\oooo since we know $\mathit{Transduce}(\mathit{drop}\;k\;v, i, \sigma, c, (g\;(\mathit{drop}\;k\;v))_n)$, we can conclude that \\
\oooo there is a $u'$ such that $\setof{c} \subseteq u' \subseteq \domain{\sigma_{n-k}}$ such that \\
\oooo $\left<G(\theta \otimes \localref{r}{n+1} \otimes R(\setof{i}, \phi_k) \otimes R(\setof{i}, \sigma_{n-k}) \otimes \psi)\right>$ \\
\oooo $\readcell c$\\
\oooo $\left<a.\;G(\theta \otimes \localref{r}{n+1} \otimes R(\setof{i}, \phi_k) \otimes \sigma_{n-k+1} \otimes R(u', \psi))
      \land a = ((g\;(\mathit{drop}\;k\;v))_{n-k}, \setof{b})\right>$ \\
\ooo making use of the observation that $(\mathit{drop}\;k\;v)_{n-k} = v_n$ \\
\ooo Choose a witness to the existential equal to $u' \cup \setof{o}$ and consider the prestate \\
\ooo $G(\theta \otimes R(\setof{i}, \omega_n) \otimes \psi)$ \\
\ooo We know $R(\setof{i}, \omega_n) = \theta \otimes \localref{r}{n} \otimes R(\setof{i}, \phi_k) \otimes R(\setof{i}, \sigma_{n-k}) \otimes \delta_n$ \\
\ooo Now, we know that $\unready{\theta \otimes \omega_n \otimes \psi}{o}$, since $\delta_n$'s read set \\
\ooo contains $c$, which is unready \\
\ooo So to evaluate $\readcell o$, we need to use the \textsc{AUnready} rule \\
\ooo So we need to evaluate $e$ in the state \\
\ooo $G(\theta \otimes \localref{r}{n} \otimes R(\setof{i}, \phi_k) \otimes R(\setof{i}, \sigma_{n-k}) \otimes \psi)$ \\
\ooo We begin with the \textsc{ABind} rule, which asks us to evaluate $\getref r$, which gives us \\
\ooo $G(\theta \otimes \localref{r}{n} \otimes R(\setof{i}, \phi_k) \otimes R(\setof{i}, \sigma_{n-k}) \otimes \psi) \land (n_1,r_1) = (n,\emptyset)$ \\
\ooo So now we need to evaluate $\bind (\setref r\;(n+1))\; (\semfun{\unit}{\readcell c})$ in \\
\ooo $G(\theta \otimes \localref{r}{n+1} \otimes R(\setof{i}, \phi_k) \otimes R(\setof{i}, \sigma_{n-k}) \otimes \psi)$ \\
\ooo Using the \textsc{ABind} rule, we need to evaluate $\setref r\;(n+1)$, which yields  \\
\ooo $G(\theta \otimes \localref{r}{n+1} \otimes R(\setof{i}, \phi_k) \otimes R(\setof{i}, \sigma_{n-k}) \otimes \psi)$ \\
\ooo with the need to consider $\readcell c$ \\
\ooo Using the triple we derived above, we get \\
\ooo $G(\theta' \otimes \localref{r}{n+1} \otimes R(\setof{i}, \phi_k) \otimes \sigma_{n-k+1} \otimes R(u', \psi))
      \land a = ((g\;(\mathit{drop}\;k\;v))_{n-k}, \setof{c})$ \\
\ooo Here, we have used the fact that $\phi_k$ is closed with respect to $u'$ to simplify the state\\
\ooo Hiding the equality, and then finishing the \textsc{AUnready} rule, we have a state \\
\ooo $G(R(\setof{o}, \theta' \otimes \localref{r}{n+1} \otimes R(\setof{i}, \phi_k) \otimes R(u' \cup \setof{i}, \sigma_0) \otimes R(u', \psi)) \otimes \delta_{n+1})$\\
\ooo Simplifying using the closure properties, we get \\
\ooo $G(\theta' \otimes \localref{r}{n+1} \otimes R(\setof{i}, \phi_k) \otimes R(u' \cup \setof{i}, \sigma_0) \otimes \delta_{n+1} \otimes R(u' \cup \setof{o}, \psi))$\\
\ooo which is \\
\ooo $G(\theta' \otimes \localref{r}{n+1} \otimes R(\setof{i}, \phi_k) \otimes R(u' \cup \setof{i}, \sigma_0) \otimes \delta_{n+1} \otimes R(u' \cup \setof{o}, \psi)))$\\
\ooo Note that $(\mathit{switch}\;k\;f\;g\;v)_n = (g\;(\mathit{drop}\;k\;v))_{n-k}$, so restoring the equality \\
\oox we get our goal
\end{tabbedproof}
\end{proof}

\subsubsection{Correctness of $\mathsf{loop}$}

\begin{lemma}
  Suppose that for all $xys$, we have $\mathit{Transduce}(xys, s,
  \phi, t, f\;xys)$. Then it is the case that for all $ys$ and $x$ we
  have $\mathit{Transduce}(ys, i, \sigma, o, \mathit{loop}\;x\;f\;ys)$, where

  \begin{itemize}
  \item $\sigma_n = \localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n} \otimes
                      \iota_n \otimes \phi_n \otimes \delta_n$ 
  \item $\iota_n = \cellpos{s}{e_1}{ws_n}{\setof{i}}$ where $ws_{n+1} = ((x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n, ys_n)$ and $ws_0$ is some dummy value\\
  \item $e_1 = \bind (\readcell i)\; \semfun{y}{\bind (\getref r)\; \semfun{x}{\return (x,y)}}$ \\
  \item $\delta_n = \cellpos{t}{e_2}{(z\cdot (\mathit{loop}\;x\;f\;ys))_n}{\setof{v}}$ for some dummy $z$ \\ 
  \item $e_2 = \bind (\readcell t)\; (\semfun{(x,z)}{
               \bind (\setref r\;x)\; (\semfun{\unit}{\return z}}))$ \\
  \end{itemize}
\end{lemma}

\begin{proof}
  \begin{itemize}
  \item 
  \item 
  \item 
  \item 
  \item 
  \item 
  \end{itemize}

Now, we'll prove the entailment of implications. 
\begin{tabbedproof}
\oo Assume we have $\theta, \theta', n$, and $u$. \\
\oo Assume that either $\ready{\theta}{i}{y_n}$ and $\theta = \theta'$ and $u = \emptyset$,  \\
\oo or $\unready{\theta}{i} \land i \in u$ \\
\oo Assume that $\closed{\theta'}{\domain{\theta'}}$ \\
\oo Assume that $\ready{\theta'}{i}{y_n}$ and $\closed{\theta'}{\domain{\theta'}}$ \\
\oo Assume for all $\psi$, we have \\
\ox  $\mspec{G(\theta \otimes \psi)}{\readcell i}{a}{a = ((f\;v)_n, \setof{c}) 
      \land G(\theta' \otimes R(u,\psi)) }$ \\
\oo Now, we'll consider the effect of reading $s$ \\
\ooo We know that $\unready{\theta \otimes \localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n} \otimes R(i, \iota_n)}{s}$ \\
\ooo Using the \textsc{AUnready} rule, we can derive the following triple: \\
\ooo $\left<G(\theta \otimes \localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n} \otimes R(\setof{i}, \iota_n) \psi)\right>$ \\
\ooo $\readcell s$ \\
\ooo $\left<a.\; G(\theta' \otimes \localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n} \otimes \iota_{n+1} \otimes R(u \cup {s},\psi))\right.$ \\
\ooo $\left.\;\;\land\;a = ((\pi_1(\mathit{cycle}\;x\;f\;ys)_n, y_n), \setof{s}) \right>$ \\
\ooo using the fact that $s \not\in \domain{\theta}$ and its closure \\
\oo Furthermore, it's clear that $u \cup \setof{s} \subseteq \domain{\theta \otimes \localref{r}{\ldots} \otimes R(\setof{i}, \iota_n)}$\\
\oo and that $\unready{\theta \otimes \localref{r}{\ldots} \otimes R(\setof{i}, \iota_n)}{s}$ \\
\oo and that $s \in \domain{\theta \otimes \localref{r}{\ldots} \otimes R(\setof{i}, \iota_n)}$\\
\oo So we can then use $\mathit{Transduce}(xys, s, \phi, t, f\;xys)$ to conclude that for all $\psi$\\
\ooo $\left<G(\theta \otimes \localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n} \otimes R(\setof{i}, \iota_n \otimes \phi_n) \otimes \psi)\right>$\\
\ooo $\readcell t$ \\
\ooo $\left<G(\theta \otimes \localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n} \otimes \iota_{n+1} \otimes \phi_{n+1} \otimes R(u \cup \setof{s} \cup u', \psi))\right.$\\
\ooo $\;\;\land\;\left.a = ((f\;(\mathit{zip}\;(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))\;y))_n, \setof{t})\right>$\\
\ooo By the loop unrolling lemma, this postcondition is equivalent to  \\
\ooo $\left<G(\theta \otimes \iota_{n+1} \otimes \phi_{n+1} \otimes R(u \cup \setof{s} \cup u', \psi))
            \land a = ((\mathit{cycle}\;x\;f\;ys)_n, \setof{t})\right>$\\
\oo Take the witness to be $u' \cup \setof{s, t}$ \\
\oo Now, assume we have $\psi$, and a prestate \\
\oo $G(\localref{r}{\pi_1(\mathit{cycle}\;x\;f\;ys)_n} \otimes R(\setof{i}, \iota_n \otimes \phi_n \otimes \delta_n) \otimes \psi)$ \\
\oo Since $\unready{\localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n} \otimes \theta \otimes R(\setof{i}, \iota_n)}{s}$, we have \\
\oox $\unready{\localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n} \otimes \theta \otimes R(\setof{i}, \iota_n \otimes \phi_n)}{t}$, so we have \\
\oox $\unready{\localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n} \otimes \theta \otimes R(\setof{i}, \iota_n \otimes \phi_n \otimes \delta_n)}{o}$, so we have \\
\oox $\unready{\localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n} \otimes \theta \otimes R(\setof{i}, \iota_n \otimes \phi_n \otimes \delta_n) \otimes \psi}{o}$ \\
\oo So to read $o$, we should use the \textsc{AUnready} rule. So we want to evaluate $e_2$ in a state\\
\oo $G(\localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n} \otimes R(\setof{i}, \iota_n \otimes \phi_n) \otimes \psi)$\\
\oo Now by \textsc{ABind} we need to consider $\readcell t$, and from our derivation above \\
\oo $G(\localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_n} \otimes \iota_{n+1} \otimes \phi_{n+1} \otimes R(u \cup u' \cup \setof{s}, \psi))$\\
\oo and furthermore the return value is $((\mathit{loop}\;x\;f\;ys)_n, \setof{t})$ \\
\oo Calling $(x, z) = (\mathit{cycle}\;x\;f\;ys)_n$, we need to consider $\bind (\setref r\;x)\; (\semfun{\unit}{\return z})$ \\
\oo Using the \textsc{ABind} rule and first the \textsc{ASetRef} rule, we see that \\
\oo $G(\localref{r}{\pi_1\;(\mathit{cycle}\;x\;f\;ys)_n} \otimes \iota_{n+1} \otimes \phi_{n+1} \otimes R(u \cup u' \cup \setof{s}, \psi))$\\
\oo By equational reasoning, this is equivalent to \\
\oo $G(\localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_{n+1}} \otimes \iota_{n+1} \otimes \phi_{n+1} \otimes R(u \cup u' \cup \setof{s}, \psi))$\\
\oo Finishing with $\return z$, we get the poststate: \\
\oo $G(R(\setof{t}, \localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_{n+1}} \otimes \iota_{n+1} \otimes \phi_{n+1} \otimes R(u \cup u' \cup \setof{s}, \psi)) \otimes \delta_{n+1})$\\
\oox $\land\; a = (z, \setof{t})$\\
\oo Note $z = \pi_2\;(\mathit{cycle}\;x\;f\;ys)_n = (\mathit{map}\;\pi_2\;(\mathit{cycle}\;x\;f\;ys))_n = (\mathit{loop}\;x\;f\;ys)_n$ \\
\oo Furthermore, the poststate simplifies to \\
\oo $G(\localref{r}{(x \cdot \mathit{map}\;\pi_1\;(\mathit{cycle}\;x\;f\;ys))_{n+1}} \otimes \iota_{n+1} \otimes \phi_{n+1} \otimes R(u \cup u' \cup \setof{s,t}, \psi)) \otimes \delta_{n+1})$ \\
\oox $\land\; a = (z, \setof{t})$\\
\oo using the closure properties of $\phi, \theta, \delta,$ and $\iota$, which is what we want.
\end{tabbedproof}
\end{proof}

\section{Future Work}

Now that we have introduced the idea of ramifications, we see many
possible applications for them. 

First, there are numerous algorithms --- such as unification, the
union-find algorithm, and the chaotic iteration constraint propagation
algorithm used in dataflow analysis --- which rely on using mutation
and assignment as a way of globally broadcasting information to the
rest of the program state. These algorithms have all been naturally
resistant to modular proofs, because of the apparent need to know
``the rest of the world'' in the program invariant. It would be
interesting to see if ramifications can help.

Second, we would like to investigate the relationship between
ramification operators and methods based on
rely-guarantee~\cite{rely-guarantee-jones}. Rely-guarantee works by
imposing a mutual contract between a piece of code and the rest of the
world, which is at least conceptually similar to the idea of a
ramification, though we see no obvious direct relationship.

Third, in this work we have presented ramifications as a style of
specification useful for verifying a particular library. Might it be
sensible or useful to bake ramification operators into the basic
logical framework? If so, what are their logical properties --- $R(u,
\phi)$ looks like a family of modal operators on the formula $\phi$, but
even in our first example we needed a number of auxiliary interaction
lemmas to make them truly useful.

\section{Related Work}

Versions of separation logic~\cite{sep-logic} supporting higher-order
languages and quantification over predicates have been proposed by
\citet{htt} with Hoare Type Theory, and by
\citet{parkinson-bierman}. It would be interesting to study how the
proof techniques in this paper could be adapted to their setting.

Prior work on verifying callbacks using separation logic includes work
by \citet{tldi09,ftfjp07} work by
\citet{parkinson-iwaco-07}. The approach in both of these
papers was similar; each subject predicate was equipped with a list of
observers, rather than maintaining them implicitly in the
invariant. These approaches were not modular, because the observers
had to be explicitly named. Worse still, this approach broke down when
faced with chains of subjects and observers, because separation logic
is a resource-based logic, and the existence of multiple paths to an
object meant that ownership of observer state became ambiguous.

citet{shaner-leavens-naumann} studied using gray-box model
programs to model higher-order method calls (which can be understood
as a a variant of refinement calculus-based methods) in JML, and 
\citet{history-invariants} have applied Liskov and Wing's
idea of history invariants~\cite{liskov-wing} to model observers. As
before, both of these methods are also non-modular, since they require
knowing what all of the observers are, and furthermore both of these
methods sharply restrict the kinds of invariants that can be used,
making it very difficult to model the code-update-based protocol seen
in our FRP example.

\citet{self-adjusting} have proposed
\emph{self-adjusting computation} as a technique for using change
propagation to write programs that incrementally
recompute answers as the inputs are adjusted. It would be worth 
studying if our techniques could help verifying implementations of this
idea.

Functional reactive programming (FRP) was proposed by \citet{frp} as a
declarative formalism for interactive programming. The API in our
paper differs from theirs in two ways. First, our interface is a
variation of the \emph{arrowized FRP} interface proposed in
\cite{afrp}, and secondly, we use a discrete model of time, rather
than a continuous model of time --- though we found the core idea of
using a declarative semantics as a specification for the interface an
inspiring one.

Furthermore, our work could also serve as a bridge between the work on
purely functional reactive programming, and more imperative
implementations, such as the work done by \citet{superglue} on
SuperGlue and by \citet{frtime} on the FrTime system.


\section{Appendix: The $\cellset$ Interface}

In this section, we'll describe the interface to the $\cellset$ type,
which is intended to be used to represent pure collections of
existentially quantified cells. Specifying this interface is not
entirely trivial, because of the way equality works for this
type. Ordinarily, we would simply give a two-place predicate $set(v,
elts)$ relating a value $v$, and the mathematical set of elements
$elts$ it represents.

However, this approach is not sufficient in our case. In order to
manage dependencies, we need to be able to test cells of
\emph{different} concrete type for equality, and the natural equality
for references only permits testing references of the same type. As a
result, we can't unpack an existentially-quantified cell and compare
the elements in its tuple, because we don't know that the two cells
are of the same type (and indeed, they might not be). 

To get around this problem, we generate a unique integer identifier
for each cell we create, and then compare those identifiers to
establish equality. Since these identifiers are all generated
dynamically along with the cells, this means that the precise partial
equivalence relation we need to use is determined dynamically as
well. So we add an additional index to the set predicate $set(W, v,
elts)$. The extra parameter $W$ is the \emph{world}, the set of all
the cells allocated so far, which must collectively satisfy the
constraint that they are equal if and only if their identifier fields
match. 

All of the usual set operations exist. We have an $\ctext{emptyset}$,
representing an empty set of cells. We have $\ctext{addset}\;v\;x$,
which adds the element $x$ to the set $v$ represents, and
$\ctext{removeset}\;v\;x$, which removes $x$ from the set $v$
represents. We also have $\ctext{iterset}\;f\;v$, which iterates over
the elements of $v$'s set and applies $f$ to each element in some
sequential order. (Observe that the specification makes use of two 
auxiliary predicates: $matches$, which assert that a
set and a list have the same elements; and $iterseq$, which constructs
a command representing the sequential execution of those elements.) 

We have three axioms that our implementation must satisfy. First, if a
$\cellset$ value $v$ represents a set in a world $W$, it will also
represent a set in any larger world $W'$. Second, the values in a set
are always a subset of the world $W$. Finally, we require that
$set(W,v,elts)$ is a pure predicate (i.e., is not heap-dependent),
which implies that it have a purely functional implementation (for
example, as a binary tree). 


\begin{tabbing}
$World = $ \\
\;\;\;\;\=$\{D \in \powersetfin{ecell}\;|\;\forall c,d \in D.\;$\=$identity(c) = identity(d)$\\
        \>                                                      \>$\iff c = d\}$\\[1em]

$\exists \cellset : \star.$ \\
$\exists set : World \To \cellset \To \powersetfin{ecell} \To \assert.$ \\
$\exists \ctext{emptyset}    : cellset.$ \\
$\exists \ctext{addset}      : \cellset \to ecell \to \cellset.$ \\
$\exists \ctext{removeset}   : \cellset \to ecell \to \cellset.$ \\
$\exists \ctext{iterset}     : \cellset \to (ecell \to \monad{\unittype}) \to \unittype.$\\[1em]

$\forall W \in World.\; set(W, \ctext{emptyset}, \emptyset)$ \\[1em]


$\forall W \in World, v : \cellset, x : ecell, elts \in \powersetfin{ecell}.$ \\ 
\> $set(W, v, elts) \land x \in W \implies set(W, \ctext{addset}\;v\;x, elts \cup \setof{x})$ \\[1em]


$\forall W \in World, v : \cellset, x : ecell, elts \in \powersetfin{ecell}.$ \\ 
\> $set(W, v, elts) \land x \in W \implies set(W, \ctext{removeset}\;v\;x, elts - \setof{x})$ \\[1em]


$\forall W \in World, v : \cellset, elts \in \powersetfin{ecell}, 
         f : (ecell \to \monad{\unittype}).$ \\ 
\> $set(W, v, elts) \implies \exists L : \seqsort{ecell}.\;$\=$matches\;elts\;L\; \land$ \\
\>                                \>$\ctext{iterset}\;f\;v = iterseq\;f\;L$ \\[1em]


$\forall W, W' \in World, v, elts.$ \\
\>$set(W,v,elts) \land W \subseteq W' \implies set(W',v, elts)$\\[1em]

$\forall W, W' \in World, v, elts.$ \\
\>$set(W, v, elts) \implies elts \subseteq W$ \\[1em]

$\forall W, v, elts.\; pure(set(W,v,elts))$ \\[1em]
  

$matches\;elts\;[] \qquad\;\;\; = elts = \emptyset$ \\
$matches\;elts\;(v :: vs) = v \in elts \land matches\;(elts - \setof{v})\;vs$\\[1em]

$iterseq\; f\; [] \qquad\;\;\;\;$\=$= \comp{\unit}$ \\
$iterseq\; f\; (v :: vs)$\>$= \comp{\letv{\unit}{f\;v}{\ctext{run}\;iterseq\;f\;vs}}$ \\
\end{tabbing}


\paragraph{Acknowledgements}

We would like to thank Peter O'Hearn for pointing out the connection
of our work with the ramification problem of AI.

