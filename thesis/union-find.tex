\chapter{Proving the Union-Find Disjoint Set Algorithm}

In this chapter, we introduce the technique of ``ramification'', as a
way of recovering local reasoning in the face of imperative programs
with global invariants.

The union-find disjoint set data structure is a technique for
efficiently computing canonical representing for equivalence classes
of values. The basic technique for doing so is to represent each value
in the equivalence class as a node in a tree --- but unlike the usual
implementation of trees, each node does not contain a pointer to its
children, but rather the children each maintain a pointer to the
parent. The root of the tree has no parent pointer, and represents the
canonical representative for an equivalence class.

The canonical representative can be found (the FIND operation) by
following the parent pointers to the root of the tree. Similarly, two
disjoint sets can be merged (the UNION operation), by finding their
canonical representatives and setting one to point to the other.

As described, this data structure is no better than using a linked
list. However, two optimizations give rise to an extremely efficient
implementation. First, the root node can be modified to keep track of
a bound on the maximum height, so that whenever two sets are merged,
the shorter tree can be made a subtree of the deeper one. Second, the
algorithm can make use of \emph{path compression} -- whenever the FIND
operation is called, it can set all of the nodes on the path to the
root to point directly at the root. Together, these optimizations
permit performing a sequence of $n$ UNION and FIND operations in $O(n
\cdot \alpha(n))$ time, where $\alpha$ is the inverse Ackermann
function.

This permits simple implementation of near-linear-time unification
algorithms, and a variant of this idea is used in the proofs of
congruence closure algorithms.

However, path compression has been an idiom difficult to accomodate
within the framework of separation logic. In informal reasoning about
the union-find data structure, we do not explicitly track all the
elements of a union-find data structure in our reasoning --- instead,
we rely on the fact that path compression makes changes to the heap
which ``will not change the answer''. However, since separation logic
is a resource-aware logic, we can't simply leave the other elements of
the equivalence class out of the invariant, since UNION may read and
modify them.

The solution I propose in this chapter is to use a global invariant,
but structured in a way which preserves modular reasoning.

\begin{figure}
  \begin{mathpar}
    \begin{array}{lcl}
      \phi, \psi & ::= & I \bnfalt \elt{x}{y} \bnfalt \phi \otimes \psi
    \end{array}
  \end{mathpar}
  \begin{mathpar}
    \begin{array}{lcl}
      R(\rho, I) & = & I \\
      R(\rho, \psi \otimes \phi) & = & R(\rho, \psi) \otimes R(\rho, \phi) \\
      R(\rho, \elt{x}{y}) & = & \elt{x}{\rho(x)} \\
    \end{array}
  \end{mathpar}

  \begin{mathpar}
    \boxed{\ufcontains{\phi}{x}{y}}
    \\
    \inferrule*[]
              { }
              {\ufcontains{\elt{x}{y}}{x}{y}}
    \and
    \inferrule*[]
              {\ufcontains{\phi}{x}{y}}
              {\ufcontains{\phi \otimes \psi}{x}{y}}
    \and
    \inferrule*[]
              {\ufcontains{\psi}{x}{y}}
              {\ufcontains{\phi \otimes \psi}{x}{y}}
  \end{mathpar}
  \begin{specification}
    \nextline
    $\exists \tau : \star$ 
    \nextline 
    $\exists H : \formula \to \assert$ 
    \nextline
    $\exists \newset : \monad{\tau}$ 
    \nextline
    $\exists \find : \tau \to \monad{\tau}$ 
    \nextline
    $\exists \union : \tau \times \tau \to \monad{\unittype}$
    \nextline 
      $\spec{H(\phi)}{\newset}{a:\tau}{H(\phi \otimes \elt{a}{a})}$
    \\ \> $\specand$
    \nextline 
      $\spec{H(\phi) \land (\ufcontains{\phi}{x}{y})}
            {\find(x)}
            {a:\tau}
            {H(\phi) \land a = y}$
    \\ \> $\specand$
    \nextline 
      $\spec{H(\phi) \land (\ufcontains{\phi}{x}{y})
                     \land (\ufcontains{\phi}{u}{v})}
            {\union(x, u)}
            {a:1}
            {H(R([y/v], \phi))}$
  \end{specification}

\caption{Specification of Union Find Algorithm}
\label{union-find:spec}
\end{figure}

In Figure~\ref{union-find:spec}, we give a specification of the
union-find algorithm. In this specification, we essentially replay the
key trick of separation logic, only ``one level up''. That is, we give
a monolithic abstract predicate $H(\phi)$, which describes all of the
trees at once. We recover modularity in the index of the predicate
$\phi$, which gives a small (in fact, nearly degenerate) ``separation
logic'' for describing nodes. 

\begin{figure}
\mbox{}
\begin{specification}
\nextline $\sigma = \Child \of \reftype{\sigma} \bnfalt \Root \of \opttype\;{\reftype{\sigma}} \times \N$ 
\nextline $\tau = \reftype{\sigma}$ 

\nextlinelabel{union-find:invariant} 
   $H(\phi) \triangleq \exists n \subseteq \tau, p \in n \to n, w \in \mu(n) \to n.\;G(n,p,w,\phi)$
\nextline[1em] $G(n, p, w, \phi) =\;$\=$p^{*} \mbox{ partial order} \;\land$ 
\nextline \> $(n, p, w) \models \phi \;\land$
\nextline \> $\heap(n, p, w)$ 

\nextline[1em] $n, p, w \models I \qquad\qquad$\=$\mbox{ iff}\;\;$\=$\mbox{always}$ 
\nextline      $n, p, w \models \phi \otimes \psi$\>$\mbox{ iff}$\>$
                     \exists n', n''.\; n = n' \uplus n'' \mbox{ and } n', p, w \models \phi \mbox{ and } 
                     n'', p, w \models \psi$
\nextline      $n, p, w \models \elt{x}{y}$ \> $\mbox{ iff }$\>$w(\mathit{root}(x)) = y$

\nextline[1em] $\heap(n, p, w) =  \forall^{*} l \in n. \IfTE{p(l) = l}{\exists n.\; l \pointsto \Root(\Some(w(l)), n)}{l \pointsto \Child(p(l))}$

\nextline[1em] $\mathit{root} : n \to \mu(p) = \mu(\semfun{f}{f \circ p})$
\end{specification}
\caption{Implementation of Union Find Algorithm}
\label{union-find:invariant}
\end{figure}
 
On line~\ref{union-find:invariant} of Figure~\ref{union-find:impl} we
give the invariant for the union-find data structure. We assert the
existence of a finite set of nodes $n$, a map $p : n \to n$, and a map
$w : \mu(p) \to p$ (where $\mu(p)$ denotes the set of fixed points of
$p$). The set of nodes $n$ are all the sets that have been allocated,
and the parent map $p$ maps each node to its parent. The fixed points
of $p$ are the roots of the union-find trees, and the map $w : \mu(p)
\to p$ identifies the canonical witness associated with each root.

In order to ensure that the graph structure actually forms a tree, we
impose the condition that the transitive closure of $p$ is a partial
order. The antisymmetry condition means that there are no nontrivial
cycles in the relation, and since every node has (a) a single parent,
and (b) there are a finite number of nodes, we will reach a root node
in a finite number of steps.

Then, we assert that the triple $(n, p, w)$ models our formulas.
These formulas are a small subset of separation logic. We have the
formula $I$, which is always satisfied. Then we have the formula $\phi
\otimes \psi$, which corresponds to the usual separating conjunction,
in that the resource $n$ (the collection of disjoint-set nodes) is
split into two parts, one of which must support $\phi$ and the other
of which must support $\psi$. Note that the whole of the parent
function $p$ and the canonical witness function $w$ functions are
passed to both branches. This is the information that will let us
ensure that global constraints are maintained in local invariants.

In particular, the atomic proposition $\elt{x}{y}$ asserts that $x$ is
a node whose canonical witness is $y$, which is checked by consulting
$p$ to get the root, and then passing that to $w$.

\begin{figure}
\mbox{}
\begin{specification}
\nextline $\newset = [$\=$\letv{r}{[\newref{\sigma}{\Root(\None, 0)}]}{}$
\nextline              \>$\letv{\unit}{[r := \Root(\Some(r), 0)]}{}$
\nextline              \>$r]$

\nextline[1em] $\ctext{findroot}(x) = [$\=$
                  \letv{v}{\comp{!x}}{}$ 
\nextline \>     $\run{}\ctext{case}($\=$v,$ 
\nextline \> \>     $\Root(w, n) \to [(x, w, n)],$
\nextline \> \>     $\Child(p) \to \ctext{findroot}(p))]$

\nextline[1em] $\find(x) = [$\=
             $\letv{(\_, w, \_)}{\ctext{findroot}(x)}{}$ 
\nextline \> $\ctext{case}($\=$w,$ 
\nextline \> \> $\None \to \bot,$  
\nextline \> \> $\Some(w) \to w)]$

\nextline[1em] $\union(x, y) = [$\= 
                 $\letv{(r, u, m)}{\findroot\;x}{}$ 
\nextline \>     $\letv{(s, v, n)}{\findroot\;y}{}$ 
\nextline \>     $\run{}$\=$\ctext{if}\;m < n\;\ctext{then}$ 
\nextline \> \>   \;\;$[$\=$\letv{\unit}{[s := \Root(u, n)]}{}$ 
\nextline \> \>         \>$r := \Child(s)]$ 
\nextline \> \> $\ctext{else}\;\ctext{if}\;n < m\;\ctext{then}$ 
\nextline \> \>   \;\;$[s := \Child(r)]$
\nextline \> \> $\ctext{else}$ 
\nextline \> \>   \;\;$[\letv{\unit}{[r := \Root(r, u, n+1)]}{}$
\nextline \> \>      \>$s := \Child(r)]]$
\end{specification}
\caption{Implementation of Union-Find Algorithm}
\label{union-find:impl}  
\end{figure}


\section{Correctness Proofs}

\subsection{Proof of $\ctext{find}$}

\texttt{FIXME: FIX DEFINITION OF FINDROOT}

Suppose $R \subseteq X \times X$ is a strict partial order. We say $x \in X$ is \emph{maximal}
when there is no $y \in X$ such that $(x,y) \in R$. 

\begin{lemma}{(Path Compression Lemma)}
  Suppose $D$ is a finite set and $f : D \rightharpoonup D$ is a partial function on $D$,
such that $f^{+}$ is a strict partial order. Now suppose $(x,y) \in f^{+}$ with $y$ maximal.

Then, $(u,v) \in [f|x:y]^{+}$ with $v$ maximal if and only if $(u,v) \in f^{+}$ with $v$ maximal. 
\end{lemma}

\begin{proof}
\begin{itemize}
\item[$\Leftarrow$] Suppose that $(u, v)$ in $f^{+}$. Then there is some $k$ such 
that $f^k(u) = v$. So we have a sequence $u, f(u), \ldots, f^k(u)$. 

If any of the $f^i(u) = x$ for $i < k$, then we know that $v = y$,
since both $v$ and $y$ are maximal. Therefore, it follows that the
sequence $0, [f|x:y](u), \ldots, [f|x:y]^i(u), y$ shows that $(u,v)
\in [f^|x:y]^+$ with $v$ maximal.

If none of the $f^i(u) = x$, then it follows that the sequence $u,
f(u), \ldots, f^k(u)$ is exactly the same as $u, [f|x:y](u), \ldots,
[f|x:y]^k(u)$, and so $(u, v) \in [f|x:y]^+$ with $(u,v)$ maximal.

\item[$\Rightarrow$] Suppose $(u,v) \in [f|x:y]^{+}$ with $v$
  maximal. Then we know that there is some sequence $u, [f|x:y](u),
  \ldots, [f|x:y]^k(u)$ with $[f|x:y]^k(u) = v$.

Suppose $[f|x:y]^i(u) = x$ for some $i \leq k$. Then we know that $i =
k-1$ and $v = y$, since $x$ is not maximal and $y$ is, and furthermore
we know that none of the $[f|x:y]^j(u) = x$ for $j < i$, and so
$[f|x:y]^j(u) = f^j(u)$. We also know that $x, f(x), \ldots, f^n(x) =
y$ is a sequence in $f$. So we can construct the sequence $u, f(u),
\ldots, f^i(u) = u, \ldots, f(x), \ldots, f^n(x) = y$, which shows
that $(u,v) \in f^+$ with $v$ maximal.

Otherwise, suppose that $[f|x:y]^i(u) \not= x$ for any $i \leq
k$. Then we know that $[f|x:y]^i(u) = f^i(u)$, and so we have the
sequence $u, f(u), \ldots, f^k(u) = v$ to show us that $(u,v) \in f^+$ with
$v$ maximal.
\end{itemize}
\end{proof}

\begin{lemma}{(Path Compression Preserves Satisfaction)}
Suppose $D$ is a finite set and $f : D \rightharpoonup D$ is a partial function on $D$,
such that $f^{+}$ is a strict partial order, and that $(x,y) \in f^{+}$ with $y$ maximal.

For all $\phi$ and $D' \subseteq D$, if $D', f \models \phi$, then $D', [f|x:y] \models \phi$.  
\end{lemma}

\begin{proof}
This lemma follows by induction on $\phi$. 
\begin{itemize}
\item Case $\phi = I$. This follows immediately from the definition of satisfaction. 
\item Case $\phi = \psi \otimes \theta$. 
  \begin{tabbedproof}
    \oo By assumption, we have $D', f \models \psi \otimes \theta$. \\
    \ooo From the definition of satisfaction, we get  $D_1, D_2$ such that $D' = D_1 \uplus D_2$ \\
    \oox and $D_1, f \models \phi$ and $D_2, f \models \phi$.  \\
    \ooo By induction, we get $D_1, [f|x:y] \models \psi$ \\
    \ooo By induction, we get $D_2, [f|x:y] \models \theta$ \\
    \ooo By definition, we get $D_1 \cup D_2, [f|x:y] \models \psi \otimes \theta$ \\
    \ooo Hence $D, [f|x:y] \models \phi$ \\
  \end{tabbedproof}
\item Case $\phi = \elt{u}{v}$.
  \begin{tabbedproof}
    \oo By assumption, $D', f \models \elt{u}{v}$ \\
    \oo So we know that $u \in D'$ and $(u,v) \in f^+$ and $v$ maximal. \\
    \oo By the path compression lemma, $(u,v) \in [f|x:y]^+$ and $v$ maximal. \\
    \oo Hence $D', [f|x:y] \models \elt{u}{v}$ 
  \end{tabbedproof}
\end{itemize}
\end{proof}


Now, we can specify and prove the correctness of $\findroot$. 

\begin{displaymath}
  \spec{G(D, f, \phi) \land \ufcontains{\phi}{u}{v}}
       {\findroot(u)}
       {a:\tau}
       {\exists f'.\; G(D, f', \phi) \land a = v}
\end{displaymath}



\begin{proof}
\begin{tabbedproof}
\oo Assume our precondition state is $G(D, f, \phi) \land \ufcontains{\phi}{u}{v}$ \\
\ooo Since $\ufcontains{\phi}{u}{v}$, and $D,f \models \phi$, we know that $u \in D$ [PROVE LEMMA]\\
\ooo Now, do a case split on whether or not $u \in \domain{f}$. \\
\ooo If $u \in \domain{f}$: \\
\oooo Then $\mathit{heap}(D,f) \implies (u \hookrightarrow \Child(w))$ for some $w$ \\
\oooo $[\letv{v}{[!u]}{}$ \\
\oooo So we add $v = \Child(w)$ to the state, and simplify the case statement \\
\oooo $\letv{p}{\findroot(w)}{}$ \\
\oooo Then $G(D, f', \phi) \land p = v$ for some $f'$ \\
\oooo Since $D,f' \models \phi$, we know that $(u,v) \in f'^{+}$ with $v$ maximal. \\
\oooo Hence $D,[f'|u:v] \models \phi$ since path compression preserves satisfaction. \\
\oooo $\letv{\_}{[u := \Child(p)]}{}$ \\
\oooo Hence $G(D, [f'|u:v], \phi) \land p = v$ \\
\oooo Hence $\exists f''.\;G(D, f'', \phi) \land p = v$ \\
\oooo $p]$ \\
\oooo Hence $\exists f''.\;G(D, f'', \phi) \land a = v$ \\
\ooo If $u \not\in \domain{f}$:  \\
\oooo Then $\mathit{heap}(D,f) \implies (u \hookrightarrow \Root)$  \\
\oooo $[\letv{v}{[!u]}{}$ \\
\oooo So we add $v = \Root$ to the state, and simplify the case statement \\
\oooo Furthermore, note that since $D,f' \models \phi$, $u = v$ \\
\oooo So $\exists f''.\;G(D, f'', \phi) \land u = v$  \\
\oooo $u]$\\
\oooo So $\exists f''.\;G(D, f'', \phi) \land a = v$  \\
\end{tabbedproof}
\end{proof}


\begin{lemma}{(Existence of Upper Fixed Points)}
Suppose $A$ is a finite set, and $f : A \to A$ is a function whose
transitive closure is a partial order, and let $\mu(f)$ be the
set of fixed points of $f$. Then, there is a function 
$\mathit{root}_f : A \to \mu(f)$ such that for each $x$ there is a 
$k$ such that $f^{k} = \mathit{root}_f(x)$.
\end{lemma}

\begin{proof}
Observe that the transitive closure gives an order $\sqsubseteq$ such
that for each $i \leq j$ and $x$ in $A$, $f^i(x) \sqsubseteq
f^j(x)$. Since $A$ is finite, it follows that the size of the longest
chain of distinct elements is at most $|A|$ -- so any sequence longer
than that must repeat elements of $A$.

Suppose there is a repeated element, occuring at the $i$-th and
$j$-th iterations of applying $f$ to $x$, where $i < j$. Since the
transitive closure is a partial order, we know that if $a \sqsubseteq
b$ and $a \sqsubseteq b$, then $a = b$. Therefore every element 
of the sequence from $i$ to $j$ is equal to $f^i(x)$. Since $i$ is
strictly less than $j$, this means that $f(f^i(x)) = f^i(x)$, and 
is hence a fixed point of $f$. 
\end{proof}

This property justifies the recursion in the implementation of
$\find$: it says that the root of a node's parent is still the root of
the node. It is worth contrasting the style of specification here with
the usual inductive specification of child-pointing trees in
separation logic. When proceeding from parent to child, we use that
fact that list or tree predicates are inductively defined, and try to
work directly with the inductive structure of the predicate.  Here, we
specify the invariant on the whole heap as a relation property of the
heap, and then have to prove that the measures we use are suitably
well-founded.


However, $\find$ also updates parents as it goes, and so at each
iteration it works on a \emph{different} global order structure.
We need to ensure that the answers we return are preserved under
this update, which is what the following lemma will ensure. 

\begin{lemma}{(Fixed Point Update)}
Suppose $A$ is a finite set, and $f : A \to A$ is a function whose
transitive closure is a partial order, and let $\mu(f)$ be the set of
fixed points of $f$. For a given $z$ in $A$, if we define $f' =
[f|z:\mathit{root}_f(z)]$, then the transitive closure of $f'$ is also
a partial order and $\mathit{root}_f = \mathit{root}_{f'}$.
\end{lemma}

\begin{proof}
Suppose that we have an arbitrary $x \in A$. Now, consider the sets of
elements $U = \comprehend{y}{y \sqsupseteq_f x}$, and $U' =
\comprehend{y}{y \sqsupseteq_{f'} x}$. (Note that $\sqsupseteq_{f'}$
is a well-defined relation, but that we do not yet know that it is a
partial order --- we only know that it defines a preorder.)

First, observe that $U$ is totally ordered with respect to
$\sqsubseteq_f$. We know that every $u \in U$ is equal to $u
= f^k(x)$ for some $k$, and so each pair of $u$ and $v$ is $f^j(x)$
and $f^k(x)$ for some $j$ and $k$. Since the natural numbers are
totally ordered, and since $j \leq k$ implies that $f^j(x)
\sqsubseteq_f f^k(x)$, it follows that $U$ is totally ordered with
respect to $\sqsubseteq_f$.

Now, $U$ either contains $z$ or not.

Suppose it does not contain $z$. Then $U = \comprehend{y}{y
  \sqsupseteq_{f'} x} = U'$, since $f = f'$ for all arguments not
equal to $z$. Therefore, $\mathit{root}_{f'}(x) = \mathit{root}_f(x)$.

On the other hand, suppose $U$ does contain $z$. Then we know that $U$
contains $\mathit{root}_f(z)$, and that this is an upper bound of
every element of $U$. 

Each distinct element of $U$ is $f^i(x)$ for some $0 \leq i <
|U|$. Therefore, we know that $z = f^k(x)$ for some $k$. Furthermore,
for each $j < k$, we know that $z \not= f^j(x)$. Therefore, these
elements are the $j$ smallest elements for both $U$ and $U'$. However,
we know that $f'(z) = \mathit{root}_f(z)$, and so at this point the
ordered enumeration of the elements of $U'$ ends.

Therefore, $U'$ is a subset of $U$ , whose maximum element (relative
to $f'$) is the same as the maximum element of $U$ --- in both cases,
it is $\mathit{root}_f(x)$. Since $U'$ is a subset of $U$, it further
follows that the transitive closure of $f'$ remains a partial
order: there can be no cycles since we have only removed paths from
the graph, and there were no cycles to begin with.
\end{proof}

Besides $\find$, our API also includes the $\union$ and $\newset$ operations. 
To create new disjoint sets, we need to that the order structure of two distinct
set forests can be merged sensibly. 

\begin{lemma}{(Order Extension)}
Suppose $A$ and $B$ are disjoint finite sets, and $f : A \to A$ and $g
: B \to B$ are functions whose transitive closures are partial
orders. Let $\mu(f)$ and $\mu(g)$ be the set of fixed points of $f$
and $g$, respectively. 

Then $h : A \cup B \to A \cup B = f \cup g$ is also a function whose 
transitive closure is a partial order, with $\mu(h) = \mu(f) \cup \mu(g)$, 
and $\mathit{root}_h = \mathit{root}_f \cup \mathit{root}_g$. 
\end{lemma}


\begin{proof}
\begin{enumerate}
\item We need to show that the transitive closure of $h$ is a partial
order. To do this, we need to show that the antisymmetry axiom holds, 
since reflexivity and transitivity arise immediately from taking the
transitive closure. 

So, suppose that $(x,y) \in h^{*}$, and likewise $(y, x) \in
h^{*}$. From the definition of the transitive closure, we know there
is some $m$ and $n$ such that $y = h^m(x)$, and $x = h^n{y}$.  Since
$A$ and $B$ are disjoint, we know that either $x \in A$ or $x \in
B$. Furthermore, from the definition of $h$ we know that $h$ takes
elements of $A$ to elements of $A$ according to $f$, and takes
elements of $B$ to elements of $B$ according to $g$. So if $x \in A$,
then $y = f^m(x)$, and so $y \in A$, and so $x = f^n(y)$.  Then by the
antisymmetry of $f^{*}$, we know that $x = y$. So if $x \in B$, then
$y = g^m(x)$, and so $y \in B$, and so $x = g^n(y)$.  Then by the
antisymmetry of $g^{*}$, we know that $x = y$.

\item Next, we need to show that the set of fixed points of $h$ is the
  union of the fixed points of $f$ and $g$. This follows immediately
  from the fact that $A$ and $B$ are disjoint, and $f$ and $g$ are
  endofunctions.

\item Finally, we need to show that $\mathit{root}_h = \mathit{root}_f
  \cup \mathit{root}_g$. Again, since $A$ and $B$ are disjoint, there
  are no increasing chains of elements of $A \cup B$ that include
  elements of both $A$ and $B$.  Therefore, the upper fixed points of
  $h$ on its $A$ sub-domain will be given by $\mathit{root}_f$ and the
  upper fixed points of $h$ on its $B$ sub-domain will be given by
  $\mathit{root}_g$.
\end{enumerate}
\end{proof}

Finally, we need a lemma to let us prove that when we take the union
of two sets, we will again have a graph which has the desired properties.

\begin{lemma}{(Abstract Union)}
Suppose $A$ is a finite set, and $f : A \to A$ is a function whose
transitive closure is a partial order, and let $\mu(f)$ be the set of
fixed points of $f$. For any $y, z$ in $\mu(A)$, if we define $f' =
[f|y:z]$, then the transitive closure of $f'$ is a partial order, and 
$\mathit{root}_{f'} = \semfun{a}{(\IfTE{\mathit{root}_f(a)=y}{z}{\mathit{root}_f(a)})}$.
\end{lemma}

\begin{proof}
Suppose that $x \in A$. Now, consider the sets of elements $U =
\comprehend{y}{y \sqsupseteq_f x}$, and $U' = \comprehend{y}{y
  \sqsupseteq_{f'} x}$. We know that $U$ can be ordered into elements
$x, \ldots, f^k(x)$, with $k = |U|$ and with $f^k(x) = \mu(x)$. 

Now, consider whether $y \in A$ or not. If it is not, then we know
that $f'^{i}(x) = f^{i}(x)$ for all $i \leq k$. Therefore $U'$ is
equal to this set, and is also totally ordered and has the maximal
element $\mathit{root}_f(x)$. 

On the other hand, if $y$ is in $A$, then we know that $f'^i(x) =
f^i(x)$ until index $k$, at which point $f'^k(x) = z$. However, we can
easily see that $f'^{k+1}(x) = f'(f'^k(x)) = z$, which means that $U'$
has a unique totally order with respect to $\sqsubseteq_{f'}$, and has
maximum $z$. 

Furthermore, since each set of upper bounds of $x$ is uniquely totally
ordered by $\sqsubseteq_{f'}$, we know that the transitive closure of
$f'$ is a partial order, and not just a preorder. 
\end{proof}


\begin{lemma}{(Monotonicity of $\ufcontains{\phi}{x}{y}$)}
Suppose $\ufcontains{\phi}{x}{y}$. Then $\ufcontains{\phi \otimes \psi}{x}{y}$. 
\end{lemma}

\begin{proof}
Take the derivation of $\ufcontains{\phi}{x}{y}$. Apply the tensor rule 
to it, and derive $\ufcontains{\phi \otimes \psi}{x}{y}$.
\end{proof}

\begin{lemma}
  Suppose $\ufcontains{\phi}{x}{y}$. Then for all $\rho$, $\ufcontains{R(\rho, \phi)}{x}{\rho(y)}$. 
\end{lemma}

\begin{proof}
This follows by induction on the derivation of $\ufcontains{\phi}{x}{y}$. 
\begin{itemize}
\item Suppose $\ufcontains{\elt{x}{y}}{x}{y}$. 

In this case $R(\rho, \elt{x}{y}) = \elt{x}{\rho(y)}$. Then apply the 
unit rule to derive $\ufcontains{R(\rho, \phi)}{x}{\rho(y)}$. 

\item Suppose that we use the tensor-left rule, so that by inversion we have
$\phi = \psi \otimes \theta$, and $\ufcontains{\psi}{x}{y}$. 

Then, by induction we have $\ufcontains{R(\rho, \psi)}{x}{\rho(y)}$. 
By the tensor-left rule, we have $\ufcontains{R(\rho, \psi) \otimes R(\rho, \theta)}{x}{\rho(y)}$. Then, by the definition of $R$, we have $\ufcontains{R(\rho, \psi \otimes \theta)}{x}{\rho(y)}$.

\item The tensor-right case is symmetric. 
\end{itemize}
\end{proof}

\begin{lemma}{(Model Extension)}
  Suppose $(n, p, w) \models \phi$, and $n'$ is disjoint from $n$, and $p' \in n' \to n'$ such that $p'^*$ is a partial order, and $w' \in n' \to \mu(n')$. Then $(n, p \cup p', w \cup w') \models \phi$. 
\end{lemma}

\begin{proof}
 We proceed by induction on $\phi$. 

 \begin{itemize}
   \item Case $\phi = I$

     This case is immediate. 

   \item Case $\phi = \elt{x}{y}$. 

     In this case, we know that $p'$ is completely disjoint from
     $p$. As a result, the transitive closure of $p \cup p'$ is just
     the unions of the transitive closures of $p$ and $p'$, and any
     upper fixed point of an element of $n \cup n'$ is just the upper
     fixed point of $p$ or of $p'$. Therefore $\mathit{root}(x)$
     remains unchanged, and since $w'$ is an extension of $w$,
     $w'(\mathit{root}(x)) = y$.
     
     \item $\phi = \psi \otimes \theta$

       This follows by induction. Suppose that $(n_1, p, w) \models
       \psi$ and $(n_2, p, w) \models \theta$. Then, by induction
       hypothesis, we know that $(n_1, p \cup p', w \cup w') \models
       \psi$ and $(n_2, p \cup p', w \cup w') \models \theta$. Then,
       by the definition of satisfaction, we know that $(n, p \cup p',
       w \cup w') \models \psi \otimes \theta$.
 \end{itemize}
\end{proof}

\begin{lemma}{(Shrinking)}
For suitably-typed $n, p, w$, suppose $(n, p, w) \models \phi \otimes \psi$. Then 
we know that $(n, p, w) \models \phi$ and $(n, p, w) \models \psi$. 
\end{lemma}
\begin{proof}
  From the definition of the model, we know that there are smaller $n_1$ and $n_2$ 
such that $(n_1, p, w) \models \phi$ and $(n_2, p, w) \models \psi$. Then, by 
the model extension lemma, we know that $(n, p, w) \models \phi$ and $(n, p, w) \models \psi$. 
\end{proof}

\begin{lemma}{(Soundness of Witness Values)}
For suitably-typed $n, p, w$, suppose $(n, p, w) \models \phi$, and that $\ufcontains{\phi}{x}{y}$. Then $w(\mathit{root}(x)) = y$.  
\end{lemma}
\begin{proof}
This follows by induction on the derivation of
$\ufcontains{\phi}{x}{y}$, with the two inductive cases following
trivially using shrinking. The only interesting case is the base case,
when $\ufcontains{\elt{x}{y}}{x}{y}$.  In this case, we know that $(n,
p, w) \models \elt{x}{y}$, so we know $w(\mathit{root}(x)) = y$. 


\end{proof}

\section{Correctness Proofs}

\subsection{Proof of $\newset$}

\begin{specification}
\nextline $\{H(\phi)\}$
\nextline $\{G(n, p, w, \phi)\}$
\nextline $\letv{r}{[\newref{\sigma}{\Root(\None, 0)}]}{}$
\nextline $\{G(n, p, w, \phi) * r \pointsto \Root(\None, 0)\}$
\nextline $\letv{\unit}{[r := \Root(\Some(r), 0)]}{}$
\nextline $\{G(n, p, w, \phi) * r \pointsto \Root(\Some(r), 0)\}$
\nextline $r]$
\nextline $\{G(n, p, w, \phi) * a \pointsto \Root(\Some(a), 0)\}$
\nextline $\{p^{*} \mbox{ partial order} \land (n, p, w) \models \phi \land
             \heap(n, p, w) * a \pointsto \Root(\Some(a), 0)\}$
\nextline $\{p^{*} \mbox{ partial order} \land (n, p, w) \models \phi \land
             \heap(n, p, w) * a \pointsto \Root(\Some(a), 0) \land a \not\in n\}$
\nextline Let $n' = n \cup \setof{a}$, and let $p' = [p|a:a]$, and let $w' = [w|a:a]$. 
\nextline By the order extension lemma,
\nextline $\{p'^{*} \mbox{ partial order} \land (n, p', w') \models \phi \land
             \heap(n', p', w')\}$
\nextline By definition of modelling, $(\setof{a}, p', w') \models \elt{a}{a}$
\nextline So $(n', p', w') \models \phi \otimes \elt{a}{a}$. Therefore
\nextline $\{p'^{*} \mbox{ partial order} \land (n', p', w') \models \phi \otimes \elt{a}{a} \land \heap(n', p', w')\}$
\nextline $\{G(n', p', w', \phi \otimes \elt{a}{a})\}$
\nextline $\{H(\phi \otimes \elt{a}{a})\}$
\end{specification}

\subsection{Proof of $\find$}

In order to prove this function correct, we will need to appeal to the
correctness of the $\findroot$, function, which we will specifiy as
follows:

\begin{prop}{(Specification of $\findroot$)}
  The specification of the $\findroot$ function is 

  \begin{specification}
    \nextline $\{G(n, p, w, \phi) \land \ufcontains{\phi}{x}{y}\}$
    \nextline $\findroot(x)$ 
    \nextline $\{(u, y', n).\; \exists p'.\;G(n, p', w, \phi) \;\land
                       u = \mathit{root}(x) \land y' = \Some(w(u)) 
                       \land p'(x) = u\}$
  \end{specification}
\end{prop}

\begin{proof}
Assume we begin in the precondition $\ufcontains{\phi}{x}{y} \land
G(n, p, w, \phi)$.  By definition, we know that $G(n, p, w, \phi) =
p^{*}\mbox{ partial order} \land (n,p,w) \models \phi \land
\heap(n,p,w)$, by the soundness of the models relation, we
additionally know that $w(\mathit{root}_p(w(x))) = y$.


\end{proof}



\begin{specification}
\nextline $\{\ufcontains{\phi}{x}{y} \land G(n, p, w, \phi)\}$
\nextline $\{p^{*} \mbox{ partial order} \land (n, p, w) \models \phi \land
             \heap(n, p, w) \land \ufcontains{\phi}{x}{y}\}$
\nextline From the soundness of the models relationship, we know 
\nextline $\{p^{*} \mbox{ partial order} \land (n, p, w) \models \phi \land
             \heap(n, p, w) \land x \in n \land w(\mathit{root}(x)) = y\}$
\nextline $\{p^{*} \mbox{ partial order} \land (n, p, w) \models \phi \land
             x \in n \land w(\mathit{root}(x)) = y $ 
\nextline $\;\;\land\; \heap(n - \setof{x}, p, w) * \IfTE{x = p(x)}{\exists k.\; x \pointsto \Root(\Some(w(x)), k)}{x \pointsto \Child(p(x))}\}$

\nextline $\{p^{*} \mbox{ partial order} \land (n, p, w) \models \phi \land
             x \in n \land w(\mathit{root}(x)) = y $ 
\nextline $\;\;\land\; \heap(n - \setof{x}, p, w) *  x \pointsto (\IfTE{x = p(x)}{\Root(\Some(w(x)), k)}{\Child(p(x))})\}$

\nextline $[$\=$\letv{v}{[!x]}{}$ 
\nextline $\{p^{*} \mbox{ partial order} \land (n, p, w) \models \phi \land
             x \in n \land w(\mathit{root}(x)) = y $ 
\nextline $\;\;\land\; \heap(n, p, w) \land v = (\IfTE{x = p(x)}{\Root(\Some(w(x)), k)}{\Child(p(x))})\}$
\nextline\> $\run{}\ctext{case}(v,$\=
\nextline\> \> $\Root(z, k) \to$

\nextline\> \> $\{p^{*} \mbox{ partial order} \land (n, p, w) \models \phi \land
             x \in n \land w(\mathit{root}(x)) = y $ 
\nextline\> \> $\;\;\land\; \heap(n, p, w) \land v = \Root(z, k) \land x = p(x) \land z = \Some(w(x))\}$

\nextline\> \> $\{p^{*} \mbox{ partial order} \land (n, p, w) \models \phi \land
             x \in n \land w(\mathit{root}(x)) = y $ 
\nextline\> \> $\;\;\land\; \heap(n, p, w) x = p(x) \land \mathit{root}(x) = x \land z = \Some(w(x))\}$

\nextline\> \> $\{p^{*} \mbox{ partial order} \land (n, p, w) \models \phi \land
             x \in n \land w(x) = y $ 
\nextline\> \> $\;\;\land\; \heap(n, p, w) \land x = p(x) \land \mathit{root}(x) = x \land z = \Some(w(x))\}$

\nextline\> \> $\{p^{*} \mbox{ partial order} \land (n, p, w) \models \phi \land
             x \in n $
\nextline\> \> $\;\;\land\; \heap(n, p, w) \land x = p(x) \land \mathit{root}(x) = x \land z = \Some(y)\}$
\nextline \> \> $[(w, x, k)]$

\nextline\> \> $\{a.\;p^{*} \mbox{ partial order} \land (n, p, w) \models \phi \land
             x \in n $
\nextline\> \> $\;\;\land\; \heap(n, p, w) \land x = p(x) \land \mathit{root}(x) = x \land z = \Some(y) land a = (x, \Some(y), k)\}$

\nextline\> \> $\{a.\;G(n, p, w) \land a = (x, \Some(y), k)\}$
\nextline\> \> $\{a.\;\exists n, p, w.\; G(n, p, w) \land land a = (x, \Some(y), k)\}$

\nextline\> \> $\Child(m) \to$
\nextline\> \> $\{p^{*} \mbox{ partial order} \land (n, p, w) \models \phi \land
             x \in n \land w(\mathit{root}(x)) = y $ 
\nextline\> \> $\;\;\land\; \heap(n, p, w) \land v = \Child(p(x)) \land m = p(x) \}$

\nextline\> \> $\{p^{*} \mbox{ partial order} \land (n, p, w) \models \phi\bullet\elt{p(x)}{y} \land
             x \in n \land w(\mathit{root}(x)) = y $ 
\nextline\> \> $\;\;\land\; \heap(n, p, w) \land v = \Child(p(x)) \land m = p(x) \}$


\nextline\> \> $[$\=$\letv{(u, y, k)}{\ctext{findroot}(m)}{}$

\nextline\> \> $\{p'^{*} \mbox{ partial order} \land (n, p', w) \models \phi\bullet\elt{p(x)}{y} \land
             x \in n \land w(\mathit{root}(x)) = y $ 
\nextline\> \> $\;\;\land\; \heap(n, p, w) \land v = \Child(p(x)) \land u = \mathit{root}(p(x)) \}$



\end{specification}




This specification asserts that calling $\findroot$ will give us a new
heap which (a) models the same formula as before, and (b) will return
the upper fixed point of $x$, as well as its witness. If the witness
is the root itself, we return $\None$, and otherwise return the
witness wrapped in a $\Some$. (We also return the height, whose value
we are not tracking in our invariant.)

The key difficulty in this proof is that $\findroot$ implements
\emph{path compression} --- each recursive call modifies the heap in
nonlocal ways. This nonlocality is evident in the fact that the parent
and witness functions $p$ changes from the pre- to the post-condition.

The correctness of this program relies on the path compression lemma
we proved earlier. 





\begin{lemma}{(External Membership and Modelling)}
Suppose $n \subseteq \tau, p \in n \to n, w \in \mu(n) \to n$. Furthermore,
suppose $(p, n, w) \models \phi$, and $\ufcontains{\phi}{x}{y}$. 
Then $(n, p, w) \models \elt{x}{y}$. 
\end{lemma}

\begin{proof}
We proceed by induction on $\phi$: 
\begin{itemize}
  \item Case $\phi = \elt{x'}{y'}$
    By inversion on $\ufcontains{\phi}{x}{y}$, we know that the only 
    rule which can apply is the element rule, and so $x = x'$ and $y = y'$. 

    Then by hypothesis we know that $(n, p, w) \models \elt{x}{y}$. 

  \item Case $\phi = I$

    This case is impossible, since there is no rule from which we can
    conclude $\ufcontains{I}{x}{y}$. 

  \item Case $\phi = \psi \otimes \theta$. 

    By inversion, we know that either $\ufcontains{\psi}{x}{y}$, or 
    that $\ufcontains{\theta}{x}{y}$. 

    Then, since $(n, p, w) \models \psi \otimes \theta$, we know 
    that $(n_1, p, w) \models \psi$ and $(n_2, p, w) \models \theta$,
    where $n = n_1 \uplus n_2$. Without loss of generality, 
    suppose that $\ufcontains{\psi}{x}{y}$. Then by induction we know
    that $(n_1, p, w) \models \elt{x}{y}$, and then by monotonicity 
    we know that $(n, p, w) \models \elt{x}{y}$. 
\end{itemize}
\end{proof}

\begin{lemma}{(Relating Membership and Heaps)}
Suppose $n = n_1 \uplus n_2$. Then $\heap(n, p, w) \iff \heap(n_1, p, w) * \heap(n_2, p, w)$. 
\end{lemma}

\begin{proof}
  \begin{specification}
    \nextline By definition, $\heap(n, p, w) =  \forall^{*} l \in n. F(l)$, where
    \nextline  $F(l) = \IfTE{p(l) = l}{\exists n.\; l \pointsto \Root(\IfTE{w(x) = x}{\None}{\Some(w(x))}, n)}{l \pointsto \Child(p(l))}$.
    \nextline So $\heap(n, p, w) =  \forall^{*} l \in n_1 \uplus n_2. F(l)$. 
    \nextline So $\heap(n, p, w) =  \forall^{*} l \in n_1 F(l) * \forall^{*} l \in n_2 F(l)$. 
    \nextline So $\heap(n, p, w) = \heap(n_1, p, w) * \heap(n_2, p, w)$. 
  \end{specification}
\end{proof}

\begin{specification}
\nextline $\setof{H(\phi) \land \ufcontains{\phi}{x}{y}}$
\nextline Since $\ufcontains{\phi}{x}{y}$ is pure, we assume it outside
  the precondition. 
\nextline 
  $\{$\=$\exists n \subseteq \tau, p \in n \to n, w \in \mu(n) \to n.\;
      p^{*} \mbox{ partial order} \land 
             (n, p, w) \models \phi \;\land \heap(n, p, w) \}$
\nextline 
  $\{$\=$n \subseteq \tau, p \in n \to n, w \in \mu(n) \to n \land
   p^{*} \mbox{ partial order} \land 
             (n, p, w) \models \phi \;\land \heap(n, p, w) \}$
\nextline 
  Since $\ufcontains{\phi}{x}{y}$ implies $(n, p, w) \models \elt{x}{y}$, it 
  follows that:
\nextline 
    $\{$\=$n \subseteq \tau, p \in n \to n, w \in \mu(n) \to n \land
      p^{*} \mbox{ partial order} \land 
             (n, p, w) \models \phi \;\land \heap(n - {x}, p, w) \;*$ 
\nextline 
    \> $\IfTE{p(x) = x}{\exists n.\; x \pointsto \Root(\IfTE{w(x) = x}{\None}{\Some(w(x))}, n)}{l \pointsto \Child(p(x))}
\}$
\nextline $\letv{v}{[!x]}{}$
\nextline
    $\{$\=$n \subseteq \tau, p \in n \to n, w \in \mu(n) \to n \land
      p^{*} \mbox{ partial order} \land 
             (n, p, w) \models \phi \;\land \heap(n - {x}, p, w)\;*$ 
\nextline
    \> $x \pointsto v\;\land$ 
\nextline
    \> $v = \IfTE{p(x) = x}{\exists n.\; \Root(\IfTE{w(x) = x}{\None}{\Some(w(x))}, n)}{\Child(p(x))} \}$
\nextline $\run{}\ctext{case}(v,$
\nextline \;\;$\Root(u,k) \to\;$
\nextline \;\;
    $\{$\=$n \subseteq \tau, p \in n \to n, w \in \mu(n) \to n \land
      p^{*} \mbox{ partial order} \land 
             (n, p, w) \models \phi \;\land \heap(n - {x}, p, w)\;*$ 
\nextline
    \> $x \pointsto v \;\land$
\nextline
    \> $v = \IfTE{p(x) = x}{\exists n.\; \Root(\IfTE{w(x) = x}{\None}{\Some(w(x))}, n)}{\Child(p(x))} \;\land$ 
\nextline \> $v = \Root(u, k)\}$
\nextline \;\;
    $\{$\=$n \subseteq \tau, p \in n \to n, w \in \mu(n) \to n \land
      p^{*} \mbox{ partial order} \land 
             (n, p, w) \models \phi \;\land \heap(n - {x}, p, w)\;*$ 
\nextline
    \> $x \pointsto v \;\land$
\nextline
    \> $u = \IfTE{w(x) = x}{\None}{\Some(w(x))} \;\land$ 
\nextline
    \> $p(x) = x \;\land$
\nextline \;\;\=$\ctext{case}(u,$ 
\nextline \>\;\;\=$\None \to [(x, x, k)]$ 

  

\end{specification}
