\chapter{The Semantics of Separation Logic}

In this chapter, I will describe the semantics of our separation
logic. Rather than working directly with the heap model of separation
logic, we will approach the semantics in a somewhat more modular
style.

First, we will define what we mean by ``semantics of separation logic''
in terms of \emph{BI algebras}, which give an algebraic semantics of
separation logic in the same way that the Heyting algebras give
semantics to intuitionistic logics. Then, we will look at how we can
construct a BI-algebra from sets of elements of an arbitrary partial
commutative monoid, proving that we can satisfy each of the axioms of
a BI algebra.

Then, we will show that our predomain of heaps actually forms a
partial commutative monoid, which means that we can now apply the
theorems and definitions of the previous sections to immediately get
the heap model we want.

With a semantic definition of assertions in hand, we will then move on
to the semantics of specifications. We will again play the algebraic
game, and give a Kripke semantics for specifications. We will also
give a semantic interpretation of Hoare triples which validates the
frame rule and fixed point induction.

After defining the semantics of assertions and specifications, I will
give their syntax.

\section{BI Algebras}

A \emph{BI algebra} is a Heyting algebra with additional residuated
monoidal structure to model the separating conjunction and wand. This
means that a BI algebra is a partial order $(B, \leq)$ with operations
$(\top, \land, \implies, \bot, \vee, I, *, \wand)$ satisfying:

\begin{enumerate}
\item $\forall p \in B.\; p \leq \top$
\item $\forall p \in B.\; \bot \leq p$
\item $\forall p,q,r \in B.$ if $r \leq p$ and $r \leq q$, then
      $r \leq p \land q$ and 
      $p \land q \leq p$ and $p \land q \leq q$
\item $\forall p,q,r \in B.$ if $p \leq r$ and $q \leq r$, then
      $p \vee q \leq r$ and
      $p \leq p \vee q$ and $q \leq p \vee q$.
\item $\forall p, q, r.\; p \land q \leq r \iff p \leq q \implies r$
\item $\forall p.\; p * I = p$
\item $\forall p, q.\; p * q = q * p$
\item $\forall p, q, r.\; (p * q) * r = p * (q * r)$
\item $\forall p, q, r.\; p * q \leq r \iff p \leq q \wand r$
\end{enumerate}

The first five conditions are just the usual conditions for a Heyting
algebra (that it have greatest and least elements, greatest lower
bounds and least upper bounds, and that it have an implication). The
next three are the monoid structure axioms, that say $I$ is the unit,
and that $*$ is commutative and associative. The last axiom asserts
the existence of a wand that is adjoint to the separating conjunction
the same way that the implication is adjoint to the ordinary
conjunction.

In addition, we will also ask that this algebra be \emph{complete},
which means that meets and joins of arbitrary sets of elements be
well-defined.

\begin{enumerate}
\item[10.] $\forall r\in B, P \subseteq B.$ if $(\forall p \in P.\; r \leq p)$, then  
      $r \leq \bigwedge P $ and 
      $\forall p \in P.\; \bigwedge P \leq p$
\item[11.] $\forall r \in B, P \subseteq B.$ if $(\forall p \in P.\; p \leq r)$, then  
      $\bigvee P \leq r$ and 
      $\forall p \in P.\; p \leq \bigvee P$
\end{enumerate}

We will eventually use completeness in order to interpret quantifiers as 
possibly-infinitary conjunctions or disjunctions.
 
\subsection{Partial Commutative Monoids}

A partial commutative monoid is a triple $(M, e, \cdot)$, where $e \in
M$, and $(\cdot)$ is a partial operation from $M \times M$ to $M$. We
will write $m \# m'$ to mean that $m \cdot m'$ is defined. 

Furthermore, the following properties must hold:

\begin{itemize}
\item $e$ is a unit, so that $e \# m$ and $e \cdot m = m$. 
\item $(\cdot)$ is commutative. If $m_1 \# m_2$, then $m_2 \# m_1$ and $m_1 \cdot m_2 = m_2 \cdot m_1$. 
\item $(\cdot)$ is associative. 
  \begin{itemize}
  \item If $m_1 \# m_2$ and $(m_1 \cdot m_2) \# m_3$, then $m_2 \# m_3$ and $m_1 \# (m_2 \cdot m_3)$ and $(m_1 \cdot m_2) \cdot m_3 = m_1 \cdot (m_2 \cdot m_3)$.
  \item If $m_2 \# m_3$ and $m_1 \# (m_2 \cdot m_3)$, then $m_1 \# m_2$ and $(m_1 \cdot m_2) \# m_3$ and $(m_1 \cdot m_2) \cdot m_3 = m_1 \cdot (m_2 \cdot m_3)$.
  \end{itemize}
  
  
\end{itemize}

\subsection{BI-Algebras over Partial Commutative Monoids}

Given a partial commutative monoid, we can show that the powerset $\powerset{M}$ 
forms a BI-algebra. 

\begin{lemma}{(Powersets of Partial Commutative Monoids)}
Given a partial commutative monoid $(M, e, \cdot)$, its powerset
$(\powerset{M}, \subseteq)$ forms a BI-algebra
with the following operations:

\begin{itemize}
\item $\top = M$
\item $p \land q = p \cap q$
\item $p \implies q = \setof{m \in M \;|\;\mbox{if }m \in p \mbox{ then } m \in q}$
\item $\bot = \emptyset$ 
\item $p \vee q = p \cup q$
\item $I = \setof{e}$
\item $p * q = \setof{m \in M\;|\; \exists m_1, m_2.\; 
                       m_1 \# m_2 \mbox{ and } m_1 \in p \mbox{ and } m_2 \in q \mbox{ and } m_1\cdot m_2 = m}$
\item $p \wand q = \{ m \in M \;|\; \forall m' \in p.\; \mbox{if } m \# m' \mbox{ then } m \cdot m' \in q \}$
\item $\bigwedge P = \bigcap P$ 
\item $\bigvee P = \bigcup P$
\end{itemize}
\end{lemma}


\begin{proof}
\begin{enumerate}
\item  We want to show $\forall p \in \powerset{M}.\; p \leq \top$
  \begin{tabbedproof}
        Assume $p \in \powerset{M}$ \\
    \oo By definition of powerset, we have $p \subseteq M$ \\
    \oo By definition of $\top$, we have $p \subseteq \top$ \\
    \oo By definition of $\leq$, we have $p \leq \top$ \\
  \end{tabbedproof}

\item We want to show $\forall p \in B.\; \bot \leq p$
  \begin{tabbedproof}
        Assume $p \in \powerset{M}$ \\ 
    \oo By definition of $\emptyset$, we have $\emptyset \subseteq p$ \\
    \oo By definition of $\bot$, $\leq$, we have $\bot \leq p$ \\
  \end{tabbedproof}

\item We want to show $\forall p,q,r \in \powerset{M}.$ if $r \leq p$ and $r \leq q$, then
      $r \leq p \land q$ and 
      $p \land q \leq p$ and $p \land q \leq q$

   \begin{tabbedproof}
      Assume $p,q,r \in \powerset{M}$ \\
      Assume $r \leq p$, $r \leq q$ \\[1em]

      \oo Expanding definition of $\leq$, we have $r \subseteq p$ and $r \subseteq q$ \\
      \oo By properties of $\cap$, we have $r \cap r \subseteq p \cap q$ \\
      \oo Hence $r \subseteq p \cap q$ \\
      \oo By definition of $\leq$ and $\land$, we have $r \leq p \land q$ \\[1em]
      \oo By properties of $\cap$, we have $p \cap q \subseteq p$ \\
      \oo By definition of $\leq$ and $\land$, we have $p \wedge q \leq p$ \\[1em]
      \oo By properties of $\cap$, we have $p \cap q \subseteq q$ \\
      \oo By definition of $\leq$ and $\land$, we have $p \wedge q \leq q$ \\
   \end{tabbedproof}

\item We want to show $\forall p,q,r \in \powerset{M}.$ if $p \leq r$ and $q \leq r$, then
      $p \vee q \leq r$ and
      $p \leq p \vee q$ and $q \leq p \vee q$.

  \begin{tabbedproof}
    Assume $p, q, r \in \powerset{M}$, $p \leq r$, $q \leq $ \\[1em]
    \oo By definition of $\leq$, we have $p \subseteq r$, $q \subseteq r$ \\
    \oo By set properties, we have $p \cup q \subseteq r$ \\
    \oo By definition of $\leq$, we have $p \vee q \leq r$ \\[1em]

    \oo By set properties we have $p \subseteq p \cup q$ \\
    \oo By definitions of $\leq$ and $\vee$, we have $p \leq p \vee q$ \\[1em]
  
    \oo By set properties, we have $q \subseteq p \cup q$ \\
    \oo By definitions of $\leq$ and $\vee$, we have  $q \leq p \vee q$ \\
  \end{tabbedproof}

\item We want to show $\forall p, q, r \in \powerset{M}.\; p \land q \leq r \iff p \leq q \implies r$

  \begin{tabbedproof}
    Assume $p,q,r \in \powerset{M}$ \\[1em]

    $\To$ direction: \\
    \oo Assume $p \land q \leq r$ \\
    \ooo By definitions of $\leq$ and $\land$, we have $p \cap q \subseteq r$ \\
    \ooo We want to show $p \leq q \implies r$ \\
    \ooo So we want to show $p \subseteq (q \implies r)$ \\
    \ooo So we want to show $\forall m$, if $m \in p$ then $m \in (q \implies r)$ \\
    \ooo Assume $m$ and $m \in p$ \\
    \oooo Want to show $m \in q \implies r$ \\
    \oooo Equivalent to showing if $m \in q$, then $m \in r$ \\
    \oooo Assume $m \in q$ \\
    \ooooo Since $m \in p$ and $m \in q$, we know $m \in p \cap q$. \\
    \ooooo Since $p \cap q \subseteq r$, we know $m \in r$ \\
    \ooo Therefore $p \subseteq q \implies r$ \\
    \ooo By definition of $\leq$, we see $p \leq q \implies r$ \\[1em]

    $\Leftarrow$ direction:\\
    \oo Assume $p \leq q \implies r$ \\
    \ooo By definition of $\leq$, we know $p \subseteq q \implies r$ \\
    \ooo We want to show $p \land q \leq r$ \\
    \ooo So we want to show $p \cap q \subseteq r$ \\
    \ooo So we want to show $\forall m$, if $m \in p \cap q$ then $m \in r$ \\
    \ooo Assume $m \in p \cap q$ \\
    \oooo Hence $m \in p$ and $m \in q$ \\
    \oooo Since $p \subseteq q \implies r$, we know for all $m$, if $m \in p$, then if $m \in q$, then $m \in r$ \\
    \oooo Hence $m \in r$ \\
    \ooo Hence $p \cap q \subseteq r$ \\
    \ooo By definition of $\leq$ and $\land$, we conclude $p \land q \leq r$ \\
  \end{tabbedproof}

\item We want to show $\forall p \in \powerset{M}.\; p * I = p$
  \begin{tabbedproof}
    \oo Assume $p \in \powerset{M}$ \\
    \ooo We want to show $p * I = p$ \\ 
    \ooo This is equivalent to showing for all $m \in M$, that $m \in p * I$ if and only if $m \in p$ \\
    \ooo Assume $m \in M$ \\
    \oooo $\To$ direction: \\
    \ooooo Assume $m \in p * I$ \\
    \ooooo Therefore $\exists m_1, m_2 \in M$ such that \\
    \ooooox $m_1 \# m_2$ and $m_1 \in p$ and $m_2 \in I$ and $m = m_1 \cdot m_2$\\
    \ooooo Let $m_1, m_2$ be witnesses, so that \\
    \oooooo $m_1 \# m_2$ and $m_1 \in p$ and $m_2 \in I$ and $m = m_1 \cdot m_2$\\
    \oooooo Since $I = \setof{e}$, we know $m_2 = e$ \\
    \oooooo By unit property, $m = m_1 \cdot e = m_1$ \\
    \oooooo Since $m_1 \in p$, we know $m \in p$ \\
    \ooo $\From$ direction: \\
    \oooo Assume $m \in p$ \\
    \ooooo We want to show $m \in p * I$ \\ 
    \ooooo So we want to show there are $m_1, m_2$ \\
    \ooooox such that $m_1 \# m_2$ and $m_1 \in p$ and $m_2 \in I$ and $m = m_1 \cdot m_2$ \\
    \ooooo Choose $m_1$ to be $m$, and $m_2$ to be $e$ \\
    \ooooo So we want to show $m \# e$ and $m \in p$ and $e \in I$ and $m = m \cdot e$ \\
    \ooooo By properties of unit, $m \# e$ and $m = m \cdot e$ \\
    \ooooo By definition of $I$, we know $e \in I$ \\
    \ooooo We know $m \in p$ by hypothesis \\
    \ooooo Therefore goal in line 16 met. \\ 
  \end{tabbedproof}

\item We want to show $\forall p, q \in \powerset{M}.\; p * q = q * r$

  \begin{eqnproof}[\mbox{Assume }p,q \in \powerset{M}]
    \eline[p * q]
          {\setof{m \in M\;|\; \exists m_1 \in p, m_2 \in q.\; 
                       m_1 \# m_2 \land m_1\cdot m_2 = m}}
          {Definition}
    \eline{\setof{m \in M\;|\; \exists m_2 \in q, m_1 \in p.\; 
                       m_1 \# m_2 \land m_1\cdot m_2 = m}}
          {Logical manipulation}
    \eline{\setof{m \in M\;|\; \exists m_2 \in q, m_1 \in p.\; 
                       m_2 \# m_1 \land m_2\cdot m_1 = m}}
          {Commutativity}
    \eline{q * p}
          {Definition}    
  \end{eqnproof}

\item We want to show $\forall p, q, r \in \powerset{M}.\; (p * q) * r = p * (q * r)$

  \begin{tabbedproof}
    \oo Assume $p, q, r \in \powerset{M}$ \\
    \oo We want to show $(p * q) * r = p * (q * r)$ \\
    \oo This is equivalent to showing for all $m \in M$, that \\
    \ox $m \in (p * q) * r$ if and only if $ m \in p * (q * r)$ \\
    \oo Assume $m \in M$ \\
    \ooo $\To$ direction: \\
    \oooo Assume $m \in (p * q) * r$ \\
    \ooooo Therefore there are $m_{pq}, m_r$ such that \\
    \ooooox $m_{pq} \# m_r$ and $m = m_{pq} \cdot m_r$ and $m_{pq} \in p * q$ and $m_r \in r$ \\
    \ooooo From $m_{pq} \in p * q$, we know there are $m_p$, $m_q$ such that \\
    \ooooox $m_p \# m_q$ and $m_{pq} = m_p \cdot m_q$ and $m_p \in p$ and $m_q$ in $r$ \\
    \ooooo By $m_{pq} = m_p \cdot m_q$, we know $m = (m_p \cdot m_q) \cdot m_r$ and $(m_p \cdot m_q) \# m_r$\\
    \ooooo Since $m_p \# m_q$ and $(m_p \cdot m_q) \# m_r$, by associativity we know \\
    \ooooox $m_q \# m_r$ and $m_p \# (m_q \cdot m_r)$ and 
            $m = (m_p \cdot m_q) \cdot m_r = m_p \cdot (m_q \cdot m_r)$ \\
    \ooooo Since $m_q \# m_r$ and $m_q \cdot m_r = m_q \cdot m_r$ and $m_q \in q$ and $m_r \in r$, \\
    \ooooox we know $m_q \cdot m_r \in q * r$ \\
    \ooooo Since $m_p \# (m_q \cdot m_r)$ and $m_p \cdot (m_q \cdot m_r) = m_p \cdot (m_q \cdot m_r)$ \\
    \ooooox and $m_p \in p$ and $m_q \cdot m_r \in q * r$,  we know $m_p \cdot (m_q \cdot m_r) \in p * (q * r)$ \\
    \ooooo Therefore $m \in p * (q * r)$ \\
    \ooo $\From$ direction: \\
    \oooo Assume we have $m_p, m_{qr}$ such that \\
    \oooox $m_p \# m_{qr}$ and $m = m_p \cdot m_{qr}$ and $m_p \in p$ and $m_{qr} \in q * r$ \\
    \ooooo Therefore we have $m_q, m_r$ such that \\
    \ooooox $m_q \# m_{r}$ and $m_{qr} = m_q \cdot m_r$ and $m_q \in q$ and $m_r \in r$ \\
    \ooooo From $m_{qr} = m_q \cdot m_r$ we have \\
    \ooooox $m = m_p \cdot (m_q \cdot m_r)$ and $m_p \# (m_q \cdot m_r)$ \\
    \ooooo By associativity with $m_q \# m_{r}$ and $m_p \# (m_q \cdot m_r)$, we have \\
    \ooooox $m_p \# m_q$ and $(m_p \cdot m_q) \# m_r$ and 
            $m = m_p \cdot (m_q \cdot m_r) = (m_p \cdot m_q) \cdot m_r$ \\
    \ooooo Since $m_p \# m_q$ and $m_p \in p$ and $m_q \in q$, we know \\
    \ooooox $(m_p \cdot m_q) \in p * q$ \\
    \ooooo Since $(m_p \cdot m_q) \# m_r$ and $(m_p \cdot m_q) in p * q$ and $m_r \in r$, we have \\ 
    \ooooox $(m_p \cdot m_q) \cdot m_r \in (p * q) * r$ \\
    \ooooo Therefore $m \in (p * q) * r$ \\
  \end{tabbedproof}

\item We want to show that for all $p, q, r \in \powerset{M}$, $p * q \leq r$ if and
only if $p \leq q \wand r$. 

  \begin{tabbedproof}
    Assume $p, q, r \in \powerset{M}$. \\
    \oo First, we will give the $\To$ direction. \\
    \oo Assume $p * q \leq r$ \\
    \oo So we know 
          $\comprehend{m}{\exists m_1, m_2.\; m_1 \# m_2 \mbox{ and } m_1 \in p \mbox{ and } m_2 \in q 
                                             \mbox{ and } m_1 \cdot m_2 = m}
           \subseteq r$ \\
    \oo Thus, $\forall m.\; (\exists m_1, m_2.\; m_1 \# m_2 \mbox{ and } m_1 \in p \mbox{ and } m_2 \in q 
                                             \mbox{ and } m_1 \cdot m_2 = m)$ implies $m \in r$. \\
    \oo By turning existentials on the left into universals, and instantiating $m$, \\
    \ooo
             $\forall m_1, m_2.\; (m_1 \# m_2 \mbox{ and } m_1 \in p \mbox{ and } m_2 \in q) \mbox{ implies } (m_1 \cdot m_2) \in r$ [HYP1] \\
    \oo Now, to show $p \leq q \wand r$, we must show
         for all $m$, if $m \in p$, that $m \in q \wand r$. \\
    \oo Assume $m$, $m \in p$. [HYP2] \\
    \ooo Now, we want to show $m \in \comprehend{m}{\forall m' \in q.\; m\# m' \mbox{ and } m' \mbox{ implies } (m \cdot m') \in r}$ \\
    \ooo This is equivalent to showing $\forall m' \in q.\; m\# m' \mbox{ and } m' \mbox{ implies } (m \cdot m') \in r$ \\
    \ooo Assume $m'$, $m' \in q$, $m \# m'$. [HYP3] \\ 
    \oooo Instantiating [HYP1] with $m$ and $m'$ and the hypotheses in [HYP2] and [HYP3], \\
    \oooo we can conclude $(m \cdot m') \in r$.  \\[1em]

    \oo Now, we will show the $\Leftarrow$ direction. \\
    \oo Assume $p \leq q \wand r$. \\
    \oo So we know, $p \subseteq \comprehend{m}{\forall m' \in q. m \# m' \mbox{ and } m' \in q \mbox{ implies } (m \cdot m') \in r}$ \\
    \oo Therefore $\forall m. m \in p \mbox{ implies } \forall m' \in q.\; m \# m' \mbox{ and } m' \in q \mbox{ implies } (m \cdot m') \in r$.  \\
    \oo Therefore $\forall m, m'.\; m \in p \mbox{ and } m' \in q \mbox{ and } m \# m' \mbox{ implies } (m \cdot m') \in r$ \\
    \oo Therefore $\forall m_o, m, m'.\; m \in p \mbox{ and } m' \in q \mbox{ and } m \# m' \mbox{ and } m_o = m\cdot m' \mbox{ implies } m_o \in r$ \\
    \oo Therefore $\forall m_o, (\exists m, m'.\; m \in p \mbox{ and } m' \in q \mbox{ and } m \# m' \mbox{ and } m_o = m\cdot m') \mbox{ implies } m_o \in r$ \\
    \oo Therefore $\forall m_o, m_o \in (p * q) \mbox{ implies } m_o \in r$ \\
    \oo Therefore $p * q \subseteq r$ \\
    \oo Therefore $p * q \leq r$ \\

  \end{tabbedproof}

\item We want to show $\forall r, P \subseteq B$, if $(\forall p \in P.\; r \leq p)$, then
$r \leq \bigwedge P$ and $\forall p \in P.\; \bigwedge P \leq p$. 

  \begin{tabbedproof}
    \oo Assume $r$, $P$, $P \subseteq B$, and $(\forall p \in P.\; r \leq p)$ \\[1em]
    \ooo First, we want to show $r \leq \bigwedge P$. \\
    \oooo This is equivalent to showing $r \subseteq \bigcap P$ \\
    \oooo This is equivalent to showing that for all $m \in r$, $m \in \bigcap P$. \\
    \oooo Assume $m$, $m \in r$.  \\
    \ooooo Showing $m \in \bigcap P$ is equivalent to $\forall p \in P. m \in p$ \\
    \ooooo Assume $p \in P$.  \\
    \oooooo Instantiating hypothesis with $p$, $r \subseteq p$. \\
    \oooooo This means $\forall m'. m' \in r \implies m' \in p$. \\
    \oooooo Instantiating $m'$ with $m$, we learn $m \in p$. \\
    \oooo Therefore, $r \leq \bigwedge P$. \\[1em]
    \ooo Second, we want to show that $\forall p \in P.\; \bigwedge P \leq p$. \\
    \ooo Assume $p$, $p \in P$. \\
    \oooo Now, we want to show $\bigwedge P \leq p$. \\
    \oooo This is equivalent to showing $\bigcap P \subseteq p$. \\
    \oooo This is equivalent to showing $\forall m.\; m \in \bigcap P \implies m \in p$ \\
    \oooo Assume $m$, $m \in \bigcap P$.  \\
    \ooooo Therefore, $\forall p' \in P.\; m \in p'$. \\
    \ooooo Instantiating $p'$ with $p$, we get $m \in p$. \\
  \end{tabbedproof}

\item We want to show $\forall r, P \subseteq B$, if $(\forall p \in P.\; p \leq r)$, then
$\bigvee P \leq r$ and $\forall p \in P.\; p \leq \bigvee P$. 

  \begin{tabbedproof}
    \oo Assume $r, P \subseteq B$, and $(\forall p \in P.\; p \leq r)$ \\[1em]
    \ooo First, we want to show $\bigvee P \leq r$ \\
    \oooo This is equivalent to showing $\bigcup P \subseteq r$ \\
    \oooo This is equivalent to showing $\forall m.\; m \in \bigcup P \implies m \in r$ \\
    \oooo Assume $m$, $m \in \bigcup P$. \\
    \ooooo $m \in \bigcup P$ is equivalent to $\exists p \in P.\; m \in p$ \\
    \ooooo Suppose $p' \in P$ is the witness, and that $m \in p'$ \\ 
    \oooooo Instantiating the quantifier $p$ in the hypothesis, we get $p' \leq r$ \\
    \oooooo This means $\forall m', m' \in p' \implies m' \in r$ \\
    \oooooo Instantiating the quantifier $m'$ with $m$,  we conclude $m \in r$.  \\
    \oooo Therefore, $\forall m.\; m \in \bigcup P \implies m \in r$ \\[1em]
    \ooo Second, we want to show $\forall p \in P.\; p \leq \bigvee P$. \\
    \oooo Assume $p$, $p \in P$ \\
    \ooooo We want to show $p \leq \bigvee P$ \\
    \ooooo This is equivalent to showing $p \subseteq \bigcup P$ \\
    \ooooo This is equivalent to showing $\forall m.\; m \in p \implies m \in \bigcup P$ \\
    \ooooo This is equivalent to showing $\forall m.\; m \in p \implies \exists p' \in P.\; m \in p'$ \\
    \ooooo Assume $m$, $m \in p$ \\
    \oooooo Take $p'$ to be $p$, since $p \in P$. \\
    \oooooo Thus, $m \in p$ by hypothesis \\
    \oooo Therefore, $p \leq \bigvee P$ \\
  \end{tabbedproof}

\end{enumerate}


\end{proof}

\subsection{Sets of Heaps Form the BI Algebra of Heap Assertions}

Now, we will take our predomain $H$ and form a partial commutative
monoid from it, from which we can build a complete BI algebra. This
algebra will serve as the domain of interpretation of heap
assertions. To construct it, we will first apply the forgetful functor
$U$ to $H$, to forget the partial order structure and leaving us with
$U(H)$, the ordinary set of heaps.
\begin{displaymath}
U(H) = \sum L \in \powersetfin{Loc}.\; (\prod \sempair{n}{A} \in L.\;
\interp{\judgeWK[\cdot]{A}{\bigstar}}\;(*)\;(K,K))
\end{displaymath}
However, in what follows we will suppress the $U$, in order to reduce
clutter. Now, we can define the operations on it as follows:

\begin{itemize}
\item The unit element $e \triangleq \sempair{\emptyset}{\emptyset}$
\item The operation $(L, f) \cdot (L', g)$ is defined when $L \cap L' = \emptyset$, and
      is equal to 

\begin{displaymath}
 \left(L \cup L', \lambda x.\;\left\{\begin{array}{ll}
                                 f(x) & \mathsf{when}\; x \in L \\
                                 g(x) & \mathsf{when}\; x \in L'
                               \end{array}
                         \right.\right)
 \end{displaymath}
\end{itemize}

The lambda-expression in the operation definition actually defines a
function. Since we know that since $L$ and $L'$ are disjoint, this
means that any element of $x \in L \cup L'$ is exclusively either in
$L$ or $L'$, which means that the definition is unambiguous. Since $f$
and $g$ are well-typed with respect to the index sets $L$ and $L'$
respectively, our new function must be as well.

Now, we can check the properties. 

\begin{itemize}

\item First, we will check that $e$ is a unit. Suppose we have $m = (L, f) \in H$. 

\begin{eqnproof}
  \eline[(\emptyset, \emptyset) \cdot (L, f)]
        {\left(\emptyset \cup L, \lambda x.\; \left\{\begin{array}{ll}
                                                      \emptyset(x) & \mathsf{when}\; x \in \emptyset \\
                                                       f(x) & \mathsf{when}\; x \in L \\
                                                     \end{array}
                                              \right.\right)}
        {Definition}
  \eline{\left(L, \lambda x.\; \begin{array}{ll}
                                  f(x) & \mathsf{when}\; x \in L \\
                               \end{array} \right)}
        {Simplification}
  \eline{\sempair{L}{f}}
        {Simplification}
\end{eqnproof}

\item Second, we will check commutativity. Suppose we have $(L,f) \in H$ and $(L',g) \in H$. 

  First, it's obviously the case that if $L \cap L' = \emptyset$, then $L' \cap L = \emptyset$. 

  \begin{eqnproof}
    \eline[(L,f) \cdot (L',g)] 
          { \left(L \cup L', \lambda x.\;\left\{\begin{array}{ll}
                                 f(x) & \mathsf{when}\; x \in L \\
                                 g(x) & \mathsf{when}\; x \in L'
                               \end{array}
                         \right.\right)}
          {Definition}
    \eline{\left(L' \cup L, \lambda x.\;\left\{\begin{array}{ll}
                                 f(x) & \mathsf{when}\; x \in L \\
                                 g(x) & \mathsf{when}\; x \in L' \\
                               \end{array}
                         \right.\right)}
          {Commutativity of $\cup$}
    \eline{\left(L' \cup L, \lambda x.\;\left\{\begin{array}{ll}
                                 g(x) & \mathsf{when}\; x \in L' \\
                                 f(x) & \mathsf{when}\; x \in L \\
                               \end{array}
                         \right.\right)}
          {Reordering Cases}
    \eline{(L',g) \cdot (L,f)}
          {Definition}
  \end{eqnproof}

\item Now, we will check associativity. Suppose $(L,f)$, $(L',g)$, and $(L'',h)$ are in $H$. 

  First, assume that $L \cap L' = \emptyset$ and that $(L \cup L') \cap L'' = \emptyset$. 
  Then we know that $L \cap L'' = \emptyset$ and $L' \cap L'' = \emptyset$, so we can 
  conclude that $L \cap (L' \cup L'') = \emptyset$. 

  Second, assume that $L' \cap L'' = \emptyset$ and that $L \cap (L' \cup L'') = \emptyset$. 
  Then we know that $L \cap L' = \emptyset$ and $L \cap L'' = \emptyset$, so we can 
  conclude that $(L \cup L') \cap L'' = \emptyset$. 

  \begin{eqnproof}
    \eline[(L,f)\cdot((L',g)\cdot(L'',h))]
          {(L,f)\cdot \left(L' \cup L'', 
                            \lambda x.\; \left\{
                                  \begin{array}{ll}
                                     g(x) & \mathsf{when}\; x \in L' \\
                                     h(x) & \mathsf{when}\; x \in L'' \\
                                  \end{array}\right.\right)}
          {Definition}
     \eline{\left(L \cup (L' \cup L''), 
                            \lambda x.\; \left\{
                                  \begin{array}{ll}
                                     f(x) & \mathsf{when}\; x \in L \\
                                     g(x) & \mathsf{when}\; x \in L' \\
                                     h(x) & \mathsf{when}\; x \in L'' \\
                                  \end{array}\right.\right)}
           {Definition}
     \eline{\left((L \cup L') \cup L'', 
                            \lambda x.\; \left\{
                                  \begin{array}{ll}
                                     f(x) & \mathsf{when}\; x \in L \\
                                     g(x) & \mathsf{when}\; x \in L' \\
                                     h(x) & \mathsf{when}\; x \in L'' \\
                                  \end{array}\right.\right)}
           {Associativity}
      \eline{\left(L \cup L', 
                    \lambda x.\; \left\{
                                  \begin{array}{ll}
                                     f(x) & \mathsf{when}\; x \in L \\
                                     g(x) & \mathsf{when}\; x \in L' \\
                                  \end{array}\right.\right) \cdot (L'', h)}
            {Definition}
    \eline{((L,f)\cdot(L',g))\cdot(L'',h)}
          {Definition}
  \end{eqnproof}
\end{itemize}
Therefore, we can use the construction of the previous subsection to
equip sets of heaps with the structure of a complete BI algebra.

\section{Challenges in Interpreting Specifications}

In this section, we will give the semantics of specifications. There
are two main technical challenges to overcome. First, we will need to
handle the problem of supporting fixed point induction, and second, we
will need to support the frame rule of separation logic. We will first
describe these two problems, and then give each problem's solution. 

\subsection{Admissibility and Fixed Point Induction}

We are designing a partial correctness program logic, and so to prove
the correctness of recursive definitions, we would like an LCF-style
fixed point induction rule. Suppose we wish to state a property $P$ of
the fixed point of a functional $f : \monad{A} \to \monad{A}$. (For
example, $P$ may be a Hoare triple). Ideally, we want to give an
inference rule for recursion taking the following form:

\begin{mathpar}
  \inferrule*[right={Fixed Point Induction (Almost)}]
            {P(\bot) \\ \forall x.\;P(x) \implies P(f(x))}
            {P(\mathit{fix}(f))}
\end{mathpar}
This rule asserts that we prove a property $P$ by showing it holds of
$\bot$, and that applying $f$ preserved the truth of $P$.  However,
this rule is not sound for all $P$ --- it is only sound for
\emph{admissible} $P$. That is, we need the additional condition that
if $P$ holds for every element of a chain, it also holds for the limit
of the chain. Not all predicates are admissible; consider for example
the $f$ on the (pointed natural numbers):
\begin{displaymath}
  \begin{array}{lcl}
    f & = & \semfun{g}{\semfun{x}{\IfTE{x = 0}{0}{g(x-1)}}} \\
    P(h) & = & \exists n:\mathbb{N}.\;h(n) = \bot
  \end{array}
\end{displaymath}
Here, $P(f^k(\bot))$ holds for any $k$-approximation --- $f^k(\bot)$ will
loop on any input larger than $k$. However, the fixed point will never
loop on any natural number input. 

Often, admissibility is checked by syntactic conditions which pick out
a class of predicates known to be admissible. We cannot take this
approach, since we will use a higher-order assertion logic. As a
result, we do not know what the shape of a proposition is, since it
may refer to proposition variables.

To handle this problem, we will use a technique sometimes called
continuation closure or $\top\top$-closure, which will force our Hoare
triples to be admissible (indeed, continuous) predicates. This will
let us make free use of arbitrary assertions in Hoare triples, with no
restrictions on the forms of pre- or post-conditions.

\subsection{The Frame Rule}

We also face a second sticky issue: our denotational semantics does
not validate the frame property. The interpretation of the
$\newref{A}{e}$ command allocates a new reference by finding the
largest numeric id of any reference in the heap's domain, and then
allocating a reference whose numeric id is one greater than that.

This means that the behavior of the memory allocator is deterministic,
which means that our semantic domain can include awkward programs
which crash if the heap is larger than a certain size. Concretely,
consider the following basic continuation:
\begin{displaymath}
  \begin{array}{lcl}
    k_{\mathit{bad}} \;(L,h) & = & \IfTE{|L| < 50}{\bot}{\top}
  \end{array}
\end{displaymath}

This continuation is safe (i.e., returns $\bot$) if the heap contains
fewer than 50 elements, and will crash (i.e., return $\top$)
otherwise. Obviously, the safety monotonicity property cannot hold for
such programs, because extending the heap enough can cause programs to
switch from running safely to crashing. On the other hand, we do not
actually want to prove the correctness of any of these pathological
programs: all the programs we actually want to write and prove correct
are actually well-behaved, and will not pay attention to state they
have no ownership of.

To make use of this fact, we will adapt an idea of Birkedal and
Yang~\cite{birkedal-yang}. They proposed changing the interpretation
of program specifications from a boolean semantics (in which each
specification is either true or false) into a Kripke interpretation.

The modal frame they proposed was one in which worlds are sets of
assertions of separation logic (i.e., elements of a BI algebra).
Intuitively, we can think of each world as ``the set of assertions
that can be safely framed onto this specification''. A specification
is then true when all assertions can be framed onto it, which is how
we will end up justifying the frame rule. As we did for assertions, we
will proceed in a modular way. We will first define a ``world
preorder'' on elements of a BI algebra --- the extension ordering ---
and then use this ordering to give the truth values as upwards-closed
sets of assertions.

\section{Basic Hoare Triples}

Since we have a continuation semantics, it is natural to define a
continuation style interpretation of basic Hoare triples, as well.
Our initial attempt, however, will not succeed:
\begin{displaymath}
  \basicspec{P}{C}{a:A}{Q(a)} \triangleq
    \forall h \in P.\; \left(C\;Q\;h = \bot\right)
\end{displaymath}
The idea is that we can view a postcondition $Q(v)$ as a sort of continuation, 
which returns $\bot$ if $h \in Q(v)$, and $\top$ otherwise. So we say that 
for every heap in $P$, $C\;Q\;h$ must be bottom. 

While elegant, this idea suffers from the difficulty that $Q$ is an
assertion, a function from $A$ to heaps to values, $C$ requires its
continuation argument to be \emph{continuous}, a property which is not
met by arbitrary $Q$. This idea can be repaired if we define a ``best
continuous approximation'' to each $Q$.

\subsection{Approximating Postconditions}

Given a predomain $A$, and a $Q \in U(A) \to \powerset{H}$, we define $Approx(Q)$ as 
the set:
\begin{displaymath}
  Approx(Q) \triangleq \comprehend{k \in A \to H \to O}
                         {\forall v \in A, h \in Q(v).\; k\;v\;h = \bot}
\end{displaymath}

These define a set of continuations which ``continuously approximate''
the postcondition $Q$ -- they are the set of continuations which run
forever when given a value and heap in $Q$.  From this set we will
define the function $Best(Q)$, which will be the ``best continuous
approximation'' to Q. (Intuitively, think of this as being like a
closure operator from topology, which finds the smallest open set
containing the given set.)

\begin{displaymath}
  Best(Q) \triangleq \lambda v \in A.\; \lambda h \in H.\; 
    \left\{\begin{array}{ll}
             \top & \mbox{when } \exists k \in Approx(Q).\; k\;v\;h = \top \\
             \bot & \mbox{otherwise}
           \end{array}
    \right.
\end{displaymath}
Of course, we have to verify that $Best(Q)$ is actually a continuous function. 

\begin{itemize}
\item First, we need to check that $Best(Q)$ is a monotone function. 

\begin{tabbedproof}
\oo Suppose we have $v \sqsubseteq v'$ and $h \sqsubseteq h'$. \\
\ooo We know $Best(Q)\;v\;h \in O$. Analyzing this by cases, we see \\
\ooo Suppose $Best(Q)\;v\;h = \bot$ \\
\oooo Since $\forall o \in O.\; \bot \sqsubseteq o$, it follows that 
      $\bot \sqsubseteq Best(Q)\;v'\;h'$ \\
\oooo So $Best(Q)\;v\;h \sqsubseteq Best(Q)\;v'\;h'$ \\
\ooo Suppose $Best(Q)\;v\;h = \top$ \\
\oooo By definition of $Best(Q)$, $\exists k \in Approx(Q).\; k\;v\;h = \top$ \\
\oooo Let $k \in Approx(Q)$ be the witness such that $k\;v\;h = \top$ \\ 
\ooooo Since $k$ is monotone, $k\;v\;h \sqsubseteq k\;v'\;h'$ \\
\ooooo So $\top \sqsubseteq k\;v'\;h'$ \\
\ooooo Since $\top$ is maximal in $O$, $k\;v'\;h' = \top$ \\
\ooooo So we can take $k$ to be the witness such that $\exists k.\; k\;v'\;h' = \top$ \\
\oooo Therefore $Best(Q)\;v'\;h' = \top$ \\
\oooo Therefore $Best(Q)\;v\;h \sqsubseteq Best(Q)\;v'\;h'$ \\
\end{tabbedproof}

\item Second, we need to show that $Best(Q)$ preserves limits. 

\begin{tabbedproof}
\oo Suppose we have two chains $v_i$ and $h_i$ such that $i \leq j$
implies $v_i \sqsubseteq v_j$ and $h_i \sqsubseteq h_j$. \\
\ooo We want to show that $\bigsqcup_i Best(Q)\;v_i\;h_i = Best(Q)\;(\sqcup v_i)\;(\sqcup h_i)$ \\
\ooo By excluded middle, either some $k$ in $Approx(Q)$ such that $k\;(\sqcup v_i)\;(\sqcup h_i) = \top$, or not. \\
\ooo Suppose that $\exists k \in Approx(Q).\; k\;(\sqcup v_i)\;(\sqcup h_i) = \top$ \\
\oooo Therefore $Best(Q)\;(\sqcup v_i)\;(\sqcup h_i) = \top$ \\
\oooo By continuity of $k$, $\bigsqcup_i k\;v_i\;h_i = \top$ \\
\oooo Since $O$ is discrete, there is an $n$ such that $k\;v_n\;h_n = \top$ \\
\oooo Therefore, for all $j \geq n$, $Best(Q)\;v_n\;h_n = \top$ \\
\oooo This means $\bigsqcup_i Best(Q)\;v_i\;h_n = \top$ \\
\oooo Therefore $\bigsqcup_i Best(Q)\;v_i\;h_n = Best(Q)\;(\sqcup v_i)\;(\sqcup h_i)$ \\
\ooo Suppose that $\lnot(\exists k \in Approx(Q).\; k\;(\sqcup v_i)\;(\sqcup h_i) = \top$ \\
\oooo This is equivalent to $\forall k \in Approx(Q).\; k\;(\sqcup v_i)\;(\sqcup h_i) = \bot$ \\
\oooo This means $Best(Q)\;(\sqcup v_i)\;(\sqcup h_i) = \bot$ \\
\oooo Now, assume $k \in Approx(Q)$ \\
\ooooo So $k\;(\sqcup v_i)\;(\sqcup h_i) = \bot$ \\
\ooooo By continuity, $\bigsqcup_i k\;v_i\;h_i = \bot$ \\
\ooooo Therefore for all $i$, $k\;v_i\;h_i = \bot$ \\
\oooo So for all $k \in Approx(Q)$ and $i$, we know $k\;v_i\;h_i = \bot$ \\
\oooo This is equivalent to $\forall i.\; \lnot(\exists k \in Approx(Q).\; k\;v_i\;h_i = \top)$\\
\oooo Therefore, for all $i$, we know $Best(Q)\;v_i\;h_i = \bot$ \\
\oooo Therefore, we know $\bigsqcup_i Best(Q)\;v_i\;h_i = \bot$ \\
\oooo So we conclude $\bigsqcup_i Best(Q)\;v_i\;h_i = Best(Q)\;(\sqcup v_i)\;(\sqcup h_i)$\\
\end{tabbedproof}
\end{itemize}
This establishes that $Best(Q)$ is a continuous function. 

Now we will prove a minor lemma about this function, which shows that
we are interpreting the two-point Sierpinksi lattice $O = \setof{\bot
  \sqsubseteq \top}$ such that the bottom element is truth, and the
top element is falsehood.

\begin{lemma}{(Inclusion Order Reverses Approximation Order)}
Suppose $Q$ and $Q'$ are assertions in $\interp{A} \to \powerset{H}$, and
that for all $a \in \interp{A}$, $Q(a) \subseteq Q'(a)$. Then
$\mathit{Best}(Q') \sqsubseteq \mathit{Best}(Q)$.
\end{lemma}

\begin{tabbedproof}
\oo We want to show $\mathit{Best}(Q') \sqsubseteq \mathit{Best}(Q)$ \\
\oo First, we will observe that $\mathit{Approx}(Q') \subseteq \mathit{Approx}(Q)$ \\
\oo So, suppose that $k \in \mathit{Approx}(Q')$. We want to show $k \in \mathit{Approx}(Q)$. \\
\ooo We want to show that for all $a \in \interp{A}$ and $h \in Q(a)$, $k\;a\;h = \bot$.  \\
\ooo Assume that $a \in \interp{A}$ and $h \in Q(a)$. \\ 
\oooo We know that since $Q(a) \subseteq Q'(a)$, we have $h \in Q'(a)$.  \\
\oooo Therefore since $k \in \mathit{Approx}(Q')$, we know $k\;a\;h = \bot$ \\
\oo Now, we want to show that $\mathit{Approx}(Q') \subseteq \mathit{Approx}(Q)$ \\
\oo So we want to show that for all $a \in \interp{A}$ and $h \in H$, $\mathit{Approx}(Q')\;a\;h \subseteq \mathit{Approx}(Q)\;a\;h$ \\
\oo Assume we have $a \in \interp{A}$ and $h \in H$ \\
\ooo Suppose $\mathit{Approx}(Q')\;a\;h = \top$: \\
\oooo Therefore there is a $k\in\mathit{Approx}(Q')$ such that $k\;a\;h = \top$ \\
\oooo Therefore $k \in \mathit{Approx}(Q)$, and so $\mathit{Approx}(Q)\;a\;h = \top$ \\
\ooo Suppose $\mathit{Approx}(Q')\;a\;h = \bot$: \\
\oooo Therefore for all $k \in \mathit{Approx}(Q')$, we have $k\;a\;h = \top$ \\
\oooo Therefore for all $k \in \mathit{Approx}(Q)$, we have $\mathit{Approx}(Q)\;a\;h = \bot$ \\

\end{tabbedproof}

\subsection{Defining the Basic Hoare Triples}

Supposing that $P$ is an element of the BI algebra $\powerset{H}$, $C$ is an element
of the domain of commands $(A \to K) \to K$, and $Q$ is an $A$-indexed assertion, of
type $A \to \powerset{H}$, then we can define the basic boolean Hoare triple 
$\basicspec{p}{c}{a:A}{q(a)}$:

\begin{displaymath}
  \basicspec{P}{C}{a:A}{Q(a)} \triangleq
    \forall h \in P.\; \left(C\;Best(Q)\;h = \bot\right)
\end{displaymath}

If $C$ is given a continuation which will run forever (i.e., yields
$\bot$) whenever it receives a heap in $Q$, then given a heap $h \in
P$, $C$ applied to that continuation and that heap will also run forever.

The reason that we interpret triples this way is to make the
fixed-point induction rule a sound rule of inference. Intuitively, we
are defining our triples only in terms of continuous things, and so
the limit of a chains should agree with the chain.

We will not prove this fact here, deferring that proof for the Kripke
Hoare triples we will actually use. The reason is that these basic
triples are too basic --- they do not validate the frame property ---
and so we will not need to use basic Hoare triples except as a tool
used to define our Kripke Hoare triples.


\section{Kripke Hoare Triples}

As with the development of the assertion logic, we will proceed in a
modular style, by first giving algebraic conditions we want our  

\subsection{World Preorders}

We can define a world preorder $W(B, \worldleq)$ over a BI algebra $B$ as
follows.  The elements of $W(B, \leq)$ are the elements of $B$, and for any
two elements $p$ and $q$, the ordering $p \worldleq q$ is defined as
follows:

\begin{displaymath}
p \worldleq q \iff \exists r.\; p * r = q
\end{displaymath}

To verify the relation $\worldleq$ is a preorder, we need to 
show it is reflexive and transitive. 

$p \worldleq p$ holds because we can take $r$ to be $I$. 


To show transitivity, we must show that $p_1 \worldleq p_3$, given
that $p_1 \worldleq p_2$ and $p_2 \worldleq p_3$.

\begin{tabbedproof}
\oo Assume $p_1 \worldleq p_2$  \\
\oo Assume $p_2 \worldleq p_3$  \\
\ooo By definition of $\worldleq$, $\exists r.\; p_1 * r = p_2$ \\
\ooo By definition of $\worldleq$, $\exists r'.\; p_2 * r' = p_3$ \\
\ooo Let $r$ and $r'$ be the witnesses in lines 3 and 4, so we have \\
\oooo $p_1 * r = p_2$ \\
\oooo $p_2 * r' = p_3$ \\
\oooo Substituting for $p_2$, we get $p_1 * r * r' = p_3$ \\
\oooo Taking as witness $r'' = r * r'$, we show $\exists r''.\; p_1 * r'' = p_3$ \\
\ooo By definition of $\worldleq$, $p_1 \worldleq p_3$ \\
\end{tabbedproof}

\subsection{Heyting Algebras over Preorders}

Given any preorder $(P, \worldleq)$, we can construct a complete
Heyting algebra by considering the set of its upward-closed subsets
$(\upset{P}, \subseteq)$:

\begin{displaymath}
\upset{P} = 
  \{ S \in \mathcal{P}(P) \;|\;
     \forall p \in S, \forall q \in P. \mbox{ if } p \worldleq q \mbox{ then } q \in S 
  \}
\end{displaymath}

The ordering relation for the Heyting algebra is set inclusion, and
the operations are:

\begin{itemize}
\item $\top = P$
\item $\bot = \emptyset$
\item $S \land S' = S \cap S'$
\item $S \vee S' = S \cup S'$
\item $\bigwedge_{i \in I} S_i = \bigcap_{i \in I} S_i$
\item $\bigvee_{i \in I} S_i = \bigcup_{i \in I} S_i$
\item $S \implies S' = \{ r \in P \;|\; \forall r' \worldgeq r.\; 	
                          \mbox{if } r' \in S \mbox{ then } r' \in S' \}$
\end{itemize}

The idea here is that we will take the world preorder over assertions
(ordered by the extension order $\worldleq$) and use it to define a
Heyting algebra, whose elements will become the interpretations of
specifications.

To show that these operations actually form a Heyting algebra, we need
to show that they satisfy the Heyting algebra axioms. First, we need
to show that the meet and join are the greatest lower bounds and least
upper bounds respectively. To do this, we will just show that arbitrary
meets and joins exist, and then the nullary and binary meets and joins
will fall out as a special case.

\begin{lemma}{(Meets in the algebra of specifications)}
If $X \subseteq \upset{P}$, then $\bigwedge X$ defines a meet. 
\end{lemma}

\begin{proof}
We need to show that if for all $i \in I$, $S_i \in \upset{P}$, 
then $\bigwedge_{i \in I} S_i \in \upset{P}$. First, we will verify that 
the intersection of a family of upwards-closed subsets is itself an
upwards-closed subset. 

\begin{tabbedproof}
\oo Assume $\forall i \in I.\; S_i \in \upset{P}$ \\
\ooo We want to show $\bigwedge_{i \in I} S_i \in \upset{P}$ \\ 
\ooo So we want to show for all $x \in \bigwedge_{i \in I} S_i$ and for all $y \in P$, if $x \worldleq y$ then $y \in \bigwedge_{i \in I} S_i$ \\
\ooo Assume $x$, $x \in \bigwedge_{i \in I} S_i$, $y$, $y \in P$, $x \worldleq y$ \\
\oooo Since $\bigwedge_{i \in I} S_i = \bigcap_{i \in I} S_i$, we know 
      $\forall i \in I.\; x \in S_i$ \\
\oooo Assume $i \in I$ \\
\ooooo Since $x \in S_i$, $x \worldleq y$, and $S_i$ is upwards-closed, $y \in S_i$ \\
\oooo Therefore, $\forall i \in I$, $y \in S_i$ \\
\ooo Therefore for all $x \in \bigwedge_{i \in I} S_i$ and for all $y \in P$, if $x \worldleq y$ then $y \in \bigwedge_{i \in I} S_i$ \\
\ooo Which means $\bigwedge_{i \in I} S_i \in \upset{P}$ \\ 
\end{tabbedproof}

\noindent Next, we need to show the Heyting algebra axiom for meets. 
Stated formally,
this is $\forall S \in \upset{P}$, if $X \subseteq
\upset{P}$ and $(\forall S' \in X.\; S \leq S')$, then $S
\leq \bigwedge X$ and $\forall S' \in X, \bigwedge X \leq S'$.
\\

\begin{tabbedproof}
\oo Assume $S \in \upset{P}, X \subseteq \upset{P},$ and   
           $(\forall S' \in X.\; S \leq S')$ \\
\ooo First, we want to show $S \leq \bigwedge X$ \\
\oooo This is equivalent to showing $\forall p.\; p \in S \implies p \in \bigwedge X$ \\
\oooo Assume $p \in S$ \\
\ooooo We want to show $p \in \bigwedge X$, so we want to show $\forall S' \in X.\; p \in S'$. \\
\ooooo Assume $S' \in X$ \\
\oooooo From the hypothesis in 1, we know $S \leq S'$ \\
\oooooo This means $\forall p.\; p \in S \implies p \in S'$ \\
\oooooo Instantiate the quantifier with $p$ and use hypothesis 4 to conclude $p \in S'$ \\
\oooo Therefore, $\forall p.\; p \in S \implies p \in \bigwedge X$, so $S \leq \bigwedge X$ \\[1em]
\ooo Second, we want to show $\forall S' \in X.\; \bigwedge X \leq S'$ \\
\ooo Assume $S' \in X$ \\
\oooo We want to show $\bigwedge X \leq S'$, so we must show $\forall p.\; p \in \bigwedge X \implies p \in S'$ \\
\oooo Assume $p \in \bigwedge X$ \\
\ooooo Therefore, we know $\forall S' \in X.\; p \in S'$ \\
\ooooo Instantiate the quantifier with $S'$ to conclude $p \in S'$ \\
\oooo Therefore $\bigwedge X \leq S'$ \\
\ooo Therefore $\forall S' \in X.\; \bigwedge X \leq S'$ 
\end{tabbedproof}
\end{proof}



\begin{lemma}{(Joins in the algebra of specifications)}
If $X \subseteq \upset{P}$, then $\bigvee X$ defines an arbitrary join. 
\end{lemma}
\begin{proof}
First, we need to verify the join we defined actually gives us an upward closed set ---
that is, if $X \subseteq \upset{P}$, then $\bigvee{X} \in \upset{P}$

\vspace{0.5em}

\begin{tabbedproof}
\oo Assume  $X \subseteq \upset{P}$ \\
\ooo We want to show $\bigvee{X} \in \upset{P}$ \\
\ooo This means for all $x \in \bigvee{X}, y \in P,$ if $x \worldleq y$ then $y \in \bigvee{X}$\\
\ooo Assume $x \in \bigvee X$, $y \in P$, $x \worldleq y$ \\
\oooo Since $x \in \bigvee X$, we know $\exists S \in X.\; x \in S$ \\
\oooo Let $S$ be the witness of the existential, so $S \in X$ and $x \in S$ \\ 
\ooooo  Since $S$ is upward closed, $x \in S$, and $x \worldleq y$, we know $y \in S$ \\
\ooo Therefore we can conclude $\exists S \in X.\; y \in S$ \\
\ooo Therefore $y \in \bigvee X$ \\
\end{tabbedproof}

\noindent Now, we need to show the Heyting axioms for disjunction. Formally stated, it is $\forall S \in \upset{P}, X \subseteq
\upset{P}$, if $(\forall S' \in X.\; S' \leq S)$, then $\bigvee X \leq
S$ and $\forall S' \in X.\; S' \leq \bigvee X$.

\vspace{0.5em}

\begin{tabbedproof}
\oo Assume $S \in \upset{P}, X \subseteq \upset{P}$, and $\forall S' \in X.\; S' \leq S$ \\
\ooo First, we want to show $\bigvee X \leq S$ \\
\oooo This is the same as $\forall p, p \in \bigvee X \implies p \in S$ \\
\oooo Assume $p \in \bigvee X$ \\
\ooooo This means $\exists S' \in X.\; p \in S'$ \\
\ooooo Let $S'$ be the witness to the existential, so $S' \in X$ and $p \in S'$ \\
\oooooo Instantiating the quantifier in the hypothesis with $S'$, we get $S' \leq S$ \\
\oooooo This means $\forall p \in S', p \in S$ \\
\oooooo Instantiating the quantifier with $p$, we  get $p \in S$ \\
\oooo Therefore $\forall p, p \in \bigvee X \implies p \in S$ \\
\oooo This is equivalent to $\bigvee X \leq S$ \\[1em]

\ooo Second, we want to show $\forall S' \in X.\; S' \leq \bigvee X$ \\
\oooo Assume $S' \in X$ \\
\ooooo We want to show $S' \leq \bigvee X$ \\
\ooooo This means $\forall p \in S', p \in \bigvee X$ \\
\ooooo Assume $p \in S'$ \\
\oooooo We want to show $p \in \bigvee X$ \\
\oooooo This means we must show $\exists S' \in X.\; p \in S'$ \\
\oooooo Witness the existential with $S'$, so we can show $p \in S'$ by hypothesis \\
\oooo  Therefore $\forall S' \in X.\; S' \leq \bigvee X$ \\
\end{tabbedproof}
\end{proof}




\begin{lemma}{(Implication)}
If $S_1, S_2 \in \upset{P}$, then
$S_1 \implies S_2 \in \upset{P}$. 
\end{lemma}

\begin{proof}
First, we will check that the definition gives us an upward closed set.

\vspace{0.5em}

\begin{tabbedproof}
\oo Assume $x \in S_1 \implies S_2$, and that $y \worldgeq x$ \\
\ooo From this, we know $\forall r' \worldgeq x, $ if $r' \in S_1$ then $r' \in S_2$ \\
\ooo We want to show $\forall r' \worldgeq y, $ if $r' \in S_1$ then $r' \in S_2$ \\
\ooo Assume $r' \worldgeq y$ and $r' \in S_1$ \\
\oooo Since $r' \worldgeq y$ and $y \worldgeq x$, we know $r' \worldgeq x$ \\
\oooo From this  and $r' \in S_1$, we can use the hypothesis in line 2 to get $r' \in S_2$ \\
\ooo Therefore $\forall r' \worldgeq y, $ if $r' \in S_1$ then $r' \in S_2$ \\
\oo Therefore $y \in S_1 \implies S_2$
\end{tabbedproof}

\noindent Now that we know that $\implies$ has the correct codomain, we need to
verify that it satisfies the adjoint relationship between conjunction and 
implication: 
\begin{displaymath}
S_1 \land S_2 \subseteq R \iff S_1 \subseteq S_2 \implies R
\end{displaymath}

\noindent This is equivalent to showing that 

\begin{displaymath}
(\forall x.\; x \in S_1 \land S_2 \Rightarrow x \in R) \iff
(\forall x.\; x \in S_1 \Rightarrow x \in S_2 \implies R)
\end{displaymath}

\noindent First, let's show the $\Rightarrow$ direction.
\\

\begin{tabular}{ll}
Assume for all $x.\; x \in S_1 \land S_2 \Rightarrow x \in R$ &
(1)
\\

Assume $x \in S_1$ &
(2)
\\

Assume $r' \worldgeq x$ &
(3)
\\

Assume $r' \in S_2$ & 
(4)
\\

$r' \in S_1$ & 
Since $x \in S_1$ and $r' \worldgeq x$ \\

$r' \in S_1 \cap S_2$ & 
Since $r' \in S_1$ and $r' \in S_2$ \\

$r' \in R$ &
By assumption (1) \\

$r' \in S_2 \Rightarrow r' \in R$ &
Implication intro (4) \\

$\forall r' \worldgeq x.\; r' \in S_2 \Rightarrow r' \in R$ &
Universal intro (3) \\

$x \in \{ r \in P \;|\; \forall r' \worldgeq r.\; r' \in S_2 \Rightarrow r' \in R$ &
Comprehension intro \\

$x \in S_2 \implies R$ &
Definition of $\implies$ \\

$\forall x.\; x \in S_1. \Rightarrow x \in S_2 \implies R$ &
Universal intro (2) \\

$(\forall x.\; x \in S_1 \land S_2 \Rightarrow x \in R) \Rightarrow (\forall x.\; x \in S_1 \Rightarrow x \in S_2 \implies R)$ &
Implication intro (1) \\
\end{tabular}
\\

Next, let's show the $\Leftarrow$ direction. 
\\

\begin{tabular}{ll}
Assume $\forall x.\; x \in S_1 \Rightarrow x \in S_2 \implies R$ &
(1) Assumption \\

Assume $x \in S_1 \land S_2$ & 
(-) Assumption \\

$x \in S_1$ & 
(2) Since $x \in S_1 \land S_2$ \\

$x \in S_2$ & 
(3) Since $x \in S_1 \land S_2$ \\

$x \in S_2 \implies R$ & 
(-) By (2) and (1) \\

$x \in \{ r \in P \;|\; \forall r' \worldgeq r.\; \mbox{if } r' \in S_2 \mbox{ then } r' \in R \}$ &
(-) Definition of $\implies$ \\

$\forall r' \worldgeq x.\; \mbox{if } r' \in S_2 \mbox{ then } r' \in R$ &
(4) Comprehension instantiation  \\

$x \worldgeq x$ & 
(5) Reflexivity  \\

$\mbox{if } x \in S_2 \mbox{ then } x \in R$ & 
(-) Instantiation of (4) with (5) \\

$x \in R$ & 
(-) Implication elim via (3) \\

$\forall x.\; x \in S_1 \land S_2 \Rightarrow x \in R$ & 
(-) Universal/Implication intro (2) \\

$(\forall x.\; x \in S_1 \Rightarrow x \in S_2 \implies R) \Rightarrow (\forall x.\; x \in S_1 \land S_2 \Rightarrow x \in R)$ & 
(-) Implication intro (1) \\
\end{tabular}
\end{proof}

These lemmas establish that $\upset{P}$ forms a complete Heyting algebra. 

\subsection{Defining Kripke Hoare Triples}

In this section, we will define \emph{Kripke Hoare triples}, which
will be the basic elements we will use to define our specification
logic. As always, the definition will come in a piece-wise
fashion. Having already defined ``basic Hoare triples'', we can then
use these to define our true Kripke Hoare triples.

First, note that our separation logic assertions form a BI-algebra,
and hence form a world preorder. This then gives rise to a Heyting
algebra $\upset{\powerset{H}}$, which we will take to be our domain of
specifications.

Given an assertion $p \in \powerset{H}$, an element $c$ of the domain
of $A$-commands $(A \to K) \to K$, and an assertion $q \in U(A) \to
\powerset{H}$, we define the meaning of a Kripke triple as:

\begin{displaymath}
  \spec{p}{c}{a:A}{q(a)} \triangleq
    \comprehend{ r \in \powerset{H} }
               {\forall s \succeq r.\; \basicspec{p * s}{c}{a:A}{q(a) * s}}
\end{displaymath}

The intuition behind this definition is that the meaning of a
specification is the set of assertions which can be framed onto it,
and hence a true specification allows anything to be framed onto it,
since the topmost element of the specification lattice is the set of 
all assertions. We confirm that Kripke triples are indeed elements of
the specification lattice below. 

\begin{lemma}{(Kripke Triples are Specifications)}
  For suitable $p,c,A$, and $q$, we have that 
\begin{displaymath}
\spec{p}{c}{a:A}{q(a)} \in \upset{\powerset{H}}
\end{displaymath}
\end{lemma}

\begin{proof}
\begin{tabbedproof}
\oo We want to show $\spec{p}{c}{a:A}{q(a)} \in \upset{\powerset{H}}$ \\
\oo This is equivalent to $\forall r,s$ if $r \in \spec{p}{c}{a:A}{q(a)}$ and $s \succeq r$,
then $s \in \spec{p}{c}{a:A}{q}$ \\
\oo Assume $r,s, r \in \spec{p}{c}{a:A}{q(a)}$, and $s \succeq r$ \\
\ooo $r \in \spec{p}{c}{a:A}{q(a)}$ is equivalent to 
     $\forall s \succeq r.\; \basicspec{p * s}{c}{a:A}{q(a) * s}$ \\
\ooo We want to show $s \in \spec{p}{c}{a:A}{q}$ \\
\ooo This is equivalent to showing 
     $\forall t \succeq s.\; \basicspec{p * t}{c}{a:A}{q(a) * t}$ \\
\ooo Assume $t$, $t \succeq s$ \\
\oooo By transitivity with $t \succeq s$ and $s \succeq r$, we know $t \succeq r$ \\
\oooo Instantiating quantifier in line 4 with $t$, $\basicspec{p * t}{c}{a:A}{q(a) * t}$ \\
\ooo Therefore $\forall t \succeq s.\; \basicspec{p * t}{c}{a:A}{q(a) * t}$ \\
\ooo Therefore $s \in \spec{p}{c}{a:A}{q}$ \\
\oo Therefore $\forall r,s$ if $r \in \spec{p}{c}{a:A}{q(a)}$ and $s \succeq r$,
    then $s \in \spec{p}{c}{a:A}{q}$ \\
\oo We have shown $\spec{p}{c}{a:A}{q(a)} \in \upset{\powerset{H}}$ \\ 
\end{tabbedproof}
\end{proof}

\subsubsection{Fixed Point Induction}

The reason we have gone to the trouble of using continuous
approximations to the postcondition is to create an admissibility
property which will allow us to justify a fixed point induction rule.
We will now cash in that work by giving a proof that the fixed point
induction rule is sound. 

\begin{lemma}{(Bottom Satisfies All Specifications)}
We have that $\spec{p}{\bot}{a:A}{q(a)} = \powerset{H}$. 
\end{lemma}
\begin{proof}
\begin{tabbedproof}
\oo We want to show $\spec{p}{\bot}{a:A}{q(a)} = \powerset{H}$ \\
\oo It suffices to show $\forall r \in \powerset{H}, r \in \spec{p}{\bot}{a:A}{q(a)}$ \\
\oo Assume $r \in \powerset{H}$ \\
\ooo We want to show $r \in \spec{p}{\bot}{a:A}{q(a)}$, which is equivalent to 
     $\forall s \succeq r.\; \basicspec{p*s}{\bot}{a:A}{q(a) * s}$ \\
\ooo Assume $s \succeq r$ \\
\oooo We want to show $\basicspec{p*s}{\bot}{a:A}{q(a) * s}$ \\
\oooo This is equivalent to $\forall h \in p. \bot\;Best(q)\;h = \bot$ \\
\oooo Assume $h \in p$ \\
\ooooo  By definition of least element, $\bot\;Best(q)\;h = \bot$ \\
\oooo Therefore $\forall h \in p. \bot\;Best(q)\;h = \bot$ \\
\oooo Therefore $\basicspec{p*s}{\bot}{a:A}{q(a) * s}$ \\
\ooo Therefore $\forall s \succeq r.\; \basicspec{p*s}{\bot}{a:A}{q(a) * s}$ \\
\ooo Therefore $r \in \spec{p}{\bot}{a:A}{q(a)}$ \\
\oo Therefore $\forall r \in \powerset{H}, r \in \spec{p}{\bot}{a:A}{q(a)}$ \\
\oo Therefore $\spec{p}{\bot}{a:A}{q(a)} = \powerset{H}$ \\
\end{tabbedproof}
\end{proof}

\begin{lemma}{(Admissibility of Triple Subsets)}
Define $\spec{p}{-}{a:A}{q(a)}$ to be 

\begin{displaymath}
\spec{p}{-}{a:A}{q(a)} \triangleq
         \comprehend{c \in (A \to K) \to K}
                   { \spec{p}{c}{a:A}{q(a)} = \powerset{H} }
\end{displaymath}

Then, $\spec{p}{-}{a:A}{q(a)}$ forms an admissible subset of $(A \to K) \to K$. 
That is, given a chain $c_i \in \spec{p}{-}{a:A}{q(a)}$, we know that 
$\spec{p}{\sqcup_i c_i}{a:A}{q(a)}$. 
\end{lemma}

\begin{proof}
\begin{tabbedproof}
\oo Suppose we have a chain $c_i \in \spec{p}{-}{a:A}{q(a)}$. \\
\ooo We want to show that $\sqcup_i c_i \in \spec{p}{-}{a:A}{q(a)}$ \\
\ooo This is equivalent to $\spec{p}{\sqcup c_i}{a:A}{q(a)} = \powerset{H}$ \\
\ooo This is equivalent to 
     $\forall r \in \powerset{H}, s \succeq r.\; 
         \basicspec{p * s}{\sqcup c_i}{a:A}{q(a) * s}$ \\
\ooo Assume $r \in \powerset{H}, s \succeq r$ \\
\oooo We want to show $\basicspec{p * s}{\sqcup c_i}{a:A}{q(a) * s}$ \\
\oooo This is equivalent to $\forall h \in p * s.\; (\sqcup c_i)\; Best(\semfun{a}{q(a)*s})\;h = \bot$ \\
\oooo Assume $h \in p * s$ \\ 
\ooooo By continuity, we know $(\sqcup c_i)\; Best(\semfun{a}{q(a)*s})\;h = 
                               \bigsqcup (c_i\;Best(\semfun{a}{q(a)*s})\;h)$ \\
\ooooo Suppose $c$ is an element of the chain of $c_i$ \\
\oooooo Then we know $c \in \spec{p}{-}{a:A}{q}$ \\
\oooooo This is equivalent to $\spec{p}{c}{a:A}{q} = \powerset{H}$ \\
\oooooo This is equivalent to $\forall r, s \succeq r.\; \basicspec{p*s}{c}{a:A}{q(a)*s}$ \\
\oooooo This is equivalent to $\forall r, s \succeq r, h \in p*s, c\;Best(\semfun{a}{q(a)*s})\;h = \bot$ \\
\oooooo Instantiating quantifiers with $r$, $s$, and $h$, we get $c\;Best(\semfun{a}{q(a)*s})\;h = \bot$\\
\ooooo Therefore $\forall c \in \comprehend{c_i}{i \in \N}$, $c\;Best(\semfun{a}{q(a)*s})\;h = \bot$ \\
\ooooo Therefore $\bigsqcup (c_i\;Best(\semfun{a}{q(a)*s})\;h) = \bot$ \\
\ooooo Therefore $(\sqcup c_i)\;Best(\semfun{a}{q(a)*s})\;h = \bot$ \\
\oooo Therefore $\forall h \in p * s.\; (\sqcup c_i)\; Best(\semfun{a}{q(a)*s})\;h = \bot$ \\
\oooo Therefore $\basicspec{p * s}{\sqcup c_i}{a:A}{q(a) * s}$ \\
\ooo Therefore $\forall r \in \powerset{H}, s \succeq r.\; 
                   \basicspec{p * s}{\sqcup c_i}{a:A}{q(a) * s}$ \\
\ooo Therefore $\spec{p}{\sqcup c_i}{a:A}{q(a)} = \powerset{H}$ \\
\ooo Therefore $\sqcup_i c_i \in \spec{p}{\sqcup_i c_i}{a:A}{q(a)}$ \\
\end{tabbedproof}
\end{proof}

\begin{lemma}{(Fixed Point Induction)}
If we know that for all $x$, $\spec{p}{x}{a:A}{q(a)} = \powerset{H}$ implies $\spec{p}{f(x)}{a:A}{q(a)}) = \powerset{H}$, then we know that $\spec{p}{\mathit{fix}(f)}{a:A}{q(a)} = \powerset{H}$
\end{lemma}

\begin{proof}
First, observe that $f^n(\bot)$ forms a chain -- that is, for all $i$, $f^i(\bot) \sqsubseteq f^{i+1}(\bot)$.
\begin{tabbedproof}
\oo We want to show $\forall i$, $f^i(\bot) \sqsubseteq f^{i+1}(\bot)$ \\
\oo We proceed by induction on $i$ \\
\ooo Case $i = 0$: \\
\oooo We want to show $\bot \sqsubseteq f(\bot)$ \\
\oooo This follows immediately from the fact that $\bot$ is the least element of a domain. \\
\ooo Case $i = j + 1$ \\
\oooo We want to show $f^j(\bot) \sqsubseteq f^{j+1}(\bot) \implies f^i(\bot) \sqsubseteq f^{i+1}(\bot)$ \\
\oooo Assume $f^j(\bot) \sqsubseteq f^{j+1}(\bot)$ \\
\ooooo By monotonicity of $f$, $f(f^j(\bot)) \sqsubseteq f(f^{j+1}(\bot))$ \\
\ooooo Therefore $f^i(\bot) \sqsubseteq f^{i+1}(\bot)$ \\
\oo Therefore $\forall i$, $f^i(\bot) \sqsubseteq f^{i+1}(\bot)$ \\
\end{tabbedproof}

\noindent Now, observe that for every $n$, $f^n(\bot) \in \spec{p}{-}{a:A}{q}$. 

\begin{tabbedproof}
\oo Assume for all $x$, $\spec{p}{x}{a:A}{q(a)} = \powerset{H}$ implies $\spec{p}{f(x)}{a:A}{q(a)}) = \powerset{H}$ \\
\ooo We want to show $\forall n, f^n(\bot) \in \spec{p}{-}{a:A}{q(a)}$ \\ 
\ooo We proceed by induction on $n$: \\
\oooo Case $n = 0$ \\
\ooooo We want to show $\bot \in \spec{p}{-}{a:A}{q(a)}$ \\
\ooooo This follows from the fact that bottom satisfies all specifications. \\
\oooo Case $n = m + 1$ \\
\ooooo We want to show $f^m(\bot) \in \spec{p}{-}{a:A}{q} \implies
                        f^{m+1}(\bot) \in \spec{p}{-}{a:A}{q}$ \\
\ooooo Assume $f^m(\bot) \in \spec{p}{-}{a:A}{q(a)}$ \\
\oooooo This means $\spec{p}{f^m(\bot)}{a:A}{q(a)} = \powerset{H}$ \\
\oooooo Instantiate line 1 with $f^m(\bot)$, to conclude
          $\spec{p}{f(f^m(\bot))}{a:A}{q(a)}) = \powerset{H}$ \\
\oooooo This means $\spec{p}{f^{m+1}(\bot)}{a:A}{q(a)} = \powerset{H}$ \\
\oooooo This means $f^{m+1}(\bot) \in \spec{p}{-}{a:A}{q(a)}$ \\
\ooo Therefore $\forall n, f^n(\bot) \in \spec{p}{-}{a:A}{q(a)}$ \\ 
\end{tabbedproof}
Finally, by the admissibility of $\spec{p}{-}{a:A}{q(a)}$, we know that
$\sqcup f^n(\bot) \in \spec{p}{-}{a:A}{q(a)}$. Since $\sqcup f^n(\bot) = fix(f)$, we 
know that $\spec{p}{\mathit{fix}(f)}{a:A}{q(a)} = \powerset{H}$. 
\end{proof}

\subsection{The Framing Operator}

One nice feature of the Kripke-style interpretation of specifications
is that it naturally validates higher-order frame rules.  We define
the operation $S \otimes p$, where $S \in \upset{W(\powerset{H})}$ and
$p \in W(\powerset{H})$:
\begin{displaymath}
S \otimes p = \comprehend{ r \in W(\powerset{H}) }{ r * p \in S }
\end{displaymath}
%
The way to understand this is that $S \otimes p$ restricts $S$ to only those
elements which can be extended by $p$. That is, if we think of $S$ as the
set of propositions that can be framed on to a basic triple, then we want
$S \otimes p$ to be only the frames in $S$, such that if we added $p$ to
them we continue to have a frame in $S$. So this operation gives a semantic
interpretation of the frame rule. 

So we need to show that first, $S \otimes p$ actually is an element of
our Heyting algebra of specification truth values, and second, we want
the frame rule to be sound -- we want $S$ to always imply $S \otimes
p$.

\begin{lemma}{(Framing is a Lattice Operation on Specifications)}
For all $S$ and $p$, we have that $S \otimes p$ is in $\upset{W(\powerset{H}})$,
and that $S \subseteq S \otimes p $.
\end{lemma}
\begin{proof}
To show that $S \otimes p \in \upset{W(\powerset{H})}$, we need to show that for all 
$x,y$, if $x \in S \otimes p$ and $y \succeq x$, then $y \in S \otimes p$. 

\begin{tabbedproof}
\oo We want to show for all $x,y$, if $x \in S \otimes p$ and $y \succeq x$, then $y \in S \otimes p$ \\
\oo Assume $x, y, x \in S \otimes p, y \succeq x$ \\
\ooo From $x \in S \otimes p$, we know $x * p \in S$ \\
\ooo From $y \succeq x$, we know $\exists r.\; y = x * r$ \\
\ooo Let $r$ be the witness so that $y = x * r$ \\
\oooo Since $S$ is upward closed, $x * p * r \in S$ \\
\oooo Since $x * p * r = (x * r) *p$, we know  $y * p \in S$ \\
\oooo Therefore $y \in S \otimes p$ \\
\end{tabbedproof}

\noindent To show $S \subseteq S \otimes p$, we need to show that if $x \in S$, then $x \in S \otimes p$. 
\begin{tabbedproof}
\oo Assume $x \in S$ \\
\ooo Since $\preceq$ is the extension ordering, $x \preceq x * p$ \\   
\ooo Since $S$ is upward closed, $x * p \in S$\\
\ooo Therefore $x \in S \otimes p$ 
\end{tabbedproof}
\end{proof}

\subsubsection{Framing Commutes With Logical Operators}

\begin{lemma}{(Framing onto Kripke Triples)}
We have that 
\begin{displaymath}
\spec{p}{c}{a:A}{q(a)} \otimes r = \spec{p * r}{c}{a:A}{q(a) * r}  
\end{displaymath}
\end{lemma}

\begin{proof}
\begin{tabbedproof}
\oo We want to show $\spec{p}{c}{a:A}{q(a)} \otimes r = \spec{p * r}{c}{a:A}{q(a) * r}$. \\
\oo This means $\forall s \in W(\powerset{H}).\; s \in (\spec{p}{c}{a:A}{q(a)} \otimes r)$ if and
only if $s \in \spec{p * r}{c}{a:A}{q(a) * r}$. \\
\ooo Assume $s \in W(\powerset{H})$ \\
\oooo $\To$ direction: \\
\ooooo Assume $s \in (\spec{p}{c}{a:A}{q(a)} \otimes r)$ \\
\oooooo This means $s * r \in \spec{p}{c}{a:A}{q(a)}$ \\
\oooooo This means $\forall t \succeq s * r.\; \basicspec{p * t}{c}{a:A}{q * t}$ \\
\oooooo We want to show $s \in \spec{p * r}{c}{a:A}{q(a) * r}$ \\
\oooooo So we want $\forall t' \succeq s.\; \basicspec{p * r * t'}{c}{a:A}{q(a) * r * t'}$\\
\oooooo Assume $t' \succeq s$ \\
\ooooooo Clearly, $t' * r \succeq s * r$ \\
\ooooooo Instantiate quantifier in 7 with $t' * r$ to conclude
         $\basicspec{p * t' * r}{c}{a:A}{q * t' * r}$ \\
\ooooooo Rearranging, we get $\basicspec{p * r * t'}{c}{a:A}{q * r * t'}$ \\
\oooooo Therefore $\forall t' \succeq s.\; \basicspec{p * r * t'}{c}{a:A}{q(a) * r * t'}$\\
\oooooo Therefore $s \in \spec{p * r}{c}{a:A}{q(a) * r}$ \\[0.5em]

\oooo $\Leftarrow$ direction: \\
\ooooo Assume $s \in \spec{p * r}{c}{a:A}{q(a) * r}$. \\
\oooooo This means $\forall t \succeq s.\; \basicspec{p * r * t}{c}{a:A}{q(a) * r * t}$ \\
\oooooo We want to show $s \in (\spec{p}{c}{a:A}{q(a)} \otimes r)$ \\
\oooooo So we want $s * r \in \spec{p}{c}{a:A}{q(a)}$ \\
\oooooo So we want $\forall t \succeq s * r.\; \basicspec{p * t}{c}{a:A}{q * t}$ \\
\oooooo Assume $t \succeq s * r$ \\
\ooooooo Since $t \succeq s * r$, we know $\exists u.\; t = s * r * u$ \\
\ooooooo Let $u$ be the witness such that $t = s * r * u$ \\
\ooooooo Now, note that $s * u \succeq s$ \\
\ooooooo Instantiate quantifier in 18 with $s * u$, so 
         $\basicspec{p * r * s * u}{c}{a:A}{q(a) * r * s * u}$ \\
\ooooooo Rearranging, $\basicspec{p * s * r * u}{c}{a:A}{q(a) * s * r * u}$ \\
\ooooooo By equality in 24, $\basicspec{p * t}{c}{a:A}{q * t}$ \\
\oooooo Therefore $\forall t \succeq s * r.\; \basicspec{p * t}{c}{a:A}{q * t}$ \\
\oooooo Therefore $s * r \in \spec{p}{c}{a:A}{q(a)}$ \\
\oooooo Therefore $s \in (\spec{p}{c}{a:A}{q(a)} \otimes r)$ 
\end{tabbedproof}
\end{proof}

\begin{lemma}{(Framing Commutes with Meets)}
We have that 
\begin{displaymath}
\left(\bigwedge_{i \in I} S_i\right) \otimes p = \bigwedge_{i \in I} (S_i \otimes p)
\end{displaymath}
\end{lemma}

\begin{proof}
To show $\left(\bigwedge_{i \in I} S_i\right) \otimes p = \bigwedge_{i \in I} (S_i \otimes p)$,
we need to show $\forall r.\; r \in \left(\bigwedge_{i \in I} S_i\right) \otimes p$ if
and only if $r \in \bigwedge_{i \in I} (S_i \otimes p)$. 

\begin{tabbedproof}
\oo Assume $r \in W(\powerset{H})$ \\[0.5em]

\ooo $\To$ direction: \\
\oooo Assume $r \in \left(\bigwedge_{i \in I} S_i\right) \otimes p$ \\
\ooooo From assumption, we know $r * p \in \bigwedge_{i \in I} S_i$ \\
\ooooo This means that $\forall i \in I.\; r * p \in S_i$ \\
\ooooo We want to show $r \in \bigwedge_{i \in I} (S_i \otimes p)$ \\
\ooooo So we want $\forall i \in I.\; r \in (S_i \otimes p)$ \\
\ooooo So we want $\forall i \in I.\; r * p \in S_i$ \\
\ooooo Assume $i \in I$ \\
\oooooo We want to show $r * p \in S_i$ \\
\oooooo Instantiating line 5 with $i$, we get $r * p \in S_i$ \\[0.5em]

\ooo $\Leftarrow$ direction:  \\
\oooo Assume $r \in \bigwedge_{i \in I} (S_i \otimes p)$  \\
\ooooo From this, we know that $\forall i \in I.\; r \in (S_i \otimes p)$ \\
\ooooo We want to show $r \in \left(\bigwedge_{i \in I} S_i\right) \otimes p$ \\
\ooooo So we want to show $r * p \in \bigwedge_{i \in I} S_i$ \\
\ooooo So we want to show $\forall i \in I.\; r * p \in S_i$ \\
\ooooo Assume $i \in I$ \\
\oooooo Instantiating line 14 with $i$, we get $r \in (S_i \otimes p)$ \\
\oooooo This means $r * p \in S_i$ \\
\ooooo Therefore $\forall i \in I.\; r * p \in S_i$ \\
\ooooo Therefore $r * p \in \bigwedge_{i \in I} S_i$ \\
\ooooo Therefore $r \in \left(\bigwedge_{i \in I} S_i\right) \otimes p$ 
\end{tabbedproof}
\end{proof}

\begin{lemma}{(Framing Commutes with Joins)}
We have that 
\begin{displaymath}
\left(\bigvee_{i \in I} S_i\right) \otimes p = \bigvee_{i \in I} (S_i \otimes p)
\end{displaymath}
\end{lemma}

\begin{proof}
Showing this is equivalent to showing $\forall r.\; r \in
\left(\bigvee_{i \in I} S_i\right) \otimes p$ if and only if $r \in
\bigvee_{i \in I} (S_i \otimes p)$.

\begin{tabbedproof}
\oo Assume $r$ \\[0.5em]
\ooo  $\To$ direction: \\
\oooo Assume $r \in \left(\bigvee_{i \in I} S_i\right) \otimes p$ \\
\oooo This means $r * p \in \bigvee_{i \in I} S_i$ \\
\oooo This means $\exists i \in I.\; r * p \in S_i$ \\
\oooo We want to show $r \in \bigvee_{i \in I} (S_i \otimes p)$ \\
\oooo So we want to show $\exists i \in I.\; r \in (S_i \otimes p)$ \\
\oooo Let $i$ be the witness in 5, such that $r * p \in S_i$ \\
\ooooo From this, we see $r \in (S_i \otimes p)$ \\
\ooooo From this and $i$, we conclude $\exists i \in I.\; r \in (S \otimes p)$ \\
\oooo Therefore $r \in \bigvee_{i \in I} (S_i \otimes p)$ \\[0.5em]

\ooo $\From$ direction: \\
\oooo Assume $r \in \bigvee_{i \in I} (S_i \otimes p)$. \\
\ooooo From this, $\exists i \in I.\; r \in (S_i \otimes p)$ \\
\ooooo We want to show $r \in \left(\bigvee_{i \in I} S_i\right) \otimes p$ \\
\ooooo So we want $r * p \in \bigvee_{i \in I} S_i$ \\
\ooooo So we want $\exists i \in I.\; r * p \in S_i$ \\
\ooooo Let $i \in I$ be the witness in 14, so that $r \in (S_i \otimes p)$ \\
\oooooo From this, $r * p \in S_i$ \\
\oooooo With this and $i \in I$, we know $\exists i \in I.\; r * p \in S_i$ \\
\ooooo Therefore $r * p \in \bigvee_{i \in I} S_i$ \\
\ooooo Therefore $r \in \left(\bigvee_{i \in I} S_i\right) \otimes p$ \\
\end{tabbedproof}
\end{proof}

\begin{lemma}{(Framing Commutes Through Implication)}
We have that
\begin{displaymath}
  (S_1 \implies S_2) \otimes p = (S_1 \otimes p) \implies (S_2 \otimes p) 
\end{displaymath}
\end{lemma}

\begin{proof}
This is equivalent to showing that $\forall r, r \in [(S_1 \implies S_2) \otimes p]$ if and
only if $r \in [(S_1 \otimes p) \implies (S_2 \otimes p)]$. 

\begin{tabbedproof}
\oo Assume $r$ \\
\ooo $\To$ direction:\\
\oooo Assume $r \in [(S_1 \implies S_2) \otimes p]$ \\
\ooooo This means $r * p \in (S_1 \implies S_2)$ \\
\ooooo This means $\forall s \succeq r * p,$ if $s \in S_1$ then $s \in S_2$ \\
\ooooo We want to show $r \in [(S_1 \otimes p) \implies (S_2 \otimes p)]$ \\
\ooooo So we want $\forall s \succeq r,$ if  $s \in S_1 \otimes p$ then $s \in S_2 \otimes p$ \\
\ooooo Assume $s \succeq r$ and $s \in S_1 \otimes p$ \\
\oooooo From this $s * p \in S_1$ \\ 
\oooooo Since $s * p \succeq s$ and $s \succeq r$, we have $s * p \succeq r$ \\
\oooooo Instantiating line 5 with $s * p$, we have if $s * p \in S_1$ then $s * p \in S_2$ \\
\oooooo Using this and line 9, we have $s * p \in S_2$ \\
\oooooo From this, we have $s \in S_2 \otimes p$ \\
\ooooo Therefore $\forall s \succeq r,$ if  $s \in S_1 \otimes p$ then $s \in S_2 \otimes p$ \\
\ooooo Therefore $r \in [(S_1 \otimes p) \implies (S_2 \otimes p)]$ \\

\ooo $\From$ direction: \\
\oooo Assume $r \in [(S_1 \otimes p) \implies (S_2 \otimes p)]$ \\
\ooooo From this, $\forall s \succeq r,$ if $s \in (S_1 \otimes p)$, then $s \in (S_2 \otimes p)$ \\
\ooooo We want to show $r \in [(S_1 \implies S_2) \otimes p]$ \\
\ooooo So we want $r * p \in (S_1 \implies S_2)$ \\
\ooooo So we want $\forall s \succeq r * p$, if $s \in S_1$ then $s \in S_2$ \\
\ooooo Assume $s \succeq r * p$ and $s \in S_1$ \\
\oooooo From this, $\exists t.\; s = t * r * p$ \\
\oooooo Let $t$ be the witness such that $s = t * r * p$ \\ 
\ooooooo Note $t * r \succeq r$ \\
\ooooooo Instantiating 18 with $t * r$, we get if $t * r \in (S_1 \otimes p)$, then $t * r \in (S_2 \otimes p)$ \\
\ooooooo From this, we have if $t * r * p \in S_1$ then $t * r * p \in S_2$ \\
\ooooooo So we have if $s \in S_1$, then $s \in S_2$ \\
\ooooooo From this and 22, we have $s \in S_2$ \\
\ooooo Therefore $\forall s \succeq r * p$, if $s \in S_1$ then $s \in S_2$ \\
\ooooo Therefore $r * p \in (S_1 \implies S_2)$ \\
\ooooo Therefore $r \in [(S_1 \implies S_2) \otimes p]$ 
\end{tabbedproof}
\end{proof}

\section{Syntax of Assertions and Specifications}

In this section, we will give the syntax of specifications and
assertions, and then we will give their interpretations. The syntactic
categories are given in Figure~\ref{logic-syntax}. The sorts of our
logic are ranged over by $\omega$, and include the kinds $\kappa$, the
polymorphic types $A$, and the propositional sorts $\upsilon$.  The
propositional sorts $\omega$ include $\assert$, the sort $\upsilon \To
\omega$, which are the sort of propositional functions, and the sort
$\forallsort{\alpha}{\kappa}{\upsilon}$, which are
type-constructor-indexed families.
 
Note that we syntactically identify a family of propositional sorts
$\upsilon$. These sorts all end in $\assert$, and by distinguishing
them from kinds $\kappa$ and types $A$, we forbid the formation of
sorts like $\assert \To A$. This will ensure that program terms will
never depend on purely logical facts, though the converse (logical
terms depending on program terms) is allowed. This restriction is a
slight variation of the usual convention in higher-order logic, where
sorts must bottom out in the assertion type.

However, general sorts $\omega$ include both types and kinds. This
lets us define the assertions we will need for asserting facts about
polymorphic programs. For example, the sort of the $\mathsf{list}$
predicate for polymorphic lists can be given as $\mathsf{listprop} :
\forallsort{\alpha}{\star}{\listtype{\alpha} \To \seqsort{\alpha} \To
  \assert}$.

The terms (for which we will use $p$ $q$ as metavariables) which are
categorized by our sorts are also given in Figure~\ref{logic-syntax}.
They include lambda-abstraction and application for the two function
space sorts $\omega \To \upsilon$ and
$\forallsort{\alpha}{\kappa}{\upsilon}$, terms $e$ for the sorts $A$,
type expressions $\tau$ for the sorts $\kappa$.

Finally, we also have the assertions of separation logic for the sort
$\assert$.  These include the usual propositional logical connectives
--- $\top, p \land q, p \implies q, \bot, p \vee q$ -- as well as the
spatial connectives $\emp, p * q, p \wand q$, and $e \pointsto_A
e'$. Note that the points-to proposition is typed; it indicates that
$e$ is a reference of type $\reftype{A}$ with contents $e'$ of type
$A$.

The quantifiers $\forall u:\omega.\; p$ and $\exists u:\omega.\; p$
are higher-order quantifiers. They can range over all sorts, including
the sort of assertions $\assert$, and so we have the full power of
higher-order separation logic available.  One way in which we will use
this expressive power is by taking advantage of the definability of
many mathematical types (such as numbers, sequences, trees, finite
sets, subsets, etc.) in higher-order logic, to augment our sorts with
these types on an as-needed basis.

Finally, we have the \emph{specification embedding assertion}
$\validprop{S}$.  This is an \emph{assertion} that the specification
$S$ is true, and is useful for writing assertions that include facts
about the behavior of code.

The specifications $S$ begin with the basic Hoare triple
$\spec{p}{c}{a:A}{q}$, which says that the computation $c$, when run
from a pre-state in $p$, will end in a post-state in $q$, with its
return value named by $a$. Similarly, we have the monadic Hoare triple
form $\mspec{p}{e}{a:A}{q}$ which says that the suspended monadic
computation $e$ (of type $\monad{A}$), will take a pre-state $p$ to a
post-state $q$ if it were to be run. The specification $\setof{p}$ is
the assertion-embedding specification, which says that $p$ is a truth
of separation logic.

This does mean that assertions and specifications are mutually
recursive, which means that we will have to give the semantics of
these two syntaxes simultaneously. This is one of the reasons we spent
the first half of this chapter developing the semantics with no
reference to the intended syntax at all --- I wanted to ensure the
semantic domains were well-defined before giving the
mutually-recursive semantics of the program logic.

We also can form conjunctions $S \specand S'$, disjunctions $S \specor S'$
and implications $S \specimp S'$ over specifications, as well as universal
$\forall u:\omega.\;S$ and existential $\exists u:\omega.\;S$ quantification
over specifications, with the legitimate domains of quantifications being
the same sorts as for the assertion language. 

\begin{figure}
\begin{displaymath}
\begin{array}{llcl}
\mbox{Propositional Sorts} & 
\upsilon & ::= & \assert \bnfalt \omega \To \upsilon \bnfalt \forallsort{\alpha}{\kappa}{\upsilon}
\\[1em]
\mbox{Sorts} & \omega & ::= & \upsilon \bnfalt \kappa \bnfalt A 
\\[1em]

\mbox{Terms} & 
p,q & ::= & u \bnfalt \pfun{u}{\omega}{p} \bnfalt \pfunall{\alpha}{\kappa}{p} \bnfalt p\;q \bnfalt p\;[\tau] \bnfalt \tau \bnfalt e \\
&   &  |  & \top \bnfalt p \land q \bnfalt p \implies q \bnfalt \bot \bnfalt p \vee q \\
&   &  |  & \emp \bnfalt p * q \bnfalt p \wand q \bnfalt p \pointsto_{A} q \\
&   &  |  & \forall u:\omega.\; p \bnfalt \exists u:\omega.\; p \bnfalt p =_\omega q \bnfalt
            \validprop{S} \\[1em]

\mbox{Specifications} & 
S & ::= & \spec{p}{c}{a:A}{q} \bnfalt \mspec{p}{e}{a:A}{q} \bnfalt \setof{P} \\
& &  |  & S \specand S' \bnfalt S \specimp S' \bnfalt S \specor S' \\
& &  |  & \forall u:\omega.\; S \bnfalt \exists u:\omega.\; S \\[1em]

\mbox{Propositional Contexts} & 
\Delta & ::= & \cdot \bnfalt \Delta, u:\upsilon \\[1em]
\end{array}
\end{displaymath}
\caption{Syntax of Assertions and Specifications}
\label{logic-syntax}  
\end{figure}



A propositional context $\Delta$ is a sequence of sorted variables of
the form $u:\omega$. However, due to the fact that the sorts contain
types, we need a judgment to establish whether a sort is well-formed
with respect to a context of kind variables, since types can contain
type variables. 

In Figure~\ref{logic-sort-ok}, we give the judgment
$\judgeSort{\omega}$ used to decide whether or not a given sort is
well-formed or not. The judgment $\judgeACtx{\Delta}$, also given in
Figure~\ref{logic-sort-ok}, then uses the well-sorting judgment to
establish whether a particular context is well-formed or not. 

Finally, we need an equality judgment for sorts, since we have an
equality theory for types. The judgment
$\judgeSortEq{\omega}{\omega'}$, defined in
Figure~\ref{logic-sort-ok}, judges whether two sorts are equal, by
means of an almost-congruence. That is, the rules of this judgment
are all congruence rules, except for the single case
\textsc{SortEqType}, which inherits the equality judgment for
polytypes defined in the previous chapter. 

Now that we have defined what the sorts are, we define what it means
for a term to be well-sorted in context with the judgment
$\judgeA{p}{\omega}$, defined in Figure~\ref{logic-prop-ok}.

\begin{figure}
\begin{mathpar}
% \boxed{\judgeACtx{\Delta}} 
% \\
% \inferrule*[right=CtxNil]
%           { }
%           {\judgeACtx{\cdot}}
% \and
% \inferrule*[right=CtxCons]
%           {\judgeACtx{\Delta} \\
%            \judgeSort{\omega}}
%           {\judgeACtx{\Delta, u:\omega}}
% \\
\boxed{\judgeSort{\omega}}
\\
\inferrule*[right=SortKind]
          { }
          {\judgeSort{\kappa}}
% \and
% \inferrule*[right=SortPolyKind]
%           {\judgeACtx{\Delta}}
%           {\judgeSort{\bigstar}}
\and
\inferrule*[right=SortA]
          {\judgeWK{A}{\bigstar}}
          {\judgeSort{A}}
\and
\inferrule*[right=SortProp]
          { }
          {\judgeSort{\assert}}
\and
\inferrule*[right=SortImp]
          {\judgeSort{\omega} \\ \judgeSort{\upsilon}}
          {\judgeSort{\omega \To \upsilon}}
\and
\and
\inferrule*[right=SortImp]
          {\judgeSort[\Theta, \alpha:\kappa]{\upsilon}}
          {\judgeSort{\forallsort{\alpha}{\kappa}{\upsilon}}}

\\
\boxed{\judgeSortEq{\omega}{\omega'}}
\\
\inferrule*[right=SortEqProp]
           { } 
           {\judgeSortEq{\assert}{\assert}}
\and
\inferrule*[right=SortEqKind]
          { }
          {\judgeSortEq{\kappa}{\kappa}}
\and
% \inferrule*[right=SortEqPolyKind]
%           { }
%           {\judgeSortEq{\bigstar}{\bigstar}}
% \and
\inferrule*[right=SortEqImp]
          {\judgeSortEq{\omega}{\omega'} \\
           \judgeSortEq{\upsilon}{\upsilon'} }
          {\judgeSortEq{\omega \To \upsilon}{\omega' \To \upsilon'}}
\and
\inferrule*[right=SortEqType]
          {\judgeKeq{A}{B}{\bigstar}}
          {\judgeSortEq{A}{B}}
\and
\inferrule*[right=SortEqAll]
          {\judgeSortEq[\Theta,\alpha:\kappa]{\upsilon}{\upsilon'}}
          {\judgeSortEq{\forallsort{\alpha}{\kappa}{\upsilon}}{\forallsort{\alpha}{\kappa}{\upsilon'}}}
\end{mathpar}
\caption{Well-sorting of Sorts and Contexts}
\label{logic-sort-ok}
\end{figure}

\begin{figure}
\begin{mathpar}
\boxed{\judgeA{p}{\omega}}
\\
\inferrule*[right=TType]
          {\judgeACtx{\Delta} \\
           \judgectx{\Theta}{\Gamma} \\
           \judgeWK{\tau}{\kappa}}
          {\judgeA{\tau}{\kappa}}
\and
\inferrule*[right=TExpr]
          {\judgeACtx{\Delta} \\
           \judgeE{\Gamma}{e}{A}}
          {\judgeA{e}{A}}
\and
% \inferrule*[right=TPolytype]
%           {\judgeACtx{\Delta} \\
%            \judgeWK[\restrictkind{\Delta}]{A}{\bigstar}}
%           {\judgeA{A}{\bigstar}}
\inferrule*[right=THyp]
          {\judgeACtx{\Delta} \\
           u:\omega \in \Delta }
          {\judgeA{u}{\omega}}
\and
\inferrule*[right=TAbs1]
          {\judgeA[\Theta; \Gamma; \Delta, u:\upsilon']{p}{\upsilon}}
          {\judgeA{\pfun{u}{\upsilon'}{p}}{\upsilon' \To \upsilon}}
\and
\inferrule*[right=TAbs2]
          {\judgeA[\Theta; \Gamma, x:A; \Delta]{p}{\upsilon}}
          {\judgeA{\pfun{x}{A}{p}}{A \To \upsilon}}
\and
\inferrule*[right=TAbs3]
          {\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\upsilon} \\ \alpha\not\in\FV{\Gamma,\Delta,\upsilon}}
          {\judgeA{\pfun{\alpha}{\kappa}{p}}{\kappa \To \upsilon}}
\and
\inferrule*[right=TApp]
          {\judgeA{p}{\omega \To \upsilon} \\
           \judgeA{q}{\omega}}
          {\judgeA{p\;q}{\upsilon}}
\and
\inferrule*[right=TAbsAll]
          {\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\upsilon} \\
           \alpha \not\in \FV{\Gamma,\Delta}}
          {\judgeA{\pfunall{\alpha}{\kappa}{p}}{\forallsort{\alpha}{\kappa}{\upsilon}}}
\and
\inferrule*[right=TAppAll]
          {\judgeA{p}{\forallsort{\alpha}{\kappa}{\upsilon}} \\
           \judgeA{\tau}{\kappa}}
          {\judgeA{p\;[\tau]}{[\tau/\alpha]\upsilon}}

\and
\inferrule*[right=TConst]
          {\judgeACtx{\Delta} \\ \judgectx{\Theta}{\Gamma} \\
           c \in \setof{\top, \bot, \emp}}
          {\judgeA{c}{\assert}}
\and
\inferrule*[right=TBinary]
          {\judgeA{p}{\assert} \\
           \judgeA{q}{\assert} \\
           \oplus \in \setof{\land, \vee, \implies, *, \wand}}
          {\judgeA{p \oplus q}{\assert}}
\and
\inferrule*[right=TQuantify1]
          {\judgeA[\Theta; \Gamma; \Delta, u:\omega]{p}{\assert} \\
           Q \in \setof{\forall, \exists}}
          {\judgeA{Q u:\upsilon.\; p}{\assert}}
\and
\inferrule*[right=TQuantify2]
          {\judgeA[\Theta; \Gamma, x:A; \Delta]{p}{\assert} \\
           Q \in \setof{\forall, \exists}}
          {\judgeA{Q x:A.\; p}{\assert}}
\and
\inferrule*[right=TQuantify3]
          {\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta, u:\omega]{p}{\assert} \\
           Q \in \setof{\forall, \exists} \\
           \alpha \not\in \FV{\Gamma, \Delta}}
          {\judgeA{Q \alpha:\kappa.\; p}{\assert}}
\and
\inferrule*[right=TPointsTo]
          {\judgeA{e}{\reftype{A}} \\
           \judgeA{e'}{A}}
          {\judgeA{e \pointsto_A e'}{\assert}}
\and
\inferrule*[right=TEqual]
          {\judgeA{p}{\omega} \\
           \judgeA{q}{\omega} \\
           \judgeSort{\omega}}
          {\judgeA{p =_\omega q}{\assert}}
\and
\inferrule*[right=TSpec]
          {\judgeS{S}}
          {\judgeA{\validprop{S}}{\assert}}
\and
\inferrule*[right=TEqSort]
          {\judgeSortEq{\omega}{\omega'} \\
           \judgeA{p}{\omega'}}
          {\judgeA{p}{\omega}}
\end{mathpar}
\caption{Well-sorting of Assertions}
\label{logic-prop-ok}
\end{figure}

In the rules \textsc{TType} and \textsc{TExpr}, we simply inherit
well-kindedness and well-typedness from the corresponding judgments
for types and terms, defined in the previous chapter.  The rule
\textsc{THyp} is the hypothesis rule for propositional
variables. (Type and program expression variables can only be
referenced through the \textsc{TType} and \textsc{TExpr} rules.)


%
% \begin{figure}
% \begin{displaymath}
% \begin{array}{lcl}
% \restrictkind{\cdot}                 & = & \cdot \\
% \restrictkind{\Delta, \alpha:\kappa} & = & \restrictkind{\Delta}, \alpha:\kappa \\
% \restrictkind{\Delta, x:A}           & = & \restrictkind{\Delta} \\
% \restrictkind{\Delta, u:\assert}     & = & \restrictkind{\Delta} \\
% \restrictkind{\Delta, u:\omega \To \omega'} & = & \restrictkind{\Delta} \\[1em]
% 
% \restricttype{\cdot}                 & = & \cdot \\
% \restricttype{\Delta, \alpha:\kappa} & = & \restricttype{\Delta} \\
% \restricttype{\Delta, x:A}           & = & \restricttype{\Delta}, x:A \\
% \restricttype{\Delta, u:\assert}     & = & \restricttype{\Delta} \\
% \restricttype{\Delta, u:\omega \To \omega'} & = & \restricttype{\Delta} \\[1em]
% 
% \restricttyenv{\cdot}{\unit}                     & = & \unit \\ 
% \restricttyenv{\Delta, u:\kappa}{(\delta, x)}    & = & (\restricttyenv{\Delta}{\delta}, x) \\
% \restricttyenv{\Delta, u:\assert}{(\delta, x)}   & = & \restricttyenv{\Delta}{\delta} \\
% \restricttyenv{\Delta, u:A}{(\delta, x)}         & = & \restricttyenv{\Delta}{\delta} \\
% \restricttyenv{\Delta,u:\omega \To \omega'}{(\delta, x)} &=& \restricttyenv{\Delta}{\delta} \\[1em]
% 
% \restrictvals{\cdot}{\unit}                     & = & \unit                             \\ 
% \restrictvals{\Delta, u:\kappa}{(\delta, \tau)} & = & \restrictvals{\Delta}{\delta}      \\
% \restrictvals{\Delta, u:\assert}{(\delta, x)}   & = & \restrictvals{\Delta}{\delta}      \\
% \restrictvals{\Delta, u:A}{(\delta, x)}         & = & (\restrictvals{\Delta}{\delta}, x) \\
% \restrictvals{\Delta, u:\omega \To \omega'}{(\delta, x)} &=& \restrictvals{\Delta}{\delta} \\[1em]
% \end{array}
% \end{displaymath}
% \caption{Auxilliary Context Operations}
% \label{context-ops}  
% \end{figure}


% 
% (There is a minor technical issue here: we can refer to a program
% variable either via the \textsc{TermExpr} rule, or using the
% \textsc{TermHyp} rule. Strictly speaking, this means that well-sorting
% derivations are not unique, and so when we give a semantics, we would
% need to prove a coherence theorem. However, this could easily be
% avoided by adding some syntactic annotation to the use of program
% terms (for instance, by writing $\left\lfloor e \right\rfloor$ or
% similarly for variables), so we will simply let this issue slide.
% The \textsc{TermAbs} and \textsc{TermApp} rules give the
lambda-abstraction and application rules for the function sort $\omega
\To \upsilon$ -- there are no surprises here. Likewise, the
\textsc{TAbsAll} and \textsc{TAppAll} rules allow abstracting
applying kind-indexed products.

Finally, there are all
the rules giving the sorting of propositions. The nullary propositions
$\top, \bot$, and $\emp$ are typed with the \textsc{TConst}
rule, and the binary propositions $\land, \vee, \implies, *$, and
$\wand$ are typed with the \textsc{TBinary} rule, requiring
their two arguments to both be of sort $\assert$.


The two quantifiers $\forall u:\omega.\;p$ and $\exists u:\omega.\;p$
are sorted with the \textsc{TQuantify} rules. We have three
variants of this rule, putting a new variable into different contexts
depending on whether the variable is a type, term or propositional
variable.  The points-to $e \pointsto_A e'$ and equality $p =_\omega
q$ each require that their arguments be of the correct sort. Note that
$e \pointsto_A e'$ is restricted to program types, as expected,
whereas equality is permitted at any sort.

Finally, we have the rule $\textsc{TSpec}$ for the
specification-embedding assertion $\validprop{S}$, which recursively
invokes the well-sorted specification $\judgeS{S}$. This judgment is
defined in Figure~\ref{logic-spec-ok}, and consists of a handful of
rules. The \textsc{SpecTriple} rule asserts that $\spec{p}{c}{a:A}{q}$
is well-kinded when $A$ is a type, $p$ is an assertion, $c$ is a
computation yielding an $A$, and $q$ is an assertion with $a$ as an
extra free variable.  Likewise the \textsc{SpecMTriple} rule does the
same job for monadic expressions, saying that $\mspec{p}{e}{a:A}{q}$,
saying that $e$ must be a term of monadic type $\monad{A}$, but
otherwise as in the \textsc{SpecTriple} rule.  Finally, the remaining
atomic proposition \textsc{SpecAssert} rule recursively calls back into the
assertion well-kinding judgment.

The \textsc{SpecBinary} rules gives well-formedness conditions for the
conjunction ($S \specand S'$), disjunction ($S \specor S'$), and
implication ($S \specimp S'$) over specifications, in each case asking
the subterms to be well-formed specifications. The quantifier rules
\textsc{SpecQuantify} simply extend the context with the newly
quantified variable. As with assertions, we have three versions of
this rule, one for each context.

Since $\spectype$ is not a sort, this means that the language of
specifications is a multi-sorted first-order logic, rather than a
higher-order logic. There are no technical obstacles to extending it
in this fashion, but we have not felt any strong need to do so.


\begin{figure}
\begin{mathpar}
\boxed{\judgeS{S}} \\
\inferrule*[right=SpecTriple]
          {\judgeA{p}{\assert} \\
           \judgeA{\comp{c}}{\monad{A}} \\
           \judgeA[\Theta; \Gamma, a:A; \Delta]{q}{\assert}}
          {\judgeS{\spec{p}{c}{a:A}{q}}}
\and
\inferrule*[right=SpecMTriple]
          {\judgeA{p}{\assert} \\
           \judgeA{e}{\monad{A}} \\
           \judgeA[\Theta; \Gamma, a:A; \Delta]{q}{\assert}} 
          {\judgeS{\mspec{p}{e}{a:A}{q}}}
\and
\inferrule*[right=SpecAssert]
          {\judgeA{p}{\assert}}
          {\judgeS{\setof{p}}}
\and
\inferrule*[right=SpecQuantify1]
          {\judgeS[\Theta; \Gamma; \Delta, u:\upsilon]{S} \\ u \in \setof{\forall, \exists}}
          {\judgeS{Q u:\upsilon.\; S}}
\and
\inferrule*[right=SpecQuantify2]
          {\judgeS[\Theta, \alpha:\kappa, \Gamma, \Delta]{S} \\ u \in \setof{\forall, \exists} \\
           \alpha \not\in \FV{\Gamma,\Delta}}
          {\judgeS{Q \alpha:\kappa.\; S}}
\and
\inferrule*[right=SpecQuantify3]
          {\judgeS[\Theta; \Gamma, x:A; \Delta]{S} \\ u \in \setof{\forall, \exists}}
          {\judgeS{Q x:A.\; S}}
\and
\inferrule*[right=SpecBinary]
          {\judgeS{S_1} \\ \judgeS{S_2} \\ \oplus \in \setof{\specand, \specor, \specimp}}
          {\judgeS{S_1 \oplus S_2}}
\end{mathpar}
\caption{Well-sorting of Specifications}
\label{logic-spec-ok}
\end{figure}

\subsection{Substitution Properties}

In the syntax for the program logic, we have systematically made the
decision to forbid the appearance of logical expressions within
program expressions. We accomplish this by prohibiting variables from
having sorts like $P : \assert \To \N$. As a result, it is not
possible to form program expressions which depend on subexpressions of
logical type, such as writing an expression of monadic type
$\monad{\N}$ like $\comp{P(x \pointsto y)}$.

This restriction ensures that program expressions never use variables
of logical type, and so any term expression can be typed using only
type and term variables, without any dependence on variables drawn
from the logical sorts. By requiring program expressions to only
contain programmatic subexpressions, we forbid the use of ``ghost
expressions'' in our programs. This restriction greatly simplify the
semantics of the program logic. I intend for the sorts of our logic to
be interpreted in Set, but the terms of our programming language are
interpreted in CPO. It is not trivial to intermingle logical and
program expressions, and so the simplest course is to forbid this
mixing.

However, this does not restrict the expressiveness of our program
logic reasoning, since our program logic is a full specification
logic. We have no need of ghost state, since we can place quantifiers
outside of Hoare triples. This lets us relate variables across a pre-
and post-condition without any dubious manipulations of binding
structure or extensions of the heap semantics.

The price we must pay for this simplicity is an increase in the
complexity of the substitution theorems of the logic: since we have
three contexts, we need six substitution theorems --- three each for
assertions and specifications. We will give these theorems after we
have given the proofs, since it will be convenient to state the syntactic
and semantic substitution properties together. 

\section{Semantics}

Now, we will consider the interpretation of the syntax. To do this,
we will proceed in stages. First, we will show how to interpret sorts and
contexts by sets, and show that the equality judgment for sorts is
sound. Using this, we will then give interpretation of terms and
specifications, and show that the interpretation is sound with respect
to substitution.

\subsection{Interpretation of Sorts}

We will start by explaining how to interpret the sorts. Essentially,
we are going to define assertions to be the powerset of heaps, and
specifications to be upward closed sets of assertions, but because we
allow types as sorts, and types may have free type variables, we will
need to give a pair of indexed, recursive definitions to make
everything work properly. We give these definitions in
Figure~\ref{sort-interpretation}. 

\begin{figure}
\begin{displaymath}
  \begin{array}{lcl}
    \interp{\judgeSort{\omega}} & \in & \interp{\Theta} \to \mathrm{Set} \\[0.5em]
    \interp{\judgeSort{\kappa}} \;\theta
    & = & \interp{\kappa} 
    \\
    \interp{\judgeSort{A}}\;\theta
    & = & U(\interp{\judgeWK{A}{\bigstar}}\;\theta)
    \\
    \interp{\judgeSort{\assert}}\;\theta
    & = & \powerset{H}
    \\
    \interp{\judgeSort{\omega \To \upsilon}}\;\theta
    & = & \interp{\judgeSort{\omega}}\;\theta \to \interp{\judgeSort{\omega}}\;\theta
    \\
    \interp{\judgeSort{\forallsort{\alpha}{\kappa}{\upsilon}}}\;\theta
    & = & \Pi \tau \in \interp{\kappa}.\;\interp{\judgeSort[\Theta, \alpha:\kappa]{\upsilon}}\;(\theta,\tau)
    \\[2em]
    \interp{\judgeACtx{\Delta}} & \in & \interp{\Theta} \to \mathrm{Set} \\[0.5em]
    \interp{\judgeACtx{\cdot}}\;\theta & = & 1 \\
    \interp{\judgeACtx{\Delta, u:\upsilon}}\;\theta & = & \interp{\judgeACtx{\Delta}}\;\theta \times
                                                          \interp{\judgeSort{\upsilon}\;\theta}

  \end{array}
\end{displaymath}
\caption{Interpretation of Sorts and Contexts}
\label{sort-interpretation}  
\end{figure}

A well-sorting derivation is interpreted as a function from a tuple
representing the type constructor environment into a set. The
interpretation of a kind $\kappa$ is just its set-theoretic semantics,
defined in the previous chapter. The interpretation of a type $A$ is
its domain-theoretic interpretation, hit with the forgetful functor
$U$ to get only its underlying set of points.  The interpretation of
propositions $\assert$ is the powerset of heaps, and the function
space $\omega \To \upsilon$ is just the set-theoretic function space
between the two sorts. The type-indexed sort
$\forallsort{\alpha}{\kappa}{\upsilon}$ is interpreted by an indexed
family of sets, with the index extendeding the context.


% Therefore, we will need to give a mutually-recursive definition
% between the interpretation the two judgments $\judgeACtx{\Delta}$ and
% $\judgeA{\Delta}{\omega}$.
% 
% \begin{displaymath}
%   \begin{array}{lcl}
%     \interp{\judgeACtx{\Delta}} & \in & \mbox{Set} \\
%     \interp{\judgeSort{\omega}} & \in & \interp{\judgeACtx{\Delta}} \to \mbox{Set} \\[1em]
% 
%     \interp{\judgeACtx{\cdot}} & = & \unittype \\
%     \interp{\judgeACtx{\Delta, u:\omega}} & = & \sum \delta \in \interp{\judgeACtx{\Delta}}.\; 
%                                                   (\interp{\judgeSort{\omega}}\;\delta) \\[1em]
%  
%     \interp{\judgeSort{\kappa}}\;\delta & = & \interp{\kappa} \\
%     \interp{\judgeSort{A}}\;\delta & = & 
%        U(\interp{\judgeWK[\restrictkind{\Delta}]{A}{\bigstar}}\;(\restricttyenv{\Delta}{\delta})) \\
%     \interp{\judgeSort{\assert}}\;\delta & = & \powerset{H} \\
%     \interp{\judgeSort{\omega \To \omega'}}\;\delta & = &  
%        \interp{\judgeSort{\omega}}\;\delta \to \interp{\judgeSort{\omega}}\;\delta \\
%   \end{array}
% \end{displaymath}
% 
% The semantic brackets are slightly overloaded in this definition. To
% interpret a type $A$, we take it to be the set of the elements of the
% domain-theoretic interpretation of $A$, and to interpret a kind
% $\kappa$, we take it to be the set of closed canonical forms of that
% type. Both of these use the interpretations given in the previous
% chapter. 
% 
% In order to establish that this actually defines a function, we will
% need to prove some supporting lemmas. First, we need to establish that
% we an also prove that the context $\Delta$ is well-formed is
% $\judgeSort{\omega}$ is derivable:
% 
% \begin{lemma}{(Well-sortedness implies well-formed contexts)}
% If it is the case that $\judgeSort{\omega}$, then $\judgeACtx{\Delta}$.
% \end{lemma}
% \begin{proof}
% The proof is by a trivial structural induction over the derivation $\judgeSort{\omega}$. 
% \end{proof}
% 
% Now, this means that the domain of the interpretation function
% $\interp{\judgeACtx{\Delta}}$ is always well-defined, given a $\judgeSort{\omega}$. Next,
% we need to establish that we get the same result, regardless of \emph{which} derivation
% of this judgment we found. 
% 
% \begin{lemma}{(Uniqueness of Interpretations)}
% We have that:
% \begin{enumerate}
% \item If we have two derivations $\mathcal{D}_1 :: \judgeACtx{\Delta}$
%       and $\mathcal{D}_2 :: \judgeACtx{\Delta}$, 
%       then $\interp{\mathcal{D}_1} = \interp{\mathcal{D}_2}$
% \item If we have two derivations $\mathcal{D}_1 ::\; \judgeSort{\omega}$
%       and $\mathcal{D}_2 ::\; \judgeSort{\omega}$, 
%       then $\interp{\mathcal{D}_1} = \interp{\mathcal{D}_2}$
% \end{enumerate}
% \end{lemma}
% \begin{proof}
%   The proof is at the end of the chapter.
% \end{proof}
% 
% \subsubsection{Interpretation of Equality Judgment on Sorts}
% 
% Now, we will show that our equality judgment on sorts $\judgeSortEq{\omega}{\omega'}$ is
% sound. 
% 
% \begin{lemma}{(Soundness of Sort Equality)}
% If $\judgeACtx{\Delta}$, $\judgeSort{\omega}$, and $\judgeSort{\omega'}$ are derivable, then if 
% $\judgeSortEq{\omega}{\omega'}$ is derivable, then $\interp{\judgeSort{\omega}} = \interp{\judgeSort{\omega'}}$. 
% \end{lemma}
% \begin{proof}
%   The proof is at the end of the chapter. 
% \end{proof}

\subsection{Interpretation of Terms and Specifications}

The term judgment $\judgeA{p}{\omega}$ is mutually recursively
defined with the specification judgment $\judgeS{S}$. Therefore, when
we give the semantics of these judgments, we need to define them
together. The definition of the interpretation of these two judgments
is given in Figures~\ref{term-interpretation} and
\ref{spec-interpretation}.

There are no surprises in the interpretations -- everything is
interpreted straightforwardly. The only unusual feature is that
lambda-abstractions and quantifiers have three cases, corresponding to
their three typing rules. However, the interpretation is still
syntax-directed, since types, kinds, and propositional sorts are
syntactically distinct.

\subsection{Substitution Properties}

We state the main soundness theorems below. 

\begin{figure}
\begin{displaymath}
\begin{array}{lcl}
\interp{\judgeA{p}{\omega}} & \in & \prod \theta \in \interp{\theta}, \gamma \in \interp{\judgectx{\Theta}{\Gamma}}\;\theta, \delta \in \interp{\judgeACtx{\Delta}}\;\theta.\\
                            &     & \qquad \to \interp{\judgeSort{\omega}}\;\theta \gamma \delta \\
\interp{\judgeS{S}}         & \in & \prod \theta \in \interp{\theta}, \gamma \in \interp{\judgectx{\Theta}{\Gamma}}\;\theta, \delta \in \interp{\judgeACtx{\Delta}}\;\theta.\\
                            &     &\qquad\to \upset{W(\powerset{H})} \\[1em]

\interp{\judgeA{\tau}{\kappa}}\;\theta\,\gamma\,\delta & = & \interp{\judgeWK{\tau}{\kappa}}\;\theta \\

\interp{\judgeA{e}{A}}\;\theta\,\gamma\,\delta & = &  U(\interp{\judgeE{\Gamma}{e}{A}}\;\theta)\;\gamma \\

\interp{\judgeA{\pfun{u}{\upsilon'}{p}}{\upsilon' \To \upsilon}}\;\theta\,\gamma\,\delta & = & 
   \semfun{v \in \interp{\judgeSort{\upsilon'}}}
          {\interp{\judgeA[\Theta; \Gamma; \Delta,u:\upsilon']{p}{\upsilon}}\;\theta\,\gamma\,(\delta, v)} \\

\interp{\judgeA{\pfun{x}{A}{p}}{A \To \upsilon}}\;\theta\,\gamma\,\delta & = & 
   \semfun{v \in \interp{\judgeSort{A}}}
          {\interp{\judgeA[\Theta;\Gamma,x:A;\Delta]{p}{\upsilon}}\;\theta\,(\gamma,v)\,\delta} \\

\interp{\judgeA{\pfun{\alpha}{\kappa}{p}}{\kappa \To \upsilon}}\;\theta\,\gamma\,\delta & = & 
   \semfun{\tau \in \interp{\judgeSort{\kappa}}}
          {\interp{\judgeA[\Theta, \alpha:\kappa;\Gamma;\Delta]{p}{\upsilon}}\;(\theta,\tau)\,\gamma\,\delta} \\

\interp{\judgeA{p\;q}{\upsilon}}\;\delta & = & 
   (\interp{\judgeA{p}{\omega \To \upsilon}}\;\delta)\;(\interp{\judgeA{q}{\omega}}\;\delta) \\

\interp{\judgeA{\pfunall{\alpha}{\kappa}{p}}{\forallsort{\alpha}{\kappa}{\upsilon}}}\;\theta\,\gamma\,\delta & = &
   \semfun{\tau \in \interp{\judgeSort{\kappa}}\;\theta}
          {\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\upsilon}}\;(\theta,\tau)\,\gamma\,\delta}
\\
\interp{\judgeA{p\;[\tau]}{[\tau/\alpha]\upsilon}}\;\theta\,\gamma\,\delta & = & 
   (\interp{\judgeA{p}{\forallsort{\alpha}{\kappa}{\upsilon}}}\;\theta\,\gamma\,\delta)\;
   (\interp{\judgeWK{\tau}{\kappa}}\;\theta) \\


\interp{\judgeA{u}{\omega}}\;\theta\,\gamma\,\delta & = & \pi_u(\delta) \\

\interp{\judgeA{c}{\assert}}\;\theta\,\gamma\,\delta & = & \interp{c}^0 \\

\interp{\judgeA{p \oplus q}{\assert}}\;\theta\,\gamma\,\delta & = & 
    \interp{\judgeA{p}{\assert}}\;\theta\,\gamma\,\delta \\
& & \interp{\oplus}^2\;\;\interp{\judgeA{q}{\assert}}\;\theta\,\gamma\,\delta \\

\interp{\judgeA{e \pointsto_A e'}{\assert}}\;\theta\,\gamma\,\delta & = & 
    \mbox{let } l = \interp{\judgeE{\Gamma}{e}{\reftype{A}}}\;\theta\,\gamma \mbox{ in}\\
& & \mbox{let } v = \interp{\judgeE{\Gamma}{e'}{A}}\;\theta\,\gamma \mbox{ in} \\
& & l \pointsto v \\


\interp{\judgeA{p =_\omega q}{\assert}}\;\theta\,\gamma\,\delta & = & 
   \mbox{if }\interp{\judgeA{p}{\omega}}\;\theta\,\gamma\,\delta = \interp{\judgeA{q}{\omega}}\;\theta\,\gamma\,\delta \\
   & & \mbox{ then } \top \mbox{ else} \bot \\

\interp{\judgeA{Q u:\upsilon.\; p}{\assert}}\;\theta\,\gamma\,\delta & = & 
  \interp{Q}^\infty_{v \in \interp{\judgeSort{\upsilon}}\;\theta}
    \interp{\judgeA[\Theta; \Gamma; \Delta, u:\omega]{p}{\assert}}\;\theta\,\gamma\,(\delta, v) \\

\interp{\judgeA{Q x:A.\; p}{\assert}}\;\theta\,\gamma\,\delta & = & 
  \interp{Q}^\infty_{v \in \interp{\judgeSort{A}}\;\theta}
    \interp{\judgeA[\Theta; \Gamma, x:A; \Delta]{p}{\assert}}\;\theta\,(\gamma,v)\,\delta \\

\interp{\judgeA{Q \alpha:\kappa.\; p}{\assert}}\;\theta\,\gamma\,\delta & = & 
  \interp{Q}^\infty_{\tau \in \interp{\judgeSort{\kappa}}\;\theta}
    \interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\assert}}\;(\theta, \tau)\,\gamma\,\delta \\


\interp{\judgeA{\validprop{S}}{\assert}}\;\theta\,\gamma\,\delta & = & 
   \mbox{if } \interp{\judgeS{S}}\;\theta\,\gamma\,\delta = \top_{\upset{W(\powerset{H})}}
   \mbox{ then } \top
   \mbox{ else } \bot \\

\interp{\judgeA{p}{\omega}}\;\theta\,\gamma\,\delta & = & 
   \interp{\judgeA{p}{\omega'}}\;\delta \mbox{ when } \judgeSortEq{\omega}{\omega'} \\[1em]

\interp{\top}^0 & = & \top \\
\interp{\bot}^0 & = & \bot \\
\interp{\emp}^0 & = & I \\[1em]

\interp{\land}^2    & = & \land \\
\interp{\implies}^2 & = & \implies \\
\interp{\vee}^2     & = & \vee \\
\interp{*}^2        & = & * \\
\interp{\wand}^2    & = & \wand \\[1em]

\interp{\forall}^\infty & = & \bigwedge \\
\interp{\exists}^\infty & = & \bigvee \\[1em]

l \pointsto v & = & \setof{(\setof{l}, \semfun{loc}{v \mbox{ when } loc = l})}
\end{array}
\end{displaymath}
\caption{ Interpretation of Terms }
\label{term-interpretation}  
\end{figure}

\begin{figure}
\begin{displaymath}
\begin{array}{lcl}
\interp{\judgeS{\spec{p}{c}{a:A}{q}}}\;\theta\,\gamma\,\delta & = & 
   \begin{array}{l}
     \setof{\interp{\judgeA{p}{\assert}}\;\theta\,\gamma\,\delta} \\
      \interp{\judgeC{\Gamma}{c}{A}}\;\theta\;\gamma\;\delta \\
     \setof{v.\; \interp{\judgeA[\Delta, a:A]{q}{\assert}}\;\theta\,(\gamma,v)\,\delta} \\
   \end{array} 
\\[2em]

\interp{\judgeS{\mspec{p}{e}{a:A}{q}}}\;\theta\,\gamma\,\delta & = & 
   \begin{array}{l}
     \setof{\interp{\judgeA{p}{\assert}}\;\theta\,\gamma\,\delta} \\
      \interp{\judgeE{\Gamma}{e}{\monad{A}}}\;\theta\;\gamma\;\delta \\
     \setof{v.\; \interp{\judgeA[\Delta, a:A]{q}{\assert}}\;\theta\,(\gamma,v)\,\delta} \\
   \end{array} 
\\[2em]

\interp{\judgeS{\setof{p}}}\;\theta\,\gamma\,\delta & = & 
  \mbox{if } \interp{\judgeA{p}{\assert}}\;\theta\,\gamma\,\delta = \top_{\powerset{H}}
  \mbox{ then } \top 
  \mbox{ else } \bot \\

\interp{\judgeS{S_1 \oplus S_2}}\;\theta\,\gamma\,\delta & = & 
  \interp{\judgeS{S_1}}\;\theta\,\gamma\,\delta \;\;\interp{\oplus} \\ 
&& \interp{\judgeS{S_2}}\;\theta\,\gamma\,\delta \\

\interp{\judgeS{Q u:\upsilon.\; S}}\;\theta\,\gamma\,\delta & = & 
  \interp{Q}_{v \in \interp{\judgeSort{\upsilon}}\;\theta} 
     \interp{\judgeS[\Theta;\Gamma;\Delta, u:\upsilon]{S}}\;\theta\,\gamma\,(\delta,v) \\

\interp{\judgeS{Q x:A.\; S}}\;\theta\,\gamma\,\delta & = & 
  \interp{Q}_{v \in \interp{\judgeSort{A}}\;\theta} 
     \interp{\judgeS[\Theta;\Gamma,x:A;\Delta]{S}}\;\theta\,(\gamma,v)\,\delta \\

\interp{\judgeS{Q \alpha:\kappa.\; S}}\;\theta\,\gamma\,\delta & = & 
  \interp{Q}_{\tau \in \interp{\judgeSort{\kappa}}\;\theta} 
     \interp{\judgeS[\Theta,\alpha:\kappa;\Gamma;\Delta]{S}}\;(\theta,\tau)\,\gamma\,\delta \\[1em]


\interp{\specand} & = & \land \\
\interp{\specor}  & = & \vee  \\
\interp{\specimp} & = & \implies \\[1em]

\interp{\forall} & = & \bigwedge \\
\interp{\exists} & = & \bigvee \\

\end{array}
\end{displaymath}
\caption{Interpretation of Specifications}
\label{spec-interpretation}  
\end{figure}

\ \\


\begin{lemma}{(Substitution for Sorts)}
Suppose $\judgeWK{\tau}{\kappa}$.
\begin{enumerate}
\item If $\judgeSort[\Theta, \alpha:\kappa]{\omega}$, then $\judgeSort[\Theta]{[\tau/\alpha]\omega}$ and \\
      $\interp{\judgeSort[\Theta]{[\tau/\alpha]\omega}}\;\theta$ equals
      $\interp{\judgeSort[\Theta, \alpha:\kappa]{\omega}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)$
\item If $\judgeACtx[\Theta, \alpha:\kappa]{\Delta}$, then $\judgeACtx{{[\tau/\alpha]}\Delta}$ and \\
      $\interp{\judgeACtx{{[\tau/\alpha]}\Delta}}\;\theta$ equals 
      $\interp{\judgeACtx[\Theta, \alpha:\kappa]{\Delta}}(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)$ 
\item If $\judgeSortEq[\Theta, \alpha:\kappa]{\omega}{\omega'}$, then
      $\judgeSortEq{{[\tau/\alpha]}\omega}{{[\tau/\alpha]}\omega'}$. 
\item If $\judgeSortEq{\omega}{\omega'}$ is derivable, then
      $\interp{\judgeSort{\omega}} = \interp{\judgeSort{\omega'}}$.
\item If $\judgeSort[\Theta]{\omega}$, then $\judgeSort[\Theta, \alpha:\kappa]{\omega}$
\item If $\judgeSort[\Theta]{\omega}$ and $\judgeSort[\Theta, \alpha:\kappa]{\omega}$, then
      $\interp{\judgeSort[\Theta]{\omega}}\;\theta = \interp{\judgeSort[\Theta, \alpha:\kappa]{\omega}}\;(theta,\tau)$
\end{enumerate}
\end{lemma}
\begin{proof}
  These lemmas follow from routine inductions.
\end{proof}

\ \\

\begin{lemma}{(Weakening and Strengthening)}
\begin{enumerate}
\item If $\judgeA{p}{\omega}$, then $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\omega}$.
\item If $\judgeA{p}{\omega}$ and $\judgeSort{A}$, then $\judgeA[\Theta; \Gamma, x:A; \Delta]{p}{\omega}$.
\item If $\judgeA{p}{\omega}$ and $\judgeSort{\upsilon}$, then $\judgeA[\Theta; \Gamma; \Delta, u:\upsilon]{p}{\omega}$.
\item If $\judgeA{p}{\omega}$ and $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\omega'}$ and $\judgeSortEq{\omega}{\omega'}$, then \\
      $\interp{\judgeA{p}{\omega}}\;\theta\;\gamma\;\delta =\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\omega'}}\;(\theta, \tau)\;\gamma\;\delta$. 
\item If $\judgeA{p}{\omega}$ and $\judgeA[\Theta; \Gamma, x:A; \Delta]{p}{\omega'}$ and $\judgeSortEq{\omega}{\omega'}$, then \\
      $\interp{\judgeA{p}{\omega}}\;\theta\;\gamma\;\delta =\interp{\judgeA[\Theta; \Gamma, x:A; \Delta]{p}{\omega'}}\;\theta\;(\gamma,v)\;\delta$. 
\item If $\judgeA{p}{\omega}$ and $\judgeA[\Theta; \Gamma; \Delta, u:\upsilon]{p}{\omega'}$ and $\judgeSortEq{\omega}{\omega'}$, then \\
      $\interp{\judgeA{p}{\omega}}\;\theta\;\gamma\;\delta =\interp{\judgeA[\Theta; \Gamma; \Delta, u:\upsilon]{p}{\omega'}}\;(\theta, \tau)\;\gamma\;(\delta,v)$. 
\end{enumerate}
In the last three cases, we assume that the arguments to the semantic functions are suitably typed. 
\end{lemma}

\begin{proof}
These proofs all follow from a routine induction. The
extra premise in the final three cases handles the slight non-syntax-directedness induced by the 
\textsc{TEqSort} rule. 
\end{proof}

\ \\

\begin{lemma}{(Substitution for Terms and Specifications)}
\begin{enumerate}
\item Suppose $\judgeWK{\tau}{\kappa}$.
  \begin{enumerate}
  \item If $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\omega}$, 
        then 
        \begin{enumerate}
        \item $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{{[\tau/\alpha]}\omega}$
        \item $\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{{[\tau/\alpha]}\omega}}\;\theta\,\gamma\,\delta$ equals \\
          $\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma, \Delta]{p}{\omega}}\;(\theta,\interp{\judgeWK{\tau}{\kappa}}\;\theta)\,\gamma\,\delta$
        \end{enumerate}
  \item If $\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{S}$, 
        then 
        \begin{enumerate}
        \item $\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}S}$
        \item $\interp{\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}S}}\;\theta$ equals \\
              $\interp{\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{S}}(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)$
        \end{enumerate}
  \end{enumerate}
\item Suppose $\judgeE{\Gamma}{e}{A}$.
  \begin{enumerate}
  \item If $\judgeA[\Theta; \Gamma, x:A; \Delta]{p}{\omega}$, 
        then 
        \begin{enumerate}
        \item $\judgeA[\Theta; \Gamma; \Delta]{[e/x]p}{\omega}$, 
        \item $\interp{\judgeA[\Theta; \Gamma; \Delta]{[e/x]p}{\omega}}\;\theta\,\gamma\,\delta$ equals \\
              $\interp{\judgeA[\Theta; \Gamma, x:A; \Delta]{p}{\omega}}\;\theta\,(\gamma, \interp{\judgeE{\Gamma}{e}{A}}\;\theta\;\gamma)\,\delta$               
        \end{enumerate}
  \item If $\judgeS[\Theta; \Gamma, x:A; \Delta]{S}$, 
        then 
        \begin{enumerate}
        \item $\judgeS[\Theta; \Gamma; \Delta]{[e/x]S}$.
        \item $\interp{\judgeS[\Theta; \Gamma; \Delta]{[e/x]S}}\;\theta\,\gamma\,\delta$ equals \\
              $\interp{\judgeS[\Theta; \Gamma, x:A; \Delta]{S}}\;\theta\,(\gamma, \interp{\judgeE{\Gamma}{e}{A}}\;\theta\;\gamma)\,\delta$
        \end{enumerate}
  \end{enumerate}
\item Suppose $\judgeA{q}{\upsilon}$.
  \begin{enumerate}
  \item If $\judgeA[\Theta; \Gamma; \Delta, u:\upsilon]{p}{\omega}$, 
        then 
        \begin{enumerate}
          \item $\judgeA[\Theta; \Gamma; \Delta]{[q/u]p}{\omega}$
          \item $\interp{\judgeA[\Theta; \Gamma; \Delta]{[q/u]p}{\omega}}\;\theta\,\gamma\,\delta$ equals \\
                $\interp{\judgeA[\Theta; \Gamma; \Delta, u:\upsilon]{p}{\omega}}\;\theta\,\gamma\,(\delta, \interp{\judgeA{q}{\upsilon}}\;\theta\,\gamma\,\delta)$
        \end{enumerate}
      \item If $\judgeS[\Theta; \Gamma:A; \Delta, u:\upsilon]{S}$, 
        then 
        \begin{enumerate}
          \item $\judgeS[\Theta; \Gamma; \Delta]{[q/u]S}$ 
          \item $\interp{\judgeS[\Theta; \Gamma; \Delta]{[q/u]S}}\;\theta\,\gamma\,\delta$ equals \\
                $\interp{\judgeS[\Theta; \Gamma:A; \Delta, u:\upsilon]{S}}\;\theta\,\gamma\,(\delta, \interp{\judgeA{q}{\upsilon}}\;\theta\,\gamma\,\delta)$
        \end{enumerate}
  \end{enumerate}

\end{enumerate}
\end{lemma}
\begin{proof}
  The proof is at the end of the chapter.
\end{proof}


\section{The Program Logic}

\begin{figure}
\begin{mathpar}
  \inferrule*[right=AxEquiv1]
         {\judgeS{\spec{p}{c}{a:A}{q} \specimp \mspec{p}{\comp{c}}{a:A}{q}}} 
         {\validS{\spec{p}{c}{a:A}{q} \specimp \mspec{p}{\comp{c}}{a:A}{q}}} 
\and 
  \inferrule*[right=AxEquiv2]
    {\judgeS{\mspec{p}{\comp{c}}{a:A}{q} \specimp \spec{p}{c}{a:A}{q}}} 
    {\validS{\mspec{p}{\comp{c}}{a:A}{q} \specimp \spec{p}{c}{a:A}{q}}} 
\and

  \inferrule*[right=AxReturn]
    {\judgeS{\spec{P}{e}{a:A}{P \land a = e}}}
    {\validS{\spec{P}{e}{a:A}{P \land a = e}}}
\and

  \inferrule*[right=AxAssign]
    {\judgeS{\spec{e \pointsto_A -}{e := e'}{a:\unittype}{e \pointsto_A e'}}}
    {\validS{\spec{e \pointsto_A -}{e := e'}{a:\unittype}{e \pointsto_A e'}}}
\and

  \inferrule*[right=AxAlloc]
    {\judgeS{\spec{\emp}{\newref{A}{e}}{a:\reftype{A}}{a \pointsto e}}}
    {\validS{\spec{\emp}{\newref{A}{e}}{a:\reftype{A}}{a \pointsto e}}}
\and

  \inferrule*[right=AxDeref]
    {\judgeS{\spec{e \pointsto_A e'}{!e}{a:A}{e \pointsto_A e' \land a = e'}}}
    {\validS{\spec{e \pointsto_A e'}{!e}{a:A}{e \pointsto_A e' \land a = e'}}}
\and

  \inferrule*[right=AxBind]
            {\validS{\mspec{p}{e}{x:A}{q}} \\
             \validS[\Theta; \Gamma, x:A; \Delta]{\spec{q}{c}{a:B}{r}} \\
             \judgeA[\Theta; \Gamma, a:B; \Delta]{r}{\assert}}
            {\validS{\spec{p}{\letv{x}{e}{c}}{a:B}{r}}}
\and

  \inferrule*[right=AxFix]
            {\validS{(\forall x:\monad{A}.\; \mspec{p}x{a:A}{q(a)}) \specimp \mspec{p}{e}{a:A}{q})}}
            {\validS{\mspec{p}{\fix{x:\monad{A}}{e}}{a:A}{q}}}
\end{mathpar}
\caption{Basic Axioms of Specification Logic}
\label{spec-logic-axioms-basic}
\end{figure}

\begin{figure}
\begin{mathpar}
  \inferrule*[right=AxExtract]
             {\validS{\setof{r} \specimp \spec{p}{c}{a:A}{q}} \\
              \mbox{$r$ is a pure formula} \\
              \validP{p \implies r}}
             {\validS{\spec{p}{c}{a:A}{q}}}
\and

  \inferrule*[right=AxEmbed]
             {\validS{\setof{r} \specimp \spec{p \land r}{c}{a:A}{q}}}
             {\validS{\setof{r} \specimp \spec{p}{c}{a:A}{q}}}
\and
  
  \inferrule*[right=AxUseValid]
             { }
             {\validS{\setof{\validprop{S}} \specimp S}}
\and
  \inferrule*[right=AxForgetEx1]
             {\validS[\Theta; \Gamma; \Delta, u:\upsilon]{\spec{p}{c}{a:A}{q}}\\ u\not\in\mathrm{FV}(q)}
             {\validS{\spec{\exists u:\upsilon.\;p}{c}{a:A}{q}}}

\and
  \inferrule*[right=AxForgetEx2]
             {\validS[\Theta; \Gamma, y:B; \Delta]{\spec{p}{c}{a:A}{q}} \\ y\not\in\mathrm{FV}(c) \\ y\not\in\mathrm{FV}(q)}
             {\validS{\spec{\exists y:B.\;p}{c}{a:A}{q}}}

\and
  \inferrule*[right=AxForgetEx3]
             {\validS[\Theta, \alpha:\kappa; \Gamma; \Delta]{\spec{p}{c}{a:A}{q}} \\ \alpha\not\in\mathrm{FV}(c) \\ u\not\in\mathrm{FV}(\alpha)}
             {\validS{\spec{\exists \alpha:\kappa.\;p}{c}{a:A}{q}}}

\and
  \inferrule*[right=AxEquality]
             {\validS{\setof{r} \specimp \spec{p}{c[e/x]}{a:A}{q}} \\
              \validP{r \implies e =_A e'} }
             {\judgeS{\setof{r} \specimp \spec{p}{c[e'/x]}{a:A}{q}}}

\and
  \inferrule*[right=AxConsequence]
             {\validS{\spec{p'}{c}{a:A}{q'}} \\ \validP{p \implies p'} \\ \validP[\Theta; \Gamma, a:A; \Delta]{q' \implies q}}
             {\validS{\spec{p}{c}{a:A}{q}}}
  
\and

  \inferrule*[right=AxDisjunction]
             {\validS{\spec{p}{c}{a:A}{q}} \\
              \validS{\spec{p'}{c}{a:A}{q'}}}
             {\validS{\spec{p \vee p'}{c}{a:A}{q \vee q'}}}
\and

  \inferrule*[right=AxEmbedAssert]
             {\validP{p}}
             {\validS{\setof{p}}}

\and
\inferrule*[right=AxFrame]
          {\judgeS{S} \\ \judgeA{r}{\assert} }
          {\validS{S \specimp S \otimes r}}
\and
\mbox{(+ all of the axioms of intuitionistic logic)}
\end{mathpar}
\caption{Structural Axioms of the Program Logic}
\label{spec-logic-axioms-structural}
\end{figure}

\begin{figure}
\begin{mathpar}
  \inferrule*{\validS{S}}
             {\validP{\validprop{S}}}
\and
  \inferrule*{\judgeA{p}{\assert}}
             {\validP{\validprop{\setof{p}} \implies p}}
\and 
  \inferrule*{\judgeEqA{p}{q}{\omega}}
             {\validP{p =_\omega q}}
\\
  \mbox{(plus axioms of higher-order separation logic)}
\end{mathpar}
\caption{Axioms of Assertion Logic}
\label{assertion-logic-axioms}  
\end{figure}

\begin{figure}
\begin{mathpar}
\inferrule*[]
          {\judgeA{p}{\omega}}
          {\judgeEqA{p}{p}{\omega}}
\and
\inferrule*[]
          {\judgeEqA{p}{q}{\omega}}
          {\judgeEqA{q}{p}{\omega}}
\and
\inferrule*[]
          {\judgeEqA{p}{q}{\omega} \\ \judgeEqA{q}{r}{\omega}}
          {\judgeEqA{p}{r}{\omega}}
\and
\inferrule*[]
          {\judgeA{(\fun{x}{\omega}{p})\;q}{\omega'}}
          {\judgeEqA{(\fun{x}{\omega}{p})\;q}{[q/x]p}{\omega'}}
\and
\inferrule*[]
          {\judgeEqA[\Delta, x:\omega]{p\;x}{p'\;x}{\omega'}}
          {\judgeEqA{\fun{x}{\omega}{p}}{\fun{x}{\omega}{p'}}{\omega \To \omega'}}
\and 
\inferrule*[]
          {\judgeEqA{p}{p'}{\omega \To \omega'} \\
           \judgeEqA{q}{q'}{\omega}}
          {\judgeEqA{p\;q}{p'\;q'}{\omega'}}
\and
\inferrule*[]
          {\judgeKeq{\tau}{\tau'}{\kappa}}
          {\judgeEqA{\tau}{\tau'}{\kappa}}
\and
\inferrule*[]
          {\judgeEq{\Gamma}{e}{e'}{A}}
          {\judgeEqA{e}{e'}{A}}
\and 
\inferrule*[]
          {\validP{p \iff q}}
          {\judgeEqA{p}{q}{\assert}}
\and
\inferrule*[]
          {\judgeEqA{p}{q}{\omega} \\ \judgeSortEq{\omega}{\omega'}}
          {\judgeEqA{p}{q}{\omega'}}
\end{mathpar}
\caption{Equality Judgment for Assertions}
\label{assertion-equality}  
\end{figure}


My program logic consists of three judgments:

\begin{enumerate}
\item $\validP{p}$, which asserts that a proposition $p$ is valid.

\item $\validS{S}$, which asserts that a specification $S$ is valid.

\item $\judgeEqA{p}{q}{\omega}$, which asserts that $p$ and $q$ are validly equal.
\end{enumerate}
%

\noindent The semantics of these three judgments is given as follows:
\begin{enumerate}
\item An assertion $\judgeP{\Delta}{p}{\assert}$ is valid, if and only
  if for all $\theta \in \interp{\theta}, \gamma \in
  \interp{\judgectx{\Theta}{\Gamma}}\theta$, and $\delta \in
  \interp{\judgeACtx{\Delta}}\theta$, we have
  $\interp{\judgeP{\Delta}{p}{\assert}}\;\theta\;\gamma\;\delta = \top$.

\item Similarly, a specification $\judgeS{S}$ is valid if and only
if, for all $\theta \in \interp{\theta}, \gamma \in
  \interp{\judgectx{\Theta}{\Gamma}}\theta$, and $\delta \in
  \interp{\judgeACtx{\Delta}}\theta$, we have
$\interp{\judgeS{S}}\;\delta = \top$.

\item Finally, two assertion terms $\judgeA{p}{\omega}$ and
$\judgeA{q}{\omega}$ are validly equal, if and only if for all 
$\theta \in \interp{\theta}, \gamma \in
  \interp{\judgectx{\Theta}{\Gamma}}\theta$, and $\delta \in
  \interp{\judgeACtx{\Delta}}\theta$, we have that
$\interp{\judgeP{\Delta}{p}{\assert}}\;\delta = \interp{\judgeP{\Delta}{p}{\assert}}\;\delta$
\end{enumerate}

So this says that for any assignment of the free variables, a valid
assertion $p$ must be true, and similarly a valid specification $S$
must be true. Likewise, two syntactic terms $p$ and $q$ are validly
equal if their interpretations are equal under all environments. 

The program logic consists of a set of three mutually-recursive
judgments for deriving valid assertions, specifications, and
equalities. In Figure~\ref{spec-logic-axioms-basic}, I give the
primitive rules for deriving valid specifications of commands, and
Figure~\ref{spec-logic-axioms-structural}, I give a collection of
structural axioms.  In Figure~\ref{assertion-logic-axioms}, I give
some of the rules for deriving valid assertions, and in
Figure~\ref{assertion-equality}, I give rules for deriving equalities
between terms.

In Figure~\ref{spec-logic-axioms-basic}, the \textsc{AxEquiv1} and
\textsc{AxEquiv2} axioms assert the equivalence of Hoare triples over
commands and monadic expressions.  The \textsc{AxReturn} axiom asserts
that when we return a value $e$, we can strengthen the postcondition
with the assertion that the return value is $e$. The \textsc{AxAssign}
axiom asserts that if $e$ points to something in the precondition, the
command $e := e'$ ensures that in the postcondition $e \pointsto
e'$. The \textsc{AxAlloc} axiom asserts that allocating a new
reference $\newref{A}{e}$ will allocate a new pointer which is the
return value $a$, and that $a \pointsto e$ will be star'd onto the
postcondition. The \textsc{AxDeref} rule asserts that if $e \pointsto
e'$ in the precondition, then in the postcondition $e \pointsto e'$
will continue to hold, and that the return value $a = e'$.

The \textsc{AxBind} rule is the sequential composition rule of this
logic.  Because of the monadic nature of our programming language, we
can name and bind intermediate results, but of course there is a side-condition
to ensure that variables do not escape their scopes. 

Finally the \textsc{AxFix} rule is a fixed point induction rule for
this calculus. As in LCF, this rule looks like an induction without a
base case, which makes sense since this program logic is a partial
correctness calculus. This rule generalizes to all the pointed types,
but the syntactic overhead for stating the rules gets higher as the
types get larger.

In Figure~\ref{spec-logic-axioms-structural}, the \textsc{AxExtract}
rule takes a pure consequence of a precondition, and lifts it to
hypothetical assertion of the validity of an assertion. The intuition
for this rule is that to show the Hoare triple, we must assume $p$,
and so this means we might as well assume $r$ generally while proving
this triple. Conversely, The \textsc{AxEmbed} rule says that if we
have assumed the validity of an assertion, it does no harm to assume
it while proving a Hoare triple. The \textsc{AxUseValid} axiom states
that if we know that the assertion $\validprop{S}$ is valid, then we
may as well assume that $S$ is valid, and the \textsc{AxEmbedAssert}
says that valid assertions can be embedded in specifications. 

The \textsc{AxEquality} rule lets us rewrite programs using equational
reasoning, and the \textsc{AxForgetEx} axiom lets us drop existentials
from preconditions. The \textsc{AxConsequence} rule is just the rule
of consequence, and the \textsc{AxDisjunction} rule is just the rule
of disjunction, both familiar from Hoare logic. However, it is worth
pointing out that my language does \emph{not} validate the rule of
conjunction, as a consequence of having a language with a continuation
semantics.

Finally, the \textsc{AxFrame} schema gives the frame rule. My logic
supports the higher-order frame rule, and so we need to define a
syntactic frame operator $\Frame{S}{r}$ to act on arbitrary
specifications.
\begin{displaymath}
  \begin{array}{lcl}
    \Frame{\spec{p}{c}{a:A}{q}}{r}    & = & \spec{p * r}{c}{a:A}{q * r} \\
    \Frame{\mspec{p}{c}{a:A}{q}}{r}   & = & \mspec{p * r}{c}{a:A}{q * r} \\
    \Frame{\setof{p}}{r}              & = & \setof{p} \\
    \Frame{(S_1 \specand S_2)}{r}      & = & \Frame{S_1}{r} \specand \Frame{S_2}{r} \\
    \Frame{(S_1 \specor S_2)}{r}       & = & \Frame{S_1}{r} \specor \Frame{S_2}{r} \\
    \Frame{(S_1 \specimp S_2)}{r}      & = & \Frame{S_1}{r} \specimp \Frame{S_2}{r} \\
    \Frame{(\forall x:\omega.\; S)}{r} & = & \forall x:\omega.\; (\Frame{S}{r}) \\
    \Frame{(\exists x:\omega.\; S)}{r} & = & \exists x:\omega.\; (\Frame{S}{r}) \\
  \end{array}
\end{displaymath}
This is just the familiar action of the frame rule on Hoare triples. It
does nothing to the validity assertion $\setof{p}$, and distributes over all 
the other connectives. 

Framing is well-defined, and corresponds precisely to the semantic frame rule
we considered earlier in the chapter. 

\begin{prop}{(Syntactic Well-Formedness of Frame Operator)}
If $\judgeS{S}$ and $\judgeA{p}{\assert}$, then
we define $\judgeS{\Frame{S}{p}}$.  
\end{prop}
\begin{proof}
  By structural induction on specifications.
\end{proof}

More interesting than the syntactic well-formedness of the frame
operator is its semantic well-formedness. 

\begin{lemma}{(Syntactic Framing is Semantic Framing)}
If $\judgeS{S}$ and $\judgeA{r}{\assert}$, then for suitably typed $\theta, \gamma$ and $\delta$,
$\interp{\judgeS{\Frame{S}{r}}}\;\theta\;\gamma\;\delta$ equals  \\
$\Frame{\interp{\judgeS{S}}\;\theta\;\gamma\;\delta}{\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta}.$ 


\end{lemma}
\begin{proof}
  The proof is at the end of the chapter.
\end{proof}\\

The distinctive axioms of the assertion logic are far fewer. In
Figure~\ref{assertion-logic-axioms}, I give only three rules tailored
to this particular program logic. One for embedding specifications in
assertions, another for extracting assertions out of specifications,
and the last says that equality derivations entail equality
assertions. All the other rules are just the axioms of higher-order
separation logic.

Likewise, the valid equality judgment in
Figure~\ref{assertion-equality} is fairly minimal: it contains the
$\beta$ and $\eta$ rules for functions, as well as inheriting the
equality judgments for types and terms.

With all the buildup so far, it is easy to prove the following soundness
theorem:

\begin{theorem}{(Soundness of the Program Logic)}
  \begin{enumerate}
  \item If $\validP{p}$, then $\judgeA{p}{\assert}$ is valid.

  \item If $\validS{S}$, the $\judgeS{S}$ is valid.

  \item If $\judgeEqA{p}{q}{\omega}$, then $p$ and $q$ are validly equal.
  \end{enumerate}
\end{theorem}

\begin{proof}
  The proof of these three theorems follows from a mutual structural
  induction.  The soundness of each atomic rule for the two validity
  judgments is proven in the next section. The soundness of the rules
  for equality are a consequence of the equality rules we have already
  proven, and the cartesian closure of Set.  
\end{proof}

\section{Related Work}

There are two immediate predecessors to the proof system in this
dissertation. 

First, there is the work of Reynolds on specification logic for
Algol~\cite{spec-logic}. Idealized Algol~\cite{idealized-algol}
combines a call-by-name functional language, together with a type of
imperative computations whose operations correspond to the
while-language (i.e., it does not have higher-order store). This
stratification ensures that Algol features a powerful equational
theory which validates both the $\beta$- and $\eta$-rules of the
lambda-calculus. 

Specification logic extends Hoare logic~\cite{hoare-logic} to deal
with these new features, by viewing Hoare triples as the atomic
propositions of a first-order logic of specifications. Then, the user
of the logic can specify the behavior of a higher-order function using
an implications over triples, using the hypothesis of an implication
to specify the behavior of arguments of command type. In short,
specification logic can be viewed as a synthesis of LCF~\cite{lcf} with
  Hoare logic.

One of the motivations for the language design in my dissertation was
to see if the analogy between the computation type in Algol and the
monadic type discipline could be extended to a full higher-order
programming language, with features like higher-order store. This has
worked fantastically well. The semantics of the logic of this
dissertation is (suprisingly) \emph{simpler} than original
specification logic, even though the programming language itself is a
much more complex one than idealized Algol.

In particular, one of the main sources of complexity in usages of
specification logic have simply vanished from this logic. Algol has
assignable variables (like C or Java, though of course this reverses
the chronology), and so specification logic had to account for their
update with assertions about so-called ``good variable''
conditions. Since ML-like languages do not have assignable variables,
this means that all aliasing is confined to the heap. As a result, the
entire machinery of good variables is simply absent from my system.
So all aliasing and interference is confined to the heap, and
separation logic works quite well for specifying and reasoning about
this interference.

The other line of work I make use is on algebraic models of separation
logic. I give a very concrete model of separation logic in this
chapter, and am able to interpret higher-order quantification due to
the fact that the lattice of propositions is complete. This is
probably best understood as an instantiation of Biering~\emph{et
  al.}'s hyperdoctrine model of higher-order separation
logic. Likewise, my semantic domain for specifications makes use of
the techniques introduced by Birkedal and Yang~\cite{birkedal-yang} to
model higher-order frame rules.

Happily, though, most of this machinery stays ``under the hood'' to
ensure that the logic looks simple to the user.  As an example of this
phenomenon, we use TT-closure~\cite{tt-closure} to force the
admissibility of Hoare triples. This lets us give a simple rule for
fixed-point induction, without having to specify conditions on
admissible predicates (which is especially problematic in a setting
with predicate variables).

Finally, nested triples are very useful for specifying the properties
of higher-order programs: it is very useful to be able put the
specification of the contents of a reference into an assertion.  In
this chapter, I have given a ``cheap and cheerful'' embedding of
assertions in specifications and vice-versa, become true
specifications. This approach has the virtues of first, being very
technically easy to implement, and second, sufficient for all of the
examples I have considered.

However, more sophisticated approaches are certainly
possible. \citet{nested-hoare-triples} describe how to unify the
assertion and specification languages into a single logic.  This
offers the technical benefit that it extends the power of the
higher-order frame rule by letting it operate in a hereditary way, to
act on nested triples contained within assertions. In contrast, the
frame rule I give stops at the boundary of an assertion.

\subsection{Other Program Logics}

\subsubsection{Parkinson's Separation Logic for Java}

Parkinson developed a version of separation logic for Java in his
doctoral dissertation~\cite{parkinson-thesis}. His logic does not
feature a sophisticated specification logic; instead, he tries to use
the traditional notion of behavioral
subtyping~\cite{behavioral-subtyping} in order to deviate less
dramatically from the standard syntax of Hoare logic. However, strict
behavioral subtyping is very restrictive --- it essentially forces an
object-oriented program to ``look like'' a first-order program --- and
many object-oriented idioms (i.e., which correspond to higher-order
programming patterns) cannot be specified or proven correct in this 
framework 

Parkinson recovers flexibility through the use of a very clever
non-standard model of Hoare logic. The idea, described in Parkinson
and Bierman~\cite{parkinson-bierman-05}, is to admit a form of
second-order existential quantification, with a very unusual semantic
interpretation. Their ``abstract predicate families'' are predicates
defined on objects, whose definition varies according to the
\emph{concrete} class of the predicate. That is, their abstract
predicates ``dynamically dispatch'' to different definitions,
depending on the class of the object indexing the predicate. As a
result, they can re-use the proof rules of behavioral subtyping, even
though different classes can be given entirely different invariants.

While this is clearly a very natural idea for the specification of
object-oriented programs, I think that a richer language of
specifications and a more conventional interpretation of existentials
and universals is likely to be desirable in practice. Modern OO
languages like C\# and Scala also contain support for first-class
functions, which means that program logics will need features to
support reasoning about higher-order programs.

\subsubsection{Hoare Type Theory}

Nanevski, Morisett and Birkedal have developed Hoare Type
Theory~\cite{htt, nanevski08}, which is an elegant and sophisticated
dependently-typed functional language that, like our system, uses a
monadic discipline to control effects.  Unlike our work, HTT takes
advantage of type dependency to directly integrate specifications into
the types of computation terms.

Nanevski, Ahmed, Morisett and Birkedal~\cite{abstract-htt} have
proposed using the existential quantification of their type theory to
hide data representations, giving examples such as a malloc/free style
memory allocator. \citet{nanevski-victor-10} also give
a proof of a modern congruence closure algorithm, illustrating that
this system can be used to verify some of the most complex imperative
algorithms known.

My sense is that this line of work represents the future of the design
of high-level imperative programming languages, but the particular
choices made in HTT's design have some shortcomings which make a
direct comparison with my own work somewhat more challenging than it
should be.

In particular, HTT uses an indexed family of monads to represent
computations.  That is, a computation has a type $e :
\spec{P}{-}{a:A}{Q(a)}$, where $P$ and $Q$ are predicates on the
heap. This means that higher-order imperative programs may need to
refer to terms of computation type in their pre- and post-conditions.
In the original formulation of HTT, which is predicative, this causes
size issues to arise which can make writing higher-order imperative
programs difficult, since any code mentioned in the indexes has to be
at a lower universe level than the code being verified.

This difficulty has been overcome by Petersen~\emph{et al.}, who give
an impredicative model of Hoare Type Theory. However, Svendsen
[personal communication] says that in an impredicative setting, the
weaker elimination rules for impredicative existentials means that
proofs involving higher-order imperative code become more difficult to
do. (This was discovered during an attempt to port the example program
in Chapter 6 to HTT.)

These issues simply do not arise in my system, since specifications
are kept strictly separate from types. This suggests that an
interesting future direction would be to study a version of Hoare Type
Theory in which there is an ordinary monadic type of computations,
together with a predicates on terms of monadic type which equip it
with pre- and post-conditions.

\subsubsection{Regional Logic and Ownership}

In addition to systems based on separation, there is also a line of
research based on the concept of object invariants and ownership.  The
Java modeling language (JML)~\cite{jml} and the Boogie
methodology~\cite{boogie} are two of the most prominent systems based
on this research stream. In Boogie, each object tracks its owner
object with a ghost field, and the ownership discipline enforces that
the heap have a tree structure. This allows the calculation of frame
properties without explosions due to aliasing, even though the
specification language remains ordinary first-order
logic. \citet{banerjee-naumann-regions} give a logic, which they name
``regional logic'', which formalizes these ideas in a small core logic
more tractable than industrial-strength systems like JML or Boogie.

One of the most interesting features of this line of work is that
\citet{banerjee-naumann-rep} were able to use an ownership discipline to
prove a representation independence (i.e., relational parametricity)
result for Java-like programs.  This is something that neither my
system, nor any of the other ones described earlier is capable of.
The equality relation I use is simply the equality inherited from the
(highly non-abstract) denotational semantics I give.



\section{Correctness Proofs}

\subsection{Substitution Theorems}

\begin{lemma*}{(Substitution for Terms and Specifications)}
\begin{enumerate}
\item Suppose $\judgeWK{\tau}{\kappa}$.
  \begin{enumerate}
  \item If $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\omega}$, 
        then 
        \begin{enumerate}
        \item $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{{[\tau/\alpha]}\omega}$
        \item $\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{{[\tau/\alpha]}\omega}}\;\theta\,\gamma\,\delta$ equals \\
          $\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma, \Delta]{p}{\omega}}\;(\theta,\interp{\judgeWK{\tau}{\kappa}}\;\theta)\,\gamma\,\delta$
        \end{enumerate}
  \item If $\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{S}$, 
        then 
        \begin{enumerate}
        \item $\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}S}$
        \item $\interp{\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}S}}\;\theta$ equals \\
              $\interp{\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{S}}(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)$
        \end{enumerate}
  \end{enumerate}
\item Suppose $\judgeE{\Gamma}{e}{A}$.
  \begin{enumerate}
  \item If $\judgeA[\Theta; \Gamma, x:A; \Delta]{p}{\omega}$, 
        then 
        \begin{enumerate}
        \item $\judgeA[\Theta; \Gamma; \Delta]{[e/x]p}{\omega}$, 
        \item $\interp{\judgeA[\Theta; \Gamma; \Delta]{[e/x]p}{\omega}}\;\theta\,\gamma\,\delta$ equals \\
              $\interp{\judgeA[\Theta; \Gamma, x:A; \Delta]{p}{\omega}}\;\theta\,(\gamma, \interp{\judgeE{\Gamma}{e}{A}}\;\theta\;\gamma)\,\delta$               
        \end{enumerate}
  \item If $\judgeS[\Theta; \Gamma, x:A; \Delta]{S}$, 
        then 
        \begin{enumerate}
        \item $\judgeS[\Theta; \Gamma; \Delta]{[e/x]S}$.
        \item $\interp{\judgeS[\Theta; \Gamma; \Delta]{[e/x]S}}\;\theta\,\gamma\,\delta$ equals \\
              $\interp{\judgeS[\Theta; \Gamma, x:A; \Delta]{S}}\;\theta\,(\gamma, \interp{\judgeE{\Gamma}{e}{A}}\;\theta\;\gamma)\,\delta$
        \end{enumerate}
  \end{enumerate}
\item Suppose $\judgeA{q}{\upsilon}$.
  \begin{enumerate}
  \item If $\judgeA[\Theta; \Gamma; \Delta, u:\upsilon]{p}{\omega}$, 
        then 
        \begin{enumerate}
          \item $\judgeA[\Theta; \Gamma; \Delta]{[q/u]p}{\omega}$
          \item $\interp{\judgeA[\Theta; \Gamma; \Delta]{[q/u]p}{\omega}}\;\theta\,\gamma\,\delta$ equals \\
                $\interp{\judgeA[\Theta; \Gamma; \Delta, u:\upsilon]{p}{\omega}}\;\theta\,\gamma\,(\delta, \interp{\judgeA{q}{\upsilon}}\;\theta\,\gamma\,\delta)$
        \end{enumerate}
      \item If $\judgeS[\Theta; \Gamma:A; \Delta, u:\upsilon]{S}$, 
        then 
        \begin{enumerate}
          \item $\judgeS[\Theta; \Gamma; \Delta]{[q/u]S}$ 
          \item $\interp{\judgeS[\Theta; \Gamma; \Delta]{[q/u]S}}\;\theta\,\gamma\,\delta$ equals \\
                $\interp{\judgeS[\Theta; \Gamma:A; \Delta, u:\upsilon]{S}}\;\theta\,\gamma\,(\delta, \interp{\judgeA{q}{\upsilon}}\;\theta\,\gamma\,\delta)$
        \end{enumerate}
  \end{enumerate}

\end{enumerate}
\end{lemma*}
\begin{proof}
First, assume $\judgeWK{\tau}{\kappa}$, and $\judgeA[\Theta, \alpha:\kappa; \Gamma;\Delta]{p}{\omega}$, and
$\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{S}$. 

Now, we proceed by mutual induction on the derivation of $p$ and $S$: 
\begin{enumerate}

\item Case \textsc{TType}: $\judgeA[\Theta, \alpha:\kappa; \Gamma;\Delta]{\tau'}{\kappa'}$

  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, we know $\judgectx{\Theta, \alpha:\kappa}{\Delta}$ \\
    \oo By inversion, we know $\judgectx{\Theta, \alpha:\kappa}{\Gamma}$ \\
    \oo By inversion, we know $\judgeWK[\Theta, \alpha:\kappa]{\tau'}{\kappa'}$ \\
    \oo By substitution, $\judgectx{\Theta}{{[\tau/\alpha]}\Delta}$ \\
    \oo By substitution, $\judgectx{\Theta}{{[\tau/\alpha]}\Gamma}$ \\
    \oo By substitution, $\judgeWK{{[\tau/\alpha]}\tau'}{\kappa'}$ \\
    \oo By rule, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma;{[\tau/\alpha]}\Delta]{{[\tau/\alpha]}\tau'}{\kappa'}$
  \end{tabbedproof}

  For semantics,     $\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma;{[\tau/\alpha]}\Delta]{{[\tau/\alpha]}\tau'}{\kappa'}}\;\theta\;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\interp{\judgeWK[\Theta]{{[\tau/\alpha]}\tau'}{\kappa'}}\;\theta}
          {Semantics}
    \eline{\interp{\judgeWK[\Theta,\alpha:\kappa]{\tau'}{\kappa'}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)}
          {Substitution thm}
    \eline{\interp{\judgeA[\Theta, \alpha:\kappa;\Gamma;\Theta]{\tau'}{\kappa'}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta}
          {Semantics}
  \end{eqnproof}
  The correctness of the application of $\gamma$ and $\delta$ follows from the equations for contexts
  under substitution. 

  \item Case \textsc{TExpr}: $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{e}{A}$

    First, the syntax:
    \begin{tabbedproof}
      \oo By inversion, we know $\judgectx{\Theta, \alpha:\kappa}{\Delta}$ \\
      \oo By inversion, we know $\judgeE[\Theta, \alpha:\kappa]{\Gamma}{e}{A}$ \\
      \oo By substitution, we know $\judgectx{\Theta}{{[\tau/\alpha]}\Delta}$ \\
      \oo By substitution, we know $\judgeE{{[\tau/\alpha]}\Gamma}{{[\tau/\alpha]}e}{{[\tau/\alpha]}A}$ \\
      \oo By rule, we know $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}e}{{[\tau/\alpha]}A}$
    \end{tabbedproof}

    For semantics, consider $\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}e}{{[\tau/\alpha]}A}}\;\theta\;\gamma\;\delta$
    \begin{eqnproof}
      \eline{\interp{\judgeE{{[\tau/\alpha]}\Gamma}{{[\tau/\alpha]}e}{{[\tau/\alpha]}A}}\;\theta\;\gamma}
            {Semantics}
      \eline{\interp{\judgeE{\Gamma}{e}{A}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma}
            {Substitution}
      \eline{\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{e}{A}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta}
            {Semantics}
    \end{eqnproof}
  The correctness of the application of $\gamma$ and $\delta$ follows from the equations for contexts
  under substitution. 

\item Case \textsc{THyp}: $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{u}{\upsilon}$

  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, we know $\judgectx{\Theta, \alpha:\kappa}{\Gamma}$\\
    \oo By inversion, we know $\judgectx{\Theta, \alpha:\kappa}{\Delta}$\\
    \oo By substitution, we know $\judgectx{\Theta}{{[\tau/\alpha]}\Gamma}$\\
    \oo By substitution, we know $\judgectx{\Theta}{{[\tau/\alpha]}\Delta}$\\
    \oo By rule, we know $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{u}{{[\tau/\alpha]}A}$\\
  \end{tabbedproof}

  Next, consider $\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{u}{{[\tau/\alpha]}A}}\;\theta\;\gamma\;\delta$\\
  \begin{eqnproof}
    \eline{\pi_u(\delta)}{Semantics}
    \eline{\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{u}{A}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta}
          {Semantics}
  \end{eqnproof}
  The correctness of the application of $\gamma$ and $\delta$ follows from the equations for contexts
  under substitution. 

\item Case \textsc{TAbs1}: $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{\pfun{u}{\upsilon'}{p}}{\upsilon' \To \upsilon}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta, u:\upsilon']{p}{\upsilon}$ \\
    \oo By induction, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta, u:{[\tau/\alpha]}\upsilon']{{[\tau/\alpha]}p}{{[\tau/\alpha]}\upsilon}$ \\
    \oo By rule, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{\pfun{u}{{[\tau/\alpha]}\upsilon'}{{[\tau/\alpha]}p}}{{[\tau/\alpha]}\upsilon' \To {[\tau/\alpha]}\upsilon}$ \\
    \oo By def of subst, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}(\pfun{u}{\upsilon'}{p})}{{[\tau/\alpha]}(\upsilon' \To \upsilon)}$ \\
  \end{tabbedproof}
  %
  For semantics, consider $\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}(\pfun{u}{\upsilon'}{p})}{{[\tau/\alpha]}(\upsilon' \To \upsilon)}}\;\theta\;\gamma\;\delta$ \\
  \begin{eqnproof}
    \eline{\semfun{v}{\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta, u:{[\tau/\alpha]}\upsilon']{{[\tau/\alpha]}p}{{[\tau/\alpha]}\upsilon}}\;\theta\;\gamma\;(\delta,v)}}
          {Semantics}
    \eline{\semfun{v}{\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta, u:\upsilon']{p}{\upsilon}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;(\delta,v)}}
          {Induction}
    \eline{\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{\pfun{u}{\upsilon'}{p}}{\upsilon' \To \upsilon}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta}
          {Semantics}
  \end{eqnproof}
  The correctness of the application of $\gamma$ and $\delta$ follows from the equations for contexts
  under substitution. 

\item Case \textsc{TAbs2}: $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{\pfun{x}{A}{p}}{A \To \upsilon}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa; \Gamma, x:A; \Delta]{p}{\upsilon}$ \\
    \oo By induction, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma, x:{[\tau/\alpha]}A; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{{[\tau/\alpha]}\upsilon}$ \\
    \oo By rule, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{\pfun{x}{{[\tau/\alpha]}A}{{[\tau/\alpha]}p}}{{[\tau/\alpha]}A \To {[\tau/\alpha]}\upsilon}$ \\
    \oo By def of subst, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}(\pfun{x}{A}{p})}{{[\tau/\alpha]}(A \To \upsilon)}$ \\
  \end{tabbedproof}
  %
  For semantics, consider $\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}(\pfun{x}{A}{p})}{{[\tau/\alpha]}(A \To \upsilon)}}\;\theta\;\gamma\;\delta$ \\
  \begin{eqnproof}
    \eline{\semfun{v}{\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma, x:{[\tau/\alpha]}A; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{{[\tau/\alpha]}\upsilon}}\;\theta\;(\gamma,v)\;\delta}}
          {Semantics}
    \eline{\semfun{v}{\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma, x:A; \Delta]{p}{\upsilon}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;(\gamma,v)\;\delta}}
          {Induction}
    \eline{\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{\pfun{x}{A}{p}}{A \To \upsilon}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta}
          {Semantics}
  \end{eqnproof}
  The correctness of the application of $\gamma$ and $\delta$ follows from the equations for contexts
  under substitution. 

\item Case \textsc{TAbs3}: $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{\pfun{\beta}{\kappa'}{p}}{\kappa' \To \upsilon}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa, \beta:\kappa'; \Gamma; \Delta]{p}{\upsilon}$ \\
    \oo By induction, $\judgeA[\Theta, \beta:\kappa'; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{{[\tau/\alpha]}\upsilon}$ \\
    \oo By rule, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{\pfun{\beta}{\kappa'}{{[\tau/\alpha]}p}}{\kappa' \To {[\tau/\alpha]}\upsilon}$ \\
    \oo By def of subst, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}(\pfun{\beta}{\kappa'}{p})}{{[\tau/\alpha]}(\kappa' \To \upsilon)}$ \\
  \end{tabbedproof}
  %
  For semantics, consider $\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}(\pfun{\beta}{\kappa'}{p})}{{[\tau/\alpha]}(\kappa' \To \upsilon)}}\;\theta\;\gamma\;\delta$ \\
  \begin{eqnproof}
    \eline{\semfun{\tau'}{\interp{\judgeA[\Theta, \beta:\kappa'; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{{[\tau/\alpha]}\upsilon}}\;(\theta,\tau')\;\gamma\;\delta}}
          {Semantics}
    \eline{\semfun{\tau'}{\interp{\judgeA[\Theta, \alpha:\kappa, \beta:\kappa'; \Gamma; \Delta]{p}{\upsilon}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta, \tau')\;\gamma\;\delta}}
          {Induction}
    \eline{\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{\pfun{\beta}{\kappa'}{p}}{\kappa' \To \upsilon}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta}
          {Semantics}
  \end{eqnproof}
  The correctness of the application of $\gamma$ and $\delta$ follows from the equations for contexts
  under substitution. We also silently permuted the context at the second step, and made use of the fact
  that $\beta$ is not free in $\Gamma$, $\Delta$ or $\tau$.

\item Case \textsc{TAbsAll}: $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{\pfunall{\beta}{\kappa'}{p}}{\forallsort{\beta}{\kappa'}{\upsilon}}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa, \beta:\kappa'; \Gamma; \Delta]{p}{\upsilon}$ \\
    \oo By induction, $\judgeA[\Theta, \beta:\kappa'; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{{[\tau/\alpha]}\upsilon}$ \\
    \oo By rule, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{\pfunall{\beta}{\kappa'}{{[\tau/\alpha]}p}}{\forallsort{\beta}{\kappa'}{{[\tau/\alpha]}\upsilon}}$ \\
    \oo By def of subst, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}(\pfunall{\beta}{\kappa'}{p})}{{[\tau/\alpha]}\forallsort{\beta}{\kappa'}{\upsilon}}$ \\
  \end{tabbedproof}
  %
  For semantics, consider $\interp{\judgeA[\Theta; 
                                           {[\tau/\alpha]}\Gamma; 
                                           {[\tau/\alpha]}\Delta]
                                          {{[\tau/\alpha]}(\pfun{\beta}{\kappa'}{p})}
                                          {{[\tau/\alpha]}(\forallsort{\beta}{\kappa'}{\upsilon})}}
                                  \;\theta\;\gamma\;\delta$ \\
  \begin{eqnproof}
    \eline{\semfun{\tau'}{\interp{\judgeA[\Theta, \beta:\kappa'; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{{[\tau/\alpha]}\upsilon}}\;(\theta,\tau')\;\gamma\;\delta}}
          {Semantics}
    \eline{\semfun{\tau'}{\interp{\judgeA[\Theta, \alpha:\kappa, \beta:\kappa'; \Gamma; \Delta]{p}{\upsilon}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta, \tau')\;\gamma\;\delta}}
          {Induction}
    \eline{\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{\pfun{\beta}{\kappa'}{p}}{\forallsort{\beta}{\kappa'}{\upsilon}}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta}
          {Semantics}
  \end{eqnproof}
  The correctness of the application of $\gamma$ and $\delta$ follows from the equations for contexts
  under substitution. We also silently permuted the context at the second step, and made use of the fact
  that $\beta$ is not free in $\Gamma$ or $\Delta$.

\item Case \textsc{TApp}: $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p\;q}{\upsilon}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\omega \To \upsilon}$\\
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{q}{\omega}$\\
    \oo By induction, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{{[\tau/\alpha]}(\omega \To \upsilon)}$\\
    \oo By induction, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}q}{{[\tau/\alpha]}\omega}$\\
    \oo By rule, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p\;{[\tau/\alpha]}q}{{[\tau/\alpha]}\upsilon}$\\
    \oo By subst def, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}(p\;q)}{{[\tau/\alpha]}\upsilon}$\\
  \end{tabbedproof}

  For semantics, consider $\interp{\judgeA[\Theta; 
                                          {[\tau/\alpha]}\Gamma; 
                                          {[\tau/\alpha]}\Delta]
                                          {{[\tau/\alpha]}(p\;q)}
                                          {{[\tau/\alpha]}\upsilon}}
                                 \;\theta\;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\begin{array}{l}
             (\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]
                             {{[\tau/\alpha]}p}
                             {{[\tau/\alpha]}(\omega \To \upsilon)}}
                     \;\theta\;\gamma\;\delta) \\
             \;\;(\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]
                                 {{[\tau/\alpha]}q}
                                 {{[\tau/\alpha]}\omega}}
                         \;\theta\;\gamma\;\delta) 
      \end{array}}
    {Semantics}
    \eline{\begin{array}{l}
             (\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\omega \To \upsilon}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta) \\
             \;\;(\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{q}{\omega}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta) 
      \end{array}}
    {Induction}
    \eline{\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p\;q}{\upsilon}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta}
          {Semantics}
  \end{eqnproof}


\item Case \textsc{TAppAll}: $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p\;[\tau']}{[\tau'/\beta]\upsilon}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\forallsort{\beta}{\kappa'}{\upsilon}}$\\
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{\tau'}{\kappa'}$\\
    \oo By induction, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{{[\tau/\alpha]}(\forallsort{\beta}{\kappa'}{\upsilon})}$\\
    \oo By induction, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}\tau'}{\kappa'}$\\
    \oo By rule, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p\;{[\tau/\alpha]}[\tau']}{{[\tau/\alpha, [\tau/\alpha]\tau'/\beta]}\upsilon}$\\
    \oo By subst def, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}(p\;[\tau'])}{{[\tau/\alpha, [\tau/\alpha]\tau'/\beta]}\upsilon}$\\
  \end{tabbedproof}

  For semantics, consider $\interp{\judgeA[\Theta;  
                                           {[\tau/\alpha]}\Gamma; 
                                           {[\tau/\alpha]}\Delta]
                                          {{[\tau/\alpha]}(p\;[\tau'])}
                                          {{[\tau/\alpha]}[\tau'/\beta]\upsilon}}\;\theta\;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\begin{array}{l}
             (\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{{[\tau/\alpha]}(\forallsort{\beta}{\kappa'}{\upsilon})}}\;\theta\;\gamma\;\delta) \\
             \;\;(\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}\tau'}{\kappa'}}\;\theta\;\gamma\;\delta) 
      \end{array}}
    {Semantics}
    \eline{\begin{array}{l}
             (\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\forallsort{\beta}{\kappa'}{\upsilon}}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta) \\
             \;\;(\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{\tau'}{\kappa'}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta) 
      \end{array}}
    {Induction}
    \eline{\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p\;[\tau']}{[\tau'/\beta]\upsilon}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta}
          {Semantics}
  \end{eqnproof}


\item Case \textsc{TConst}:

  First, the syntax: 
  \begin{tabbedproof}
    \oo By inversion, $\judgectx{\Theta, \alpha:\kappa}{\Gamma}$ \\
    \oo By inversion, $\judgectx{\Theta, \alpha:\kappa}{\Delta}$ \\
    \oo By substitution, $\judgectx{\Theta}{[\tau/\alpha]\Gamma}$ \\
    \oo By substitution, $\judgectx{\Theta}{[\tau/\alpha]\Delta}$ \\
    \oo By rule, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{c}{\assert}$
  \end{tabbedproof}

  For semantics consider $\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{c}{\assert}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\interp{c}^0}{Semantics}
    \eline{\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{c}{\assert}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta}
          {Semantics}
  \end{eqnproof}
  The correctness of the application of $\gamma$ and $\delta$ follows from the equations for contexts
  under substitution. 

\item Case \textsc{TBinary}: $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p \oplus q}{\assert}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\assert}$\\
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{q}{\assert}$\\
    \oo By induction, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{\assert}$\\
    \oo By induction, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}q}{\assert}$\\
    \oo By rule, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p \oplus {[\tau/\alpha]}q}{{[\tau/\alpha]}\assert}$\\
    \oo By subst def, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}(p \oplus q)}{\assert}$\\
  \end{tabbedproof}

  For semantics, consider $\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}(p \oplus q)}{\assert}}\;\theta\;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\begin{array}{l}
             (\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{\assert}}\;\theta\;\gamma\;\delta) \;\interp{\oplus}^2 \\
             \;\;(\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}q}{\assert}}\;\theta\;\gamma\;\delta) 
      \end{array}}
    {Semantics}
    \eline{\begin{array}{l}
             (\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\assert}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta) \interp{\oplus}^2 \\
             \;\;(\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{q}{\assert}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta) 
      \end{array}}
    {Induction}
    \eline{\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p \oplus q}{\assert}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{TQuantify1}: $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{Q u:\upsilon.\;p}{\assert}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta, u:\upsilon]{p}{\assert}$ \\
    \oo By induction, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta, u:{[\tau/\alpha]}\upsilon]{{[\tau/\alpha]}p}{\assert}$ \\
    \oo By rule, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]
                         {Q u:{[\tau/\alpha]}\upsilon.\;{[\tau/\alpha]}p}{\assert}$ \\
    \oo By def of subst, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]
                                 {{[\tau/\alpha]}(Q u:\upsilon.\;p)}{\assert}$ 
  \end{tabbedproof}

  For semantics, consider
  $\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]
                  {{[\tau/\alpha]}(Q u:\upsilon.\;p)}{\assert}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\begin{array}{l}
            \interp{Q}_{v \in \interp{\judgeSort{{[\tau/\alpha]}\upsilon}}\;\theta} \\
            \;\;\interp{\judgeA[\Theta;{[\tau/\alpha]}\Gamma;{[\tau/\alpha]}\Delta, u:{[\tau/\alpha]}\upsilon]{{[\tau/\alpha]}p}{\assert}}\;\theta\,\gamma\,(\delta,v)
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
            \interp{Q}_{v \in \interp{\judgeSort[\Theta, \alpha:\kappa]{\upsilon}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)} \\
            \;\;\interp{\judgeA[\Theta, \alpha:\kappa;\Gamma;\Delta, u:\upsilon]{p}{\assert}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\,\gamma\,(\delta,v)
           \end{array}}
          {Induction}
    \eline{\interp{\judgeA[\Theta, \alpha:\kappa;\Gamma;\Delta]{Q u:\upsilon.\;p}{\assert}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\,\gamma\,\delta}
          {Semantics}
  \end{eqnproof}

  The correctness of the application of $\gamma$ and $\delta$ follows from the equations for
  contexts under substitution.


\item Case \textsc{TQuantify2}: $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{Q x:A.\;p}{\assert}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa; \Gamma, x:A; \Delta]{p}{\assert}$ \\
    \oo By induction, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma, x:{[\tau/\alpha]}A; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{\assert}$ \\
    \oo By rule, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]
                         {Q x:{[\tau/\alpha]}A.\;{[\tau/\alpha]}p}{\assert}$ \\
    \oo By def of subst, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]
                                 {{[\tau/\alpha]}(Q x:A.\;p)}{\assert}$ 
  \end{tabbedproof}

  For semantics, consider
  $\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]
                  {{[\tau/\alpha]}(Q x:A.\;p)}{\assert}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\begin{array}{l}
            \interp{Q}_{v \in \interp{\judgeSort{{[\tau/\alpha]}A}}\;\theta} \\
            \;\;\interp{\judgeA[\Theta;{[\tau/\alpha]}\Gamma, x:{[\tau/\alpha]}A;{[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{\assert}}\;\theta\,(\gamma,v)\,\delta
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
            \interp{Q}_{v \in \interp{\judgeSort[\Theta, \alpha:\kappa]{A}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)} \\
            \;\;\interp{\judgeA[\Theta, \alpha:\kappa;\Gamma, x:A;\Delta]{p}{\assert}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\,(\gamma,v)\,\delta
           \end{array}}
          {Induction}
    \eline{\interp{\judgeA[\Theta, \alpha:\kappa;\Gamma;\Delta]{Q x:A.\;p}{\assert}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\,\gamma\,\delta}
          {Semantics}
  \end{eqnproof}

  The correctness of the application of $\gamma$ and $\delta$ follows from the equations for
  contexts under substitution.

\item Case \textsc{TQuantify3}: $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{Q \beta:\kappa'.\;p}{\assert}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa, \beta:\kappa'; \Gamma; \Delta]{p}{\assert}$ \\
    \oo By induction, $\judgeA[\Theta, \beta:\kappa'; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{\assert}$ \\
    \oo By rule, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]
                         {Q \beta:\kappa'.\;{[\tau/\alpha]}p}{\assert}$ \\
    \oo By def of subst, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]
                                 {{[\tau/\alpha]}(Q \beta:\kappa'.\;p)}{\assert}$ 
  \end{tabbedproof}

  For semantics, consider
  $\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]
                  {{[\tau/\alpha]}(Q \beta:\kappa'.\;p)}{\assert}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\begin{array}{l}
            \interp{Q}_{\tau' \in \interp{\judgeSort{\kappa'}}\;\theta} \\
            \;\;\interp{\judgeA[\Theta, \beta:\kappa';{[\tau/\alpha]}\Gamma;{[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{\assert}}\;(\theta,\tau')\,\gamma\,\delta
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
            \interp{Q}_{\tau' \in \interp{\judgeSort[\Theta, \alpha:\kappa]{\kappa'}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)} \\
            \;\;\interp{\judgeA[\Theta, \alpha:\kappa, \beta:\kappa';\Gamma;\Delta]{p}{\assert}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta, \tau')\,\gamma\,(\delta,v)
           \end{array}}
          {Induction}
    \eline{\interp{\judgeA[\Theta;\Gamma;\Delta]{Q \beta:\kappa'.\;p}{\assert}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\,\gamma\,\delta}
          {Semantics}
  \end{eqnproof}

  The correctness of the application of $\gamma$ and $\delta$ follows from the equations for
  contexts under substitution. We also silently permute the context in the second line.

\item Case \textsc{TEqual}: $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p =_\omega q}{\assert}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\omega}$ \\
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{q}{\omega}$ \\
    \oo By inversion, $\judgeSort[\Theta, \alpha:\kappa]{\omega}$ \\
    \oo By induction, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{{[\tau/\alpha]}\omega}$ \\
    \oo By induction, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}q}{{[\tau/\alpha]}\omega}$ \\
    \oo By substitution, $\judgeSort[\Theta]{{[\tau/\alpha]}\omega}$ \\
    \oo By rule, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}(p =_\omega q)}{\assert}$
  \end{tabbedproof}

  For the semantics, consider $\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}(p =_\omega q)}{\assert}}\;\theta\;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\mbox{if }\interp{{[\tau/\alpha]}p}\theta\;\gamma\;\delta = \interp{{[\tau/\alpha]}q}\theta\;\gamma\;\delta\mbox{ then }\top \mbox{ else } \bot}
          {Semantics}
    \eline{\mbox{if }\interp{p}(\theta, \interp{\judgeWK{\tau}{\kappa}}\theta)\;\gamma\;\delta = \interp{q}(\theta, \interp{\judgeWK{\tau}{\kappa}}\theta)\;\gamma\;\delta\mbox{ then }\top \mbox{ else } \bot}
          {Induction}
    \eline{\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{(p =_\omega q)}{\assert}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\theta)\;\gamma\;\delta}
          {Semantics}
  \end{eqnproof}
  The correctness of the application of $\gamma$ and $\delta$ follows from the equations for
  contexts under substitution. We also need to use the equality of sorts under substitution to
  justify forming the equality in the third line. 

\item Case \textsc{TPointsto}: $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{e \pointsto_A e'}{\assert}$

  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{e}{\reftype{A}}$ \\
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{e'}{A}$ \\
    \oo By induction, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}e}{{[\tau/\alpha]}\reftype{A}}$ \\
    \oo By induction, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}e'}{{[\tau/\alpha]}A}$ \\
    \oo By rule, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}(e \pointsto_A e')}{\assert}$
  \end{tabbedproof}

  For the semantics, consider $\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}(e \pointsto_A e')}{\assert}}\;\theta\;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\begin{array}{l}
           \interp{\judgeE[\Theta]{{[\tau/\alpha]}\Gamma}{{[\tau/\alpha]}e}{{[\tau/\alpha]}\reftype{A}}}\;\theta\;\gamma \\ 
           \pointsto \\
           \interp{\judgeE[\Theta]{{[\tau/\alpha]}\Gamma}{{[\tau/\alpha]}e'}{{[\tau/\alpha]}A}}\;\theta\;\gamma 
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
           \interp{\judgeE[\Theta, \alpha:\kappa]{\Gamma}{e}{\reftype{A}}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma \\ 
           \pointsto \\
           \interp{\judgeE[\Theta, \alpha:\kappa]{\Gamma}{e'}{A}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma 
           \end{array}}
          {Induction}
    \eline{\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{e \pointsto_A e'}{\assert}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma }
          {Semantics}
  \end{eqnproof}
  The correctness of the application of $\gamma$ and $\delta$ follows from the equations for
  contexts under substitution. 

\item Case \textsc{TEqSort}: $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\omega}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeSortEq[\Theta, \alpha:\kappa]{\omega}{\omega'}$ \\
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\omega'}$ \\
    \oo By substitution, $\judgeSortEq{{[\tau/\alpha]}\omega}{{[\tau/\alpha]}\omega'}$ \\
    \oo By induction, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{{[\tau/\alpha]}\omega'}$ \\
    \oo By rule, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{{[\tau/\alpha]}\omega}$ \\
  \end{tabbedproof}

  For the semantics, consider $\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{{[\tau/\alpha]}\omega}}\;\theta\;\gamma\;\delta$ \\
  \begin{eqnproof}
    \eline{\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{{[\tau/\alpha]}\omega'}}\;\theta\;\gamma\;\delta}
          {Semantics}
    \eline{\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\omega'}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta}
          {Induction}
    \eline{\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\omega}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta}
          {Semantics}
  \end{eqnproof}
  The correctness of the application of $\gamma$ and $\delta$ follows from the equations for
  contexts under substitution. 

\item Case \textsc{TSpec}: $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{\validprop{S}}{\assert}$:
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{S}$ \\
    \oo By mutual induction $\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}S}$\\
    \oo By rule, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{\validprop{{[\tau/\alpha]}S}}{\assert}$
  \end{tabbedproof}

  For the semantics, consider $\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{\validprop{{[\tau/\alpha]}S}}{\assert}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\mbox{if } \interp{{[\tau/\alpha]}S}\;\theta\;\gamma\;\delta = \top \mbox{ then } \top \mbox{ else } \bot}
          {Semantics}
    \eline{\mbox{if } \interp{S}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta = \top \mbox{ then } \top \mbox{ else } \bot}
          {Induction}
    \eline{\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{\validprop{S}}{\assert}}\; (\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta}
          {Semantics}
  \end{eqnproof}
  The correctness of the application of $\gamma$ and $\delta$ follows from the equations for
  contexts under substitution. 

\item Case \textsc{SpecTriple}: $\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{\spec{p}{c}{a:A}{q}}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\assert}$ \\
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{\comp{c}}{\monad{A}}$ \\
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta, a:A]{q}{\assert}$ \\
    \oo By induction, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{\assert}$ \\
    \oo By induction, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}\comp{c}}{{[\tau/\alpha]}\monad{A}}$ \\
    \oo By induction, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta, {[\tau/\alpha]}a:A]{{[\tau/\alpha]}q}{\assert}$ \\
    \oo By rule, $\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}(\spec{p}{c}{a:A}{q})}$
  \end{tabbedproof}

  For the semantics, consider $\interp{\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}(\spec{p}{c}{a:A}{q})}}\;\theta;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\begin{array}{l}
           \{\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{p}{\assert}}\;\theta\;\gamma\;\delta\} \\
           \interp{\judgeC{{[\tau/\alpha]}\Gamma}{{[\tau/\alpha]}c}{A}}\;\theta\;\gamma\;\delta \\
           \{v.\;\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma, a:A; {[\tau/\alpha]}\Delta]{q}{\assert}}\;\theta\;(\gamma,v)\;\delta\} 
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
           \{\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\assert}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta\} \\
           \interp{\judgeC[\Theta, \alpha:\kappa]{\Gamma}{c}{A}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta \\
           \{v.\;\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma, a:A; \Delta]{q}{\assert}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;(\gamma,v)\;\delta\} 
           \end{array}}
          {Induction}
    \eline{\interp{\judgeS[\Theta; \Gamma; \Delta]{(\spec{p}{c}{a:A}{q})}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta}
          {Semantics}
  \end{eqnproof}
  The correctness of the application of $\gamma$ and $\delta$ follows from the equations for
  contexts under substitution. 

\item Case \textsc{SpecMTriple}: $\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{\mspec{p}{e}{a:A}{q}}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\assert}$ \\
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{e}{\monad{A}}$ \\
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta, a:A]{q}{\assert}$ \\
    \oo By induction, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{\assert}$ \\
    \oo By induction, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}e}{{[\tau/\alpha]}\monad{A}}$ \\
    \oo By induction, $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta, {[\tau/\alpha]}a:A]{{[\tau/\alpha]}q}{\assert}$ \\
    \oo By rule, $\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}(\mspec{p}{e}{a:A}{q})}$
  \end{tabbedproof}

  For the semantics, consider $\interp{\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}(\mspec{p}{e}{a:A}{q})}}\;\theta;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\begin{array}{l}
           \{\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{p}{\assert}}\;\theta\;\gamma\;\delta\} \\
           \interp{\judgeE{{[\tau/\alpha]}\Gamma}{{[\tau/\alpha]}e}{\monad{A}}}\;\theta\;\gamma\;\delta \\
           \{v.\;\interp{\judgeA[\Theta; {[\tau/\alpha]}\Gamma, a:A; {[\tau/\alpha]}\Delta]{q}{\assert}}\;\theta\;(\gamma,v)\;\delta\} 
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
           \{\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\assert}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta\} \\
           \interp{\judgeE[\Theta, \alpha:\kappa]{\Gamma}{e}{\monad{A}}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta \\
           \{v.\;\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma, a:A; \Delta]{q}{\assert}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;(\gamma,v)\;\delta\} 
           \end{array}}
          {Induction}
    \eline{\interp{\judgeS[\Theta; \Gamma; \Delta]{(\mspec{p}{e}{a:A}{q})}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta);\gamma\;\delta}
          {Semantics}
  \end{eqnproof}
  The correctness of the application of $\gamma$ and $\delta$ follows from the equations for
  contexts under substitution. 

\item Case \textsc{SpecQuantify1}: $\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{Q u:\upsilon.\;S}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta, u:\upsilon]{S}$ \\
    \oo By induction, $\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta, u:{[\tau/\alpha]}\upsilon]{{[\tau/\alpha]}S}$ \\
    \oo By rule, $\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]
                         {Q u:{[\tau/\alpha]}\upsilon.\;{[\tau/\alpha]}S}$ \\
    \oo By def of subst, $\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]
                                 {{[\tau/\alpha]}(Q u:\upsilon.\;S)}$ 
  \end{tabbedproof}

  For semantics, consider
  $\interp{\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]
                  {{[\tau/\alpha]}(Q u:\upsilon.\;S)}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\begin{array}{l}
            \interp{Q}_{v \in \interp{\judgeSort{{[\tau/\alpha]}\upsilon}}\;\theta} \\
            \;\;\interp{\judgeS[\Theta;{[\tau/\alpha]}\Gamma;{[\tau/\alpha]}\Delta, u:{[\tau/\alpha]}\upsilon]{{[\tau/\alpha]}S}}\;\theta\,\gamma\,(\delta,v)
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
            \interp{Q}_{v \in \interp{\judgeSort[\Theta, \alpha:\kappa]{\upsilon}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)} \\
            \;\;\interp{\judgeS[\Theta, \alpha:\kappa;\Gamma;\Delta, u:\upsilon]{S}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\,\gamma\,(\delta,v)
           \end{array}}
          {Induction}
    \eline{\interp{\judgeS[\Theta, \alpha:\kappa;\Gamma;\Delta]{Q u:\upsilon.\;S}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\,\gamma\,\delta}
          {Semantics}
  \end{eqnproof}

  The correctness of the application of $\gamma$ and $\delta$ follows from the equations for
  contexts under substitution.


\item Case \textsc{SpecQuantify2}: $\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{Q x:A.\;S}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeS[\Theta, \alpha:\kappa; \Gamma, x:A; \Delta]{S}$ \\
    \oo By induction, $\judgeS[\Theta; {[\tau/\alpha]}\Gamma, x:{[\tau/\alpha]}A; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}S}$ \\
    \oo By rule, $\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]
                         {Q x:{[\tau/\alpha]}A.\;{[\tau/\alpha]}S}$ \\
    \oo By def of subst, $\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]
                                 {{[\tau/\alpha]}(Q x:A.\;S)}$ 
  \end{tabbedproof}

  For semantics, consider
  $\interp{\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]
                  {{[\tau/\alpha]}(Q x:A.\;S)}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\begin{array}{l}
            \interp{Q}_{v \in \interp{\judgeSort{{[\tau/\alpha]}A}}\;\theta} \\
            \;\;\interp{\judgeS[\Theta;{[\tau/\alpha]}\Gamma, x:{[\tau/\alpha]}A;{[\tau/\alpha]}\Delta]{{[\tau/\alpha]}S}}\;\theta\,(\gamma,v)\,\delta
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
            \interp{Q}_{v \in \interp{\judgeSort[\Theta, \alpha:\kappa]{A}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)} \\
            \;\;\interp{\judgeS[\Theta, \alpha:\kappa;\Gamma, x:A;\Delta]{S}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\,(\gamma,v)\,\delta
           \end{array}}
          {Induction}
    \eline{\interp{\judgeS[\Theta, \alpha:\kappa;\Gamma;\Delta]{Q x:A.\;S}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\,\gamma\,\delta}
          {Semantics}
  \end{eqnproof}

  The correctness of the application of $\gamma$ and $\delta$ follows from the equations for
  contexts under substitution.

\item Case \textsc{SpecQuantify3}: $\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{Q \beta:\kappa'.\;S}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeS[\Theta, \alpha:\kappa, \beta:\kappa'; \Gamma; \Delta]{S}$ \\
    \oo By induction, $\judgeS[\Theta, \beta:\kappa'; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}S}$ \\
    \oo By rule, $\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]
                         {Q \beta:\kappa'.\;{[\tau/\alpha]}S}$ \\
    \oo By def of subst, $\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]
                                 {{[\tau/\alpha]}(Q \beta:\kappa'.\;S)}$ 
  \end{tabbedproof}

  For semantics, consider
  $\interp{\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]
                  {{[\tau/\alpha]}(Q \beta:\kappa'.\;S)}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\begin{array}{l}
            \interp{Q}_{\tau' \in \interp{\judgeSort{\kappa'}}\;\theta} \\
            \;\;\interp{\judgeS[\Theta, \beta:\kappa';{[\tau/\alpha]}\Gamma;{[\tau/\alpha]}\Delta]{{[\tau/\alpha]}S}}\;(\theta,\tau')\,\gamma\,\delta
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
            \interp{Q}_{\tau' \in \interp{\judgeSort[\Theta, \alpha:\kappa]{\kappa'}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)} \\
            \;\;\interp{\judgeS[\Theta, \alpha:\kappa, \beta:\kappa';\Gamma;\Delta]{S}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta, \tau')\,\gamma\,(\delta,v)
           \end{array}}
          {Induction}
    \eline{\interp{\judgeS[\Theta, \alpha:\kappa;\Gamma;\Delta]{Q \beta:\kappa'.\;S}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\,\gamma\,\delta}
          {Semantics}
  \end{eqnproof}

  The correctness of the application of $\gamma$ and $\delta$ follows from the equations for
  contexts under substitution. We also silently permute the context in the second line.

\item Case \textsc{SpecBinary}: $\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{S \oplus S'}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{S}$\\
    \oo By inversion, $\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{S'}$\\
    \oo By induction, $\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}S}$\\
    \oo By induction, $\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}S'}$\\
    \oo By rule, $\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}S \oplus {[\tau/\alpha]}S'}$\\
    \oo By subst def, $\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}(S \oplus S')}$\\
  \end{tabbedproof}

  For semantics, consider $\interp{\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}(S \oplus S')}}\;\theta\;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\begin{array}{l}
             (\interp{\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}S}}\;\theta\;\gamma\;\delta) \;\interp{\oplus} \\
             \;\;(\interp{\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}S'}}\;\theta\;\gamma\;\delta) 
      \end{array}}
    {Semantics}
    \eline{\begin{array}{l}
             (\interp{\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{S}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta) \interp{\oplus} \\
             \;\;(\interp{\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{S'}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta) 
      \end{array}}
    {Induction}
    \eline{\interp{\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{S \oplus S'}}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta}
          {Semantics}
  \end{eqnproof}
  The correctness of the application of $\gamma$ and $\delta$ follows from the equations for
  contexts under substitution. 

\item Case \textsc{TSpec}: $\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{\setof{p}}$:
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\assert}$ \\
    \oo By mutual induction $\judgeA[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{{[\tau/\alpha]}p}{\assert}$\\
    \oo By rule, $\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{\setof{{[\tau/\alpha]}p}}$
  \end{tabbedproof}

  For the semantics, consider $\interp{\judgeS[\Theta; {[\tau/\alpha]}\Gamma; {[\tau/\alpha]}\Delta]{\setof{{[\tau/\alpha]}p}}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\mbox{if } \interp{{[\tau/\alpha]}p}\;\theta\;\gamma\;\delta = \top \mbox{ then } \top \mbox{ else } \bot}
          {Semantics}
    \eline{\mbox{if } \interp{p}\;(\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta = \top \mbox{ then } \top \mbox{ else } \bot}
          {Induction}
    \eline{\interp{\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{\setof{p}}}\; (\theta, \interp{\judgeWK{\tau}{\kappa}}\;\theta)\;\gamma\;\delta}
          {Semantics}
  \end{eqnproof}
  The correctness of the application of $\gamma$ and $\delta$ follows from the equations for
  contexts under substitution. 
\end{enumerate}

\ \\

First, assume $\judgeE{\Gamma}{e''}{B}$, and $\judgeA[\Theta; \Gamma, y:B;\Delta]{p}{\omega}$, and
$\judgeS[\Theta; \Gamma, y:B; \Delta]{S}$. 

Now, we proceed by mutual induction on the derivation of $p$ and $S$: 
\begin{enumerate}

\item Case \textsc{TType}: $\judgeA[\Theta; \Gamma, y:B;\Delta]{\tau'}{\kappa'}$

  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, we know $\judgectx{\Theta}{\Delta}$ \\
    \oo By inversion, we know $\judgectx{\Theta}{\Gamma, y:B}$ \\
    \oo By inversion, we know $\judgeWK[\Theta]{\tau'}{\kappa'}$ \\
    \oo By inversion, we know $\judgectx{\Theta}{\Gamma}$ \\
    \oo By rule, $\judgeA[\Theta; \Gamma;\Delta]{\tau'}{\kappa'}$
  \end{tabbedproof}

  For semantics,  $\interp{\judgeA[\Theta; \Gamma; \Delta]{[e''/y]\tau'}{\kappa'}}\;\theta\;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\interp{\judgeWK[\Theta]{\tau'}{\kappa'}}\;\theta}
          {Semantics}
    \eline{\interp{\judgeA[\Theta;\Gamma, y:B;\Theta]{\tau'}{\kappa'}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta}
          {Semantics}
  \end{eqnproof}

  \item Case \textsc{TExpr}: $\judgeA[\Theta; \Gamma, y:B; \Delta]{e}{A}$

    First, the syntax:
    \begin{tabbedproof}
      \oo By inversion, we know $\judgectx{\Theta}{\Delta}$ \\
      \oo By inversion, we know $\judgeE{\Gamma, y:B}{e}{A}$ \\
      \oo By substitution, we know $\judgeE{\Gamma}{[e''/y]e}{A}$ \\
      \oo By rule, we know $\judgeA[\Theta; \Gamma; \Delta]{[e''/y]e}{A}$
    \end{tabbedproof}

    For semantics, consider $\interp{\judgeA[\Theta; \Gamma; \Delta]{[e''/y]e}{A}}\;\theta\;\gamma\;\delta$
    \begin{eqnproof}
      \eline{\interp{\judgeE{\Gamma}{[e''/y]e}{A}}\;\theta\;\gamma}
            {Semantics}
      \eline{\interp{\judgeE{\Gamma}{e}{A}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)}
            {Substitution}
      \eline{\interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{e}{A}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta}
            {Semantics}
    \end{eqnproof}

\item Case \textsc{THyp}: $\judgeA[\Theta; \Gamma, y:B; \Delta]{u}{\upsilon}$

  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, we know $\judgectx{\Theta}{\Gamma, y:B}$\\
    \oo By inversion, we know $\judgectx{\Theta}{\Delta}$\\
    \oo By inversion, we know $\judgectx{\Theta}{\Gamma}$\\
    \oo By rule, we know $\judgeA[\Theta; \Gamma; \Delta]{u}{A}$\\
    \oo Hence, we know $\judgeA[\Theta; \Gamma; \Delta]{[e''/y]u}{A}$\\
  \end{tabbedproof}

  Next, consider $\interp{\judgeA[\Theta; \Delta; \Gamma]{u}{A}}\;\theta\;\gamma\;\delta$\\
  \begin{eqnproof}
    \eline{\pi_u(\delta)}{Semantics}
    \eline{\interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{u}{A}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{TAbs1}: $\judgeA[\Theta; \Gamma, y:B; \Delta]{\pfun{u}{\upsilon'}{p}}{\upsilon' \To \upsilon}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta; \Gamma, y:B; \Delta, u:\upsilon']{p}{\upsilon}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta, u:\upsilon']{[e''/y]p}{\upsilon}$ \\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]{\pfun{u}{\upsilon'}{[e''/y]p}}{\upsilon' \To \upsilon}$ \\
    \oo By def of subst, $\judgeA[\Theta; \Gamma; \Delta]{[e''/y](\pfun{u}{\upsilon'}{p})}{\upsilon' \To \upsilon}$ \\
  \end{tabbedproof}
  %
  For semantics, consider $\interp{\judgeA[\Theta; \Gamma; \Delta]{(\pfun{u}{\upsilon'}{[e''/y]p})}{\upsilon' \To \upsilon}}\;\theta\;\gamma\;\delta$ \\
  \begin{eqnproof}
    \eline{\semfun{v}{\interp{\judgeA[\Theta; \Gamma; \Delta, u:\upsilon']{[e''/y]p}{\upsilon}}\;\theta\;\gamma\;(\delta,v)}}
          {Semantics}
    \eline{\semfun{v}{\interp{\judgeA[\Theta; \Gamma, y:B; \Delta, u:\upsilon']{p}{\upsilon}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;(\delta,v)}}
          {Induction}
    \eline{\interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{\pfun{u}{\upsilon'}{p}}{\upsilon' \To \upsilon}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{TAbs2}: $\judgeA[\Theta; \Gamma, y:B; \Delta]{\pfun{x}{A}{p}}{A \To \upsilon}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta; \Gamma, y:B, x:A; \Delta]{p}{\upsilon}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma, x:A; \Delta]{[e''/y]p}{\upsilon}$ \\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]{\pfun{x}{A}{[e''/y]p}}{A \To \upsilon}$ \\
    \oo By def of subst, $\judgeA[\Theta; \Gamma; \Delta]{[e''/y](\pfun{x}{A}{p})}{(A \To \upsilon)}$ \\
  \end{tabbedproof}
  %
  For semantics, consider $\interp{\judgeA[\Theta; \Gamma; \Delta]{[e''/y](\pfun{x}{A}{p})}{(A \To \upsilon)}}\;\theta\;\gamma\;\delta$ \\
  \begin{eqnproof}
    \eline{\semfun{v}{\interp{\judgeA[\Theta; \Gamma, x:A; \Delta]{[e''/y]p}{\upsilon}}\;\theta\;(\gamma,v)\;\delta}}
          {Semantics}
    \eline{\semfun{v}{\interp{\judgeA[\Theta; \Gamma, y:B, x:A; \Delta]{p}{\upsilon}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma, v)\;\delta}}
          {Induction}
    \eline{\interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{\pfun{x}{A}{p}}{A \To \upsilon}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta}
          {Semantics}
  \end{eqnproof}
  We silently permute arguments in the second line. 

\item Case \textsc{TAbs3}: $\judgeA[\Theta; \Gamma, y:B; \Delta]{\pfun{\beta}{\kappa'}{p}}{\kappa' \To \upsilon}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta, \beta:\kappa'; \Gamma, y:B; \Delta]{p}{\upsilon}$ \\
    \oo By weakening, $\judgeE[\Theta, \beta:\kappa']{\Gamma}{e''}{B}$ \\
    \oo By induction, $\judgeA[\Theta, \beta:\kappa'; \Gamma; \Delta]{{[e''/y]}p}{\upsilon}$ \\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]{\pfun{\beta}{\kappa'}{{[e''/y]}p}}{\kappa' \To \upsilon}$ \\
    \oo By def of subst, $\judgeA{{[e''/y]}(\pfun{\beta}{\kappa'}{p})}{\kappa' \To \upsilon}$ \\
  \end{tabbedproof}
  %
  For semantics, consider $\interp{\judgeA{[e''/y](\pfun{\beta}{\kappa'}{p})}{\kappa' \To \upsilon}}\;\theta\;\gamma\;\delta$ \\
  \begin{eqnproof}
    \eline{\semfun{\tau}{\interp{\judgeA[\Theta, \beta:\kappa'; \Gamma; \Delta]{[e''/y]p}{\upsilon}}\;(\theta,\tau)\;\gamma\;\delta}}
          {Semantics}
    \eline{\semfun{\tau}{\interp{\judgeA[\Theta, \beta:\kappa'; \Gamma, y:B; \Delta]{p}{\upsilon}}\;(\theta, \tau)\;(\gamma, \interp{\judgeE[\Theta, \beta:\kappa']{\Gamma}{e''}{B}}\;(\theta, \tau)\;\gamma)\;\delta}}
          {Induction}
    \eline{\semfun{\tau}{\interp{\judgeA[\Theta, \beta:\kappa'; \Gamma, y:B; \Delta]{p}{\upsilon}}\;(\theta, \tau)\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta}}
          {Strengthening}
    \eline{\interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{\pfun{\beta}{\kappa'}{p}}{\kappa' \To \upsilon}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta}
          {Semantics}
  \end{eqnproof}
  This case relies upon the fact that $\Gamma$ and $\Delta$ do not have $\beta$ free and the 
  equality of sorts under substitution. 

\item Case \textsc{TAbsAll}: $\judgeA[\Theta; \Gamma, y:B; \Delta]{\pfunall{\beta}{\kappa'}{p}}{\forallsort{\beta}{\kappa'}{\upsilon}}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta, \beta:\kappa'; \Gamma, y:B; \Delta]{p}{\upsilon}$ \\
    \oo By weakening, $\judgeE[\Theta, \beta:\kappa']{\Gamma}{e''}{B}$ \\
    \oo By induction, $\judgeA[\Theta, \beta:\kappa'; \Gamma; \Delta]{[e''/y]p}{\upsilon}$ \\
    \oo By rule, $\judgeA{\pfunall{\beta}{\kappa'}{[e''/y]p}}{\forallsort{\beta}{\kappa'}{\upsilon}}$ \\
    \oo By def of subst, $\judgeA{[e''/y](\pfunall{\beta}{\kappa'}{p})}{\forallsort{\beta}{\kappa'}{\upsilon}}$ \\
  \end{tabbedproof}
  %
  For semantics, consider $\interp{\judgeA{[e''/y](\pfun{\beta}{\kappa'}{p})}{\forallsort{\beta}{\kappa'}{\upsilon}}}\;\theta\;\gamma\;\delta$ \\
  \begin{eqnproof}
    \eline{\semfun{\tau}{\interp{\judgeA[\Theta, \beta:\kappa'; \Gamma; \Delta]{[e''/y]p}{\upsilon}}\;(\theta,\tau)\;\gamma\;\delta}}
          {Semantics}
    \eline{\semfun{\tau}{\interp{\judgeA[\Theta, \beta:\kappa'; \Gamma, y:B; \Delta, \beta:\kappa']{p}{\upsilon}}\;(\theta, \tau)\;(\gamma, \interp{\judgeE[\Theta, \beta:\kappa']{\Gamma}{e''}{B}}\;(\theta, \tau)\;\gamma)\;\delta}}
          {Induction}
    \eline{\semfun{\tau}{\interp{\judgeA[\Theta, \beta:\kappa'; \Gamma, y:B; \Delta, \beta:\kappa']{p}{\upsilon}}\;(\theta, \tau)\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta}}
          {Strengthening}
    \eline{\interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{\pfun{\beta}{\kappa'}{p}}{\forallsort{\beta}{\kappa'}{\upsilon}}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta}
          {Semantics}
  \end{eqnproof}
  This case relies upon the fact that $\Gamma$ and $\Delta$ do not have $\beta$ free and the 
  equality of sorts under substitution. 



\item Case \textsc{TApp}: $\judgeA[\Theta; \Gamma, y:B; \Delta]{p\;q}{\upsilon}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta; \Gamma, y:B; \Delta]{p}{\omega \To \upsilon}$\\
    \oo By inversion, $\judgeA[\Theta; \Gamma, y:B; \Delta]{q}{\omega}$\\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[e''/y]p}{(\omega \To \upsilon)}$\\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[e''/y]q}{\omega}$\\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]{[e''/y](p\;q)}{\omega \To \upsilon}$\\
  \end{tabbedproof}

  For semantics, consider $\interp{\judgeA[\Theta; \Gamma; \Delta]{[e''/y](p\;q)}{\upsilon}}\;\theta\;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\begin{array}{l}
             (\interp{\judgeA[\Theta; \Gamma; \Delta]{[e''/y]p}{(\omega \To \upsilon)}}\;\theta\;\gamma\;\delta) \\
             \;\;(\interp{\judgeA[\Theta; \Gamma; \Delta]{[e''/y]q}{\omega}}\;\theta\;\gamma\;\delta) 
      \end{array}}
    {Semantics}
    \eline{\begin{array}{l}
             (\interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{p}{\omega \To \upsilon}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta) \\
             \;\;(\interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{q}{\omega}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta) 
      \end{array}}
    {Induction}
    \eline{\interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{p\;q}{\upsilon}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta}
          {Semantics}
  \end{eqnproof}


\item Case \textsc{TAppAll}: $\judgeA[\Theta; \Gamma, y:B; \Delta]{p\;[\tau']}{[\tau'/\beta]\upsilon}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta; \Gamma, y:B; \Delta]{p}{\forallsort{\beta}{\kappa'}{\upsilon}}$\\
    \oo By inversion, $\judgeA[\Theta; \Gamma, y:B; \Delta]{\tau'}{\kappa'}$\\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[e''/y]p}{(\forallsort{\beta}{\kappa'}{\upsilon})}$\\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{\tau'}{\kappa'}$\\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]{[e''/y](p\;[\tau'])}{{[\tau/\alpha, [\tau/\alpha]\tau'/\beta]}\upsilon}$\\
  \end{tabbedproof}

  For semantics, consider $\interp{\judgeA[\Theta; \Gamma; \Delta]{[e''/y](p\;[\tau'])}{\upsilon}}\;\theta\;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\begin{array}{l}
             (\interp{\judgeA[\Theta; \Gamma; \Delta]{[e''/y]p}{(\forallsort{\beta}{\kappa'}{\upsilon})}}\;\theta\;\gamma\;\delta) \\
             \;\;(\interp{\judgeA[\Theta; \Gamma; \Delta]{\tau'}{\kappa'}}\;\theta\;\gamma\;\delta) 
      \end{array}}
    {Semantics}
    \eline{\begin{array}{l}
             (\interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{p}{\forallsort{\beta}{\kappa'}{\upsilon}}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta) \\
             \;\;(\interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{\tau'}{\kappa'}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta) 
      \end{array}}
    {Induction}
    \eline{\interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{p\;[\tau']}{\upsilon}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta}
          {Semantics}
  \end{eqnproof}


\item Case \textsc{TConst}:

  First, the syntax: 
  \begin{tabbedproof}
    \oo By inversion, $\judgectx{\Theta}{\Gamma, y:B}$ \\
    \oo By inversion, $\judgectx{\Theta}{\Delta}$ \\
    \oo By inversion, $\judgectx{\Theta}{\Gamma}$ \\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]{c}{\assert}$
  \end{tabbedproof}

  For semantics consider $\interp{\judgeA[\Theta; \Gamma; \Delta]{[e''/y]c}{\assert}}\;\theta;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\interp{c}^0}{Semantics}
    \eline{\interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{c}{\assert}}\;\theta;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{TBinary}: $\judgeA[\Theta; \Gamma, y:B; \Delta]{p \oplus q}{\assert}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta; \Gamma, y:B; \Delta]{p}{\assert}$\\
    \oo By inversion, $\judgeA[\Theta; \Gamma, y:B; \Delta]{q}{\assert}$\\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[e''/y]p}{\assert}$\\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[e''/y]q}{\assert}$\\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]{[e''/y]p \oplus [e''/y]q}{\assert}$\\
    \oo By subst def, $\judgeA[\Theta; \Gamma; \Delta]{[e''/y](p \oplus q)}{\assert}$\\
  \end{tabbedproof}

  For semantics, consider $\interp{\judgeA[\Theta; \Gamma; \Delta]{[e''/y](p \oplus q)}{\assert}}\;\theta\;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\begin{array}{l}
             (\interp{\judgeA[\Theta; \Gamma; \Delta]{[e''/y]p}{\assert}}\;\theta\;\gamma\;\delta) \;\interp{\oplus}^2 \\
             \;\;(\interp{\judgeA[\Theta; \Gamma; \Delta]{[e''/y]q}{\assert}}\;\theta\;\gamma\;\delta) 
      \end{array}}
    {Semantics}
    \eline{\begin{array}{l}
             (\interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{p}{\assert}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta) \interp{\oplus}^2 \\
             \;\;(\interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{q}{\assert}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta) 
      \end{array}}
    {Induction}
    \eline{\interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{p \oplus q}{\assert}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{TQuantify1}: $\judgeA[\Theta; \Gamma, y:B; \Delta]{Q u:\upsilon.\;p}{\assert}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta; \Gamma, y:B; \Delta, u:\upsilon]{p}{\assert}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta, u:\upsilon]{[e''/y]p}{\assert}$ \\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]
                         {Q u:\upsilon.\;[e''/y]p}{\assert}$ \\
    \oo By def of subst, $\judgeA[\Theta; \Gamma; \Delta]
                                 {[e''/y](Q u:\upsilon.\;p)}{\assert}$ 
  \end{tabbedproof}

  For semantics, consider
  $\interp{\judgeA[\Theta; \Gamma; \Delta]
                  {[e''/y](Q u:\upsilon.\;p)}{\assert}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\begin{array}{l}
            \interp{Q}_{v \in \interp{\judgeSort{\upsilon}}\;\theta} \\
            \;\;\interp{\judgeA[\Theta;\Gamma;\Delta, u:\upsilon]{[e''/y]p}{\assert}}\;\theta\,\gamma\,(\delta,v)
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
            \interp{Q}_{v \in \interp{\judgeSort[\Theta]{\upsilon}}\;\theta} \\
            \;\;\interp{\judgeA[\Theta;\Gamma, y:B;\Delta, u:\upsilon]{p}{\assert}}\;\theta\,(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\,(\delta,v)
           \end{array}}
          {Induction}
    \eline{\interp{\judgeA[\Theta;\Gamma;\Delta]{Q u:\upsilon.\;p}{\assert}}\;\theta\,(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\,\delta}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{TQuantify2}: $\judgeA[\Theta; \Gamma, y:B; \Delta]{Q x:A.\;p}{\assert}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta; \Gamma, y:B, x:A; \Delta]{p}{\assert}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma, x:A; \Delta]{[e''/y]p}{\assert}$ \\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]
                         {Q x:A.\;[e''/y]p}{\assert}$ \\
    \oo By def of subst, $\judgeA[\Theta; \Gamma; \Delta]
                                 {[e''/y](Q x:A.\;p)}{\assert}$ 
  \end{tabbedproof}

  For semantics, consider
  $\interp{\judgeA[\Theta; \Gamma; \Delta]
                  {[e''/y](Q x:A.\;p)}{\assert}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\begin{array}{l}
            \interp{Q}_{v \in \interp{\judgeSort{A}}\;\theta} \\
            \;\;\interp{\judgeA[\Theta;\Gamma, x:A;\Delta]{[e''/y]p}{\assert}}\;\theta\,(\gamma,v)\,\delta
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
            \interp{Q}_{v \in \interp{\judgeSort[\Theta, \alpha:\kappa]{A}}\;\theta} \\
            \;\;\interp{\judgeA[\Theta;\Gamma, y:B, x:A;\Delta]{p}{\assert}}\;\theta\,(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma, v)\,\delta
           \end{array}}
          {Induction}
    \eline{\interp{\judgeA[\Theta;\Gamma, y:B;\Delta]{Q x:A.\;p}{\assert}}\;\theta\,(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\,\delta}
          {Semantics}
  \end{eqnproof}
  Here, we make use of the fact that $x$ is not free in $e''$, and we silently permute the context as 
  needed. 

\item Case \textsc{TQuantify3}: $\judgeA[\Theta; \Gamma, y:B; \Delta]{Q \beta:\kappa'.\;p}{\assert}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta, \beta:\kappa'; \Gamma, y:B; \Delta]{p}{\assert}$ \\
    \oo By weakening, $\judgeE[\Theta, \beta:\kappa']{\Gamma}{e''}{B}$ \\
    \oo By induction, $\judgeA[\Theta, \beta:\kappa'; \Gamma; \Delta]{[e''/y]p}{\assert}$ \\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]
                         {Q \beta:\kappa'.\;[e''/y]p}{\assert}$ \\
    \oo By def of subst, $\judgeA[\Theta; \Gamma; \Delta]
                                 {[e''/y](Q \beta:\kappa'.\;p)}{\assert}$ 
  \end{tabbedproof}

  For semantics, consider
  $\interp{\judgeA[\Theta; \Gamma; \Delta]
                  {[e''/y](Q \beta:\kappa'.\;p)}{\assert}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\begin{array}{l}
            \interp{Q}_{\tau' \in \interp{\judgeSort{\kappa'}}\;\theta} \\
            \;\;\interp{\judgeA[\Theta, \beta:\kappa';\Gamma;\Delta]{[e''/y]p}{\assert}}\;(\theta,\tau')\,\gamma\,\delta
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
            \interp{Q}_{\tau' \in \interp{\judgeSort[\Theta]{\kappa'}}\;\theta} \\
            \;\;\interp{\judgeA[\Theta, \beta:\kappa';\Gamma, y:B;\Delta]{p}{\assert}}\;(\theta, \tau)\,(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\,\delta
           \end{array}}
          {Induction}
    \eline{\interp{\judgeA[\Theta;\Gamma;\Delta]{Q \beta:\kappa'.\;p}{\assert}}\;\theta\,(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\,\delta}
          {Semantics}
  \end{eqnproof}
  In this case we silently use the fact that $\beta$ does not occur free in $e''$ or $B$.

\item Case \textsc{TEqual}: $\judgeA[\Theta; \Gamma, y:B; \Delta]{p =_\omega q}{\assert}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta; \Gamma, y:B; \Delta]{p}{\omega}$ \\
    \oo By inversion, $\judgeA[\Theta; \Gamma, y:B; \Delta]{q}{\omega}$ \\
    \oo By inversion, $\judgeSort[\Theta]{\omega}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[e''/y]p}{\omega}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[e''/y]q}{\omega}$ \\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]{[e''/y](p =_\omega q)}{\assert}$
  \end{tabbedproof}

  For the semantics, consider $\interp{\judgeA[\Theta; \Gamma; \Delta]{[e''/y](p =_\omega q)}{\assert}}\;\theta\;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\mbox{if }\interp{[e''/y]p}\theta\;\gamma\;\delta = \interp{[e''/y]q}\theta\;\gamma\;\delta\mbox{ then }\top \mbox{ else } \bot}
          {Semantics}
    \eline{\mbox{if }\interp{p}\;\theta\;(\gamma, \interp{e''}\theta\;\gamma)\;\delta = \interp{q}\;\theta\;(\gamma, \interp{e''}\theta\;\gamma)\;\delta\mbox{ then }\top \mbox{ else } \bot}
          {Induction}
    \eline{\interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{(p =_\omega q)}{\assert}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{TPointsto}: $\judgeA[\Theta; \Gamma, y:B; \Delta]{e \pointsto_A e'}{\assert}$

  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta; \Gamma, y:B; \Delta]{e}{\reftype{A}}$ \\
    \oo By inversion, $\judgeA[\Theta; \Gamma, y:B; \Delta]{e'}{A}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[e''/y]e}{\reftype{A}}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[e''/y]e'}{A}$ \\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]{[e''/y](e \pointsto_A e')}{\assert}$
  \end{tabbedproof}

  For the semantics, consider $\interp{\judgeA[\Theta; \Gamma; \Delta]{[e''/y](e \pointsto_A e')}{\assert}}\;\theta\;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\begin{array}{l}
           \interp{\judgeE[\Theta]{\Gamma}{[e''/y]e}{\reftype{A}}}\;\theta\;\gamma \\ 
           \pointsto \\
           \interp{\judgeE[\Theta]{\Gamma}{[e''/y]e'}{A}}\;\theta\;\gamma
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
           \interp{\judgeE{\Gamma, y:B}{e}{\reftype{A}}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma) \\ 
           \pointsto \\
           \interp{\judgeE{\Gamma, y:B}{e'}{A}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)
           \end{array}}
          {Induction}
    \eline{\interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{e \pointsto_A e'}{\assert}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{TEqSort}: $\judgeA[\Theta; \Gamma, y:B; \Delta]{p}{\omega}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeSortEq{\omega}{\omega'}$ \\
    \oo By inversion, $\judgeA[\Theta; \Gamma, y:B; \Delta]{p}{\omega'}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[e''/y]p}{\omega'}$ \\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]{[e''/y]p}{\omega}$ \\
  \end{tabbedproof}

  For the semantics, consider $\interp{\judgeA[\Theta; \Gamma; \Delta]{[e''/y]p}{\omega}}\;\theta\;\gamma\;\delta$ \\
  \begin{eqnproof}
    \eline{\interp{\judgeA[\Theta; \Gamma; \Delta]{[e''/y]p}{\omega'}}\;\theta\;\gamma\;\delta}
          {Semantics}
    \eline{\interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{p}{\omega'}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta}
          {Induction}
    \eline{\interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{p}{\omega}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{TSpec}: $\judgeA[\Theta; \Gamma, y:B; \Delta]{\validprop{S}}{\assert}$:
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeS[\Theta; \Gamma, y:B; \Delta]{S}$ \\
    \oo By mutual induction $\judgeS[\Theta; \Gamma; \Delta]{[e''/y]S}$\\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]{[e''/y]\validprop{S}}{\assert}$
  \end{tabbedproof}

  For the semantics, consider $\interp{\judgeA[\Theta; \Gamma; \Delta]{[e''/y]\validprop{S}}{\assert}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\mbox{if } \interp{[e''/y]S}\;\theta\;\gamma\;\delta = \top \mbox{ then } \top \mbox{ else } \bot}
          {Semantics}
    \eline{\mbox{if } \interp{S}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta = \top \mbox{ then } \top \mbox{ else } \bot}
          {Induction}
    \eline{\interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{\validprop{S}}{\assert}}\; \theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{SpecTriple}: $\judgeS[\Theta; \Gamma, y:B; \Delta]{\spec{p}{c}{a:A}{q}}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta; \Gamma, y:B; \Delta]{p}{\assert}$ \\
    \oo By inversion, $\judgeA[\Theta; \Gamma, y:B; \Delta]{\comp{c}}{\monad{A}}$ \\
    \oo By inversion, $\judgeA[\Theta; \Gamma, y:B; \Delta, a:A]{q}{\assert}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[e''/y]p}{\assert}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{\comp{[e''/y]c}}{\monad{A}}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta, a:A]{[e''/y]q}{\assert}$ \\
    \oo By rule, $\judgeS[\Theta; \Gamma; \Delta]{[e''/y](\spec{p}{c}{a:A}{q})}$
  \end{tabbedproof}

  For the semantics, consider $\interp{\judgeS[\Theta; \Gamma; \Delta]{[e''/y](\spec{p}{c}{a:A}{q})}}\;\theta;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\begin{array}{l}
           \{\interp{\judgeA[\Theta; \Gamma; \Delta]{[e''/y]p}{\assert}}\;\theta\;\gamma\;\delta\} \\
           \interp{\judgeC{\Gamma}{[e''/y]c}{A}}\;\theta\;\gamma \\
           \{v.\;\interp{\judgeA[\Theta; \Gamma, a:A; \Delta]{[e''/y]q}{\assert}}\;\theta\;(\gamma,v)\;\delta\} 
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
           \{\interp{\judgeA[\Theta, \Gamma; \Delta]{p}{\assert}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta\} \\
           \interp{\judgeC[\Theta]{\Gamma, y:B}{c}{A}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma) \\
           \{v.\;\interp{\judgeA[\Theta; \Gamma, y:B, a:A; \Delta]{q}{\assert}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma, v)\;\delta\} 
           \end{array}}
          {Induction}
    \eline{\interp{\judgeS[\Theta; \Gamma, y:B; \Delta]{(\spec{p}{c}{a:A}{q})}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta}
          {Semantics}
  \end{eqnproof}
  The correctness of the application of $\gamma$ and $\delta$ follows from the equations for
  contexts under substitution. 

\item Case \textsc{SpecMTriple}: $\judgeS[\Theta; \Gamma, y:B; \Delta]{\mspec{p}{e}{a:A}{q}}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta; \Gamma, y:B; \Delta]{p}{\assert}$ \\
    \oo By inversion, $\judgeA[\Theta; \Gamma, y:B; \Delta]{e}{\monad{A}}$ \\
    \oo By inversion, $\judgeA[\Theta; \Gamma, y:B; \Delta, a:A]{q}{\assert}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[e''/y]p}{\assert}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[e''/y]e}{\monad{A}}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta, a:A]{[e''/y]q}{\assert}$ \\
    \oo By rule, $\judgeS[\Theta; \Gamma; \Delta]{[e''/y](\mspec{p}{e}{a:A}{q})}$
  \end{tabbedproof}

  For the semantics, consider $\interp{\judgeS[\Theta; \Gamma; \Delta]{[e''/y](\mspec{p}{e}{a:A}{q})}}\;\theta;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\begin{array}{l}
           \{\interp{\judgeA[\Theta; \Gamma; \Delta]{[e''/y]p}{\assert}}\;\theta\;\gamma\;\delta\} \\
           \interp{\judgeE{\Gamma}{[e''/y]e}{\monad{A}}}\;\theta\;\gamma \\
           \{v.\;\interp{\judgeA[\Theta; \Gamma, a:A; \Delta]{[e''/y]q}{\assert}}\;\theta\;(\gamma,v)\;\delta\} 
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
           \{\interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{p}{\assert}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta\} \\
           \interp{\judgeE{\Gamma, y:B}{e}{\monad{A}}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma) \\
           \{v.\;\interp{\judgeA[\Theta; \Gamma, y:B, a:A; \Delta]{q}{\assert}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma, v)\;\delta\} 
           \end{array}}
          {Induction}
    \eline{\interp{\judgeS[\Theta; \Gamma, y:B; \Delta]{(\mspec{p}{e}{a:A}{q})}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{SpecQuantify1}: $\judgeS[\Theta; \Gamma, y:B; \Delta]{Q u:\upsilon.\;S}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeS[\Theta; \Gamma, y:B; \Delta, u:\upsilon]{S}$ \\
    \oo By induction, $\judgeS[\Theta; \Gamma; \Delta, u:\upsilon]{[e''/y]S}$ \\
    \oo By rule, $\judgeS[\Theta; \Gamma; \Delta]
                         {Q u:\upsilon.\;[e''/y]S}$ \\
    \oo By def of subst, $\judgeS[\Theta; \Gamma; \Delta]
                                 {[e''/y](Q u:\upsilon.\;S)}$ 
  \end{tabbedproof}

  For semantics, consider
  $\interp{\judgeS[\Theta; \Gamma; \Delta]
                  {[e''/y](Q u:\upsilon.\;S)}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\begin{array}{l}
            \interp{Q}_{v \in \interp{\judgeSort{\upsilon}}\;\theta} \\
            \;\;\interp{\judgeS[\Theta;\Gamma;\Delta, u:\upsilon]{[e''/y]S}}\;\theta\,\gamma\,(\delta,v)
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
            \interp{Q}_{v \in \interp{\judgeSort[\Theta]{\upsilon}}\;\theta} \\
            \;\;\interp{\judgeS[\Theta;\Gamma, y:B;\Delta, u:\upsilon]{S}}\;\theta\,(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\,(\delta,v)
           \end{array}}
          {Induction}
    \eline{\interp{\judgeS[\Theta;\Gamma, y:B;\Delta]{Q u:\upsilon.\;S}}\;\theta\,(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\,\delta}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{SpecQuantify2}: $\judgeS[\Theta; \Gamma, y:B; \Delta]{Q x:A.\;S}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeS[\Theta; \Gamma, y:B, x:A; \Delta]{S}$ \\
    \oo By induction, $\judgeS[\Theta; \Gamma, x:A; \Delta]{[e''/y]S}$ \\
    \oo By rule, $\judgeS[\Theta; \Gamma; \Delta]
                         {Q x:A.\;[e''/y]S}$ \\
    \oo By def of subst, $\judgeS[\Theta; \Gamma; \Delta]
                                 {[e''/y](Q x:A.\;S)}$ 
  \end{tabbedproof}

  For semantics, consider
  $\interp{\judgeS[\Theta; \Gamma; \Delta]
                  {[e''/y](Q x:A.\;S)}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\begin{array}{l}
            \interp{Q}_{v \in \interp{\judgeSort{A}}\;\theta} \\
            \;\;\interp{\judgeS[\Theta;\Gamma, x:A;\Delta]{[e''/y]S}}\;\theta\,(\gamma,v)\,\delta
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
            \interp{Q}_{v \in \interp{\judgeSort[\Theta]{A}}\;\theta} \\
            \;\;\interp{\judgeS[\Theta;\Gamma, y:A, x:A;\Delta]{S}}\;\theta\,(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma,v)\,\delta
           \end{array}}
          {Induction}
    \eline{\interp{\judgeS[\Theta;\Gamma, y:A;\Delta]{Q x:A.\;S}}\;\theta\,(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\,\delta}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{SpecQuantify3}: $\judgeS[\Theta; \Gamma, y:A; \Delta]{Q \beta:\kappa'.\;S}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeS[\Theta, \beta:\kappa'; \Gamma, y:A; \Delta]{S}$ \\
    \oo By induction, $\judgeS[\Theta, \beta:\kappa'; \Gamma; \Delta]{[e''/y]S}$ \\
    \oo By rule, $\judgeS[\Theta; \Gamma; \Delta]
                         {Q \beta:\kappa'.\;[e''/y]S}$ \\
    \oo By def of subst, $\judgeS[\Theta; \Gamma; \Delta]
                                 {[e''/y](Q \beta:\kappa'.\;S)}$ 
  \end{tabbedproof}

  For semantics, consider
  $\interp{\judgeS[\Theta; \Gamma; \Delta]
                  {[e''/y](Q \beta:\kappa'.\;S)}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\begin{array}{l}
            \interp{Q}_{\tau' \in \interp{\judgeSort{\kappa'}}\;\theta} \\
            \;\;\interp{\judgeS[\Theta, \beta:\kappa';\Gamma;\Delta]{[e''/y]S}}\;(\theta,\tau')\,\gamma\,\delta
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
            \interp{Q}_{\tau' \in \interp{\judgeSort[\Theta]{\kappa'}}\;\theta} \\
            \;\;\interp{\judgeS[\Theta, \alpha:\kappa, \beta:\kappa';\Gamma;\Delta]{S}}\;(\theta, \tau')\,(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\,\delta
           \end{array}}
          {Induction}
    \eline{\interp{\judgeS[\Theta;\Gamma;\Delta]{Q \beta:\kappa'.\;S}}\;\theta\,(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\,\delta}
          {Semantics}
  \end{eqnproof}


\item Case \textsc{SpecBinary}: $\judgeS[\Theta; \Gamma, y:B; \Delta]{S \oplus S'}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeS[\Theta; \Gamma, y:B; \Delta]{S}$\\
    \oo By inversion, $\judgeS[\Theta; \Gamma, y:B; \Delta]{S'}$\\
    \oo By induction, $\judgeS[\Theta; \Gamma; \Delta]{[e''/y]S}$\\
    \oo By induction, $\judgeS[\Theta; \Gamma; \Delta]{[e''/y]S'}$\\
    \oo By rule, $\judgeS[\Theta; \Gamma; \Delta]{[e''/y]S \oplus [e''/y]S'}$\\
    \oo By subst def, $\judgeS[\Theta; \Gamma; \Delta]{[e''/y](S \oplus S')}$\\
  \end{tabbedproof}

  For semantics, consider $\interp{\judgeS[\Theta; \Gamma; \Delta]{[e''/y](S \oplus S')}}\;\theta\;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\begin{array}{l}
             (\interp{\judgeS[\Theta; \Gamma; \Delta]{[e''/y]S}}\;\theta\;\gamma\;\delta) \;\interp{\oplus} \\
             \;\;(\interp{\judgeS[\Theta; \Gamma; \Delta]{[e''/y]S'}}\;\theta\;\gamma\;\delta) 
      \end{array}}
    {Semantics}
    \eline{\begin{array}{l}
             (\interp{\judgeS[\Theta; \Gamma, y:B; \Delta]{S}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta) \interp{\oplus} \\
             \;\;(\interp{\judgeS[\Theta; \Gamma, y:B; \Delta]{S'}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta) 
      \end{array}}
    {Induction}
    \eline{\interp{\judgeS[\Theta; \Gamma, y:B; \Delta]{S \oplus S'}}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{TSpec}: $\judgeS[\Theta; \Gamma, y:B; \Delta]{\setof{p}}$:
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta; \Gamma, y:B; \Delta]{p}{\assert}$ \\
    \oo By mutual induction $\judgeA[\Theta; \Gamma; \Delta]{[e''/y]p}{\assert}$\\
    \oo By rule, $\judgeS[\Theta; \Gamma; \Delta]{[e''/y]\setof{p}}$
  \end{tabbedproof}

  For the semantics, consider $\interp{\judgeS[\Theta; \Gamma; \Delta]{[e''/y]\setof{p}}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\mbox{if } \interp{[e''/y]p}\;\theta\;\gamma\;\delta = \top \mbox{ then } \top \mbox{ else } \bot}
          {Semantics}
    \eline{\mbox{if } \interp{p}\;\theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta = \top \mbox{ then } \top \mbox{ else } \bot}
          {Induction}
    \eline{\interp{\judgeS[\Theta; \Gamma, y:B; \Delta]{\setof{p}}}\; \theta\;(\gamma, \interp{\judgeE{\Gamma}{e''}{B}}\;\theta\;\gamma)\;\delta}
          {Semantics}
  \end{eqnproof}
\end{enumerate}

\ \\

Finally, assume $\judgeA{r}{\upsilon''}$, and $\judgeA[\Theta; \Gamma;\Delta, b:\upsilon'']{p}{\omega}$, and
$\judgeS[\Theta; \Gamma, y:B; \Delta, b:\upsilon'']{S}$. 

Now, we proceed by mutual induction on the derivation of $p$ and $S$: 
\begin{enumerate}

\item Case \textsc{TType}: $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{\tau'}{\kappa'}$

  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, we know $\judgectx{\Theta}{\Delta, b:\upsilon''}$ \\
    \oo By inversion, we know $\judgectx{\Theta}{\Gamma}$ \\
    \oo By inversion, we know $\judgectx{\Theta}{\Delta}$ \\
    \oo By rule, $\judgeA[\Theta; \Gamma;\Delta]{\tau'}{\kappa'}$
  \end{tabbedproof}

  For semantics,  $\interp{\judgeA[\Theta; \Gamma; \Delta]{[r/b]\tau'}{\kappa'}}\;\theta\;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\interp{\judgeWK[\Theta]{\tau'}{\kappa'}}\;\theta}
          {Semantics}
    \eline{\interp{\judgeA[\Theta;\Gamma;\Delta, b:\upsilon'']{\tau'}{\kappa'}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
          {Semantics}
  \end{eqnproof}

  \item Case \textsc{TExpr}: $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{e}{A}$

    First, the syntax:
    \begin{tabbedproof}
      \oo By inversion, we know $\judgectx{\Theta}{\Delta, b:\upsilon''}$ \\
      \oo By inversion, we know $\judgectx{\Theta}{\Delta}$ \\
      \oo By inversion, we know $\judgeE{\Gamma}{e}{A}$ \\
      \oo By substitution, we know $\judgeE{\Gamma}{[r/b]e}{A}$ \\
      \oo By rule, we know $\judgeA[\Theta; \Gamma; \Delta]{[r/b]e}{A}$
    \end{tabbedproof}

    For semantics, consider $\interp{\judgeA[\Theta; \Gamma; \Delta]{[r/b]e}{A}}\;\theta\;\gamma\;\delta$
    \begin{eqnproof}
      \eline{\interp{\judgeE{\Gamma}{e}{A}}\;\theta\;\gamma}
            {Semantics}
      \eline{\interp{\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{e}{A}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
            {Semantics}
    \end{eqnproof}

\item Case \textsc{THyp}: $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{u}{\upsilon}$

  There are two cases. 
  \begin{itemize}
  \item Case $u = b$: (hence $\upsilon'' = \upsilon$)

    In this case, the syntax follows since $\judgeA{r}{\upsilon''}$

    For semantics, consider that $\interp{\judgeA[\Theta; \Gamma; \Delta]{r}{\upsilon}}\;\theta;\gamma\;\delta$
    \begin{eqnproof}
    \eline{\interp{\judgeA[\Theta; \Gamma; \Delta, b:\upsilon]{b}{\upsilon}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon}}\;\theta\;\gamma\;\delta)}
          {Definition}
    \end{eqnproof}

  \item Case $u \not= b$: 

  First, the syntax:
  \begin{tabbedproof}
  \oo By strengthening, $\judgeA[\Theta; \Gamma; \Delta]{[r/b]u}{\upsilon}$ \\
  \end{tabbedproof}

  For semantics, consider that $\interp{\judgeA[\Theta; \Gamma; \Delta]{[r/b]u}{\upsilon}}\;\theta;\gamma\;\delta$ \\
  \begin{eqnproof}
    \eline{\pi_u(\delta)}
          {Semantics} 
    \eline{\interp{\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{u}{\upsilon}}\;\theta;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
          {Semantics}
  \end{eqnproof}

  \end{itemize}




\item Case \textsc{TAbs1}: $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{\pfun{u}{\upsilon'}{p}}{\upsilon' \To \upsilon}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'', u:\upsilon']{p}{\upsilon}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta, u:\upsilon']{[r/b]p}{\upsilon}$ \\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]{\pfun{u}{\upsilon'}{[r/b]p}}{\upsilon' \To \upsilon}$ \\
    \oo By def of subst, $\judgeA[\Theta; \Gamma; \Delta]{[r/b](\pfun{u}{\upsilon'}{p})}{\upsilon' \To \upsilon}$ \\
  \end{tabbedproof}
  %
  For semantics, consider $\interp{\judgeA[\Theta; \Gamma; \Delta]{(\pfun{u}{\upsilon'}{[r/b]p})}{\upsilon' \To \upsilon}}\;\theta\;\gamma\;\delta$ \\
  \begin{eqnproof}
    \eline{\semfun{v}{\interp{\judgeA[\Theta; \Gamma; \Delta, u:\upsilon']{[r/b]p}{\upsilon}}\;\theta\;\gamma\;(\delta,v)}}
          {Semantics}
    \eline{\semfun{v}{\interp{\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'', u:\upsilon']{p}{\upsilon}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta,v)}}
          {Induction}
    \eline{\interp{\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{\pfun{u}{\upsilon'}{p}}{\upsilon' \To \upsilon}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{TAbs2}: $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{\pfun{x}{A}{p}}{A \To \upsilon}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta; \Gamma, x:A; \Delta, b:\upsilon'']{p}{\upsilon}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma, x:A; \Delta]{[r/b]p}{\upsilon}$ \\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]{\pfun{x}{A}{[r/b]p}}{A \To \upsilon}$ \\
    \oo By def of subst, $\judgeA[\Theta; \Gamma; \Delta]{[r/b](\pfun{x}{A}{p})}{(A \To \upsilon)}$ \\
  \end{tabbedproof}
  %
  For semantics, consider $\interp{\judgeA[\Theta; \Gamma; \Delta]{[r/b](\pfun{x}{A}{p})}{(A \To \upsilon)}}\;\theta\;\gamma\;\delta$ \\
  \begin{eqnproof}
    \eline{\semfun{v}{\interp{\judgeA[\Theta; \Gamma, x:A; \Delta]{[r/b]p}{\upsilon}}\;\theta\;(\gamma,v)\;\delta}}
          {Semantics}
    \eline{\semfun{v}{\interp{\judgeA[\Theta; \Gamma, x:A; \Delta, b:\upsilon'']{p}{\upsilon}}\;\theta\;(\gamma, v)\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}}
          {Induction}
    \eline{\interp{\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{\pfun{x}{A}{p}}{A \To \upsilon}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
          {Semantics}
  \end{eqnproof}
  We silently permute arguments in the second line. 

\item Case \textsc{TAbs3}: $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{\pfun{\beta}{\kappa'}{p}}{\kappa' \To \upsilon}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta, \beta:\kappa'; \Gamma; \Delta, b:\upsilon'']{p}{\upsilon}$ \\
    \oo By weakening, $\judgeA[\Theta, \beta:\kappa'; \Gamma; \Delta]{r}{\upsilon''}$ \\
    \oo By induction, $\judgeA[\Theta, \beta:\kappa'; \Gamma; \Delta]{{[r/b]}p}{\upsilon}$ \\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]{\pfun{\beta}{\kappa'}{{[r/b]}p}}{\kappa' \To \upsilon}$ \\
    \oo By def of subst, $\judgeA{{[r/b]}(\pfun{\beta}{\kappa'}{p})}{\kappa' \To \upsilon}$ \\
  \end{tabbedproof}
  %
  For semantics, consider $\interp{\judgeA{[r/b](\pfun{\beta}{\kappa'}{p})}{\kappa' \To \upsilon}}\;\theta\;\gamma\;\delta$ \\
  \begin{eqnproof}
    \eline{\semfun{\tau}{\interp{\judgeA[\Theta, \beta:\kappa'; \Gamma; \Delta]{[r/b]p}{\upsilon}}\;(\theta,\tau)\;\gamma\;\delta}}
          {Semantics}
    \eline{\semfun{\tau}{\interp{\judgeA[\Theta, \beta:\kappa'; \Gamma; \Delta, b:\upsilon'']{p}{\upsilon}}\;(\theta, \tau)\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}}
          {Induction}
    \eline{\interp{\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{\pfun{\beta}{\kappa'}{p}}{\kappa' \To \upsilon}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
          {Semantics}
  \end{eqnproof}
  This case relies upon the fact that $\Gamma$ and $\Delta$ do not have $\beta$ free and the 
  equality of sorts under substitution. 

\item Case \textsc{TAbsAll}: $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{\pfunall{\beta}{\kappa'}{p}}{\forallsort{\beta}{\kappa'}{\upsilon}}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta, \beta:\kappa'; \Gamma; \Delta, b:\upsilon'']{p}{\upsilon}$ \\
    \oo By induction, $\judgeA[\Theta, \beta:\kappa'; \Gamma; \Delta]{[r/b]p}{\upsilon}$ \\
    \oo By rule, $\judgeA{\pfunall{\beta}{\kappa'}{[r/b]p}}{\forallsort{\beta}{\kappa'}{\upsilon}}$ \\
    \oo By def of subst, $\judgeA{[r/b](\pfunall{\beta}{\kappa'}{p})}{\forallsort{\beta}{\kappa'}{\upsilon}}$ \\
  \end{tabbedproof}
  %
  For semantics, consider $\interp{\judgeA{[r/b](\pfun{\beta}{\kappa'}{p})}{\forallsort{\beta}{\kappa'}{\upsilon}}}\;\theta\;\gamma\;\delta$ \\
  \begin{eqnproof}
    \eline{\semfun{\tau}{\interp{\judgeA[\Theta, \beta:\kappa'; \Gamma; \Delta]{[r/b]p}{\upsilon}}\;(\theta,\tau)\;\gamma\;\delta}}
          {Semantics}
    \eline{\semfun{\tau}{\interp{\judgeA[\Theta, \beta:\kappa'; \Gamma; \Delta, b:\upsilon'', \beta:\kappa']{p}{\upsilon}}\;(\theta, \tau)\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}}
          {Induction}
    \eline{\interp{\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{\pfun{\beta}{\kappa'}{p}}{\forallsort{\beta}{\kappa'}{\upsilon}}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
          {Semantics}
  \end{eqnproof}
  This case relies upon the fact that $\Gamma$ and $\Delta$ do not have $\beta$ free and the 
  equality of sorts under substitution. 



\item Case \textsc{TApp}: $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{p\;q}{\upsilon}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{p}{\omega \To \upsilon}$\\
    \oo By inversion, $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{q}{\omega}$\\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[r/b]p}{(\omega \To \upsilon)}$\\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[r/b]q}{\omega}$\\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]{[r/b](p\;q)}{\omega \To \upsilon}$\\
  \end{tabbedproof}

  For semantics, consider $\interp{\judgeA[\Theta; \Gamma; \Delta]{[r/b](p\;q)}{\upsilon}}\;\theta\;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\begin{array}{l}
             (\interp{\judgeA[\Theta; \Gamma; \Delta]{[r/b]p}{(\omega \To \upsilon)}}\;\theta\;\gamma\;\delta) \\
             \;\;(\interp{\judgeA[\Theta; \Gamma; \Delta]{[r/b]q}{\omega}}\;\theta\;\gamma\;\delta) 
      \end{array}}
    {Semantics}
    \eline{\begin{array}{l}
             (\interp{\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{p}{\omega \To \upsilon}}\;\theta\;\gamma\;\delta) \\
             \;\;(\interp{\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{q}{\omega}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)) 
      \end{array}}
    {Induction}
    \eline{\interp{\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{p\;q}{\upsilon}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
          {Semantics}
  \end{eqnproof}


\item Case \textsc{TAppAll}: $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{p\;[\tau']}{[\tau'/\beta]\upsilon}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{p}{\forallsort{\beta}{\kappa'}{\upsilon}}$\\
    \oo By inversion, $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{\tau'}{\kappa'}$\\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[r/b]p}{(\forallsort{\beta}{\kappa'}{\upsilon})}$\\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{\tau'}{\kappa'}$\\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]{[r/b](p\;[\tau'])}{{[\tau/\alpha, [\tau/\alpha]\tau'/\beta]}\upsilon}$\\
  \end{tabbedproof}

  For semantics, consider $\interp{\judgeA[\Theta; \Gamma; \Delta]{[r/b](p\;[\tau'])}{\upsilon}}\;\theta\;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\begin{array}{l}
             (\interp{\judgeA[\Theta; \Gamma; \Delta]{[r/b]p}{(\forallsort{\beta}{\kappa'}{\upsilon})}}\;\theta\;\gamma\;\delta) \\
             \;\;(\interp{\judgeA[\Theta; \Gamma; \Delta]{\tau'}{\kappa'}}\;\theta\;\gamma\;\delta) 
      \end{array}}
    {Semantics}
    \eline{\begin{array}{l}
             (\interp{\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{p}{\forallsort{\beta}{\kappa'}{\upsilon}}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)) \\
             \;\;(\interp{\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{\tau'}{\kappa'}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)) 
      \end{array}}
    {Induction}
    \eline{\interp{\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{p\;[\tau']}{\upsilon}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
          {Semantics}
  \end{eqnproof}


\item Case \textsc{TConst}:

  First, the syntax: 
  \begin{tabbedproof}
    \oo By inversion, $\judgectx{\Theta}{\Gamma}$ \\
    \oo By inversion, $\judgectx{\Theta}{\Delta, b:\upsilon''}$ \\
    \oo By inversion, $\judgectx{\Theta}{\Delta}$ \\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]{c}{\assert}$
  \end{tabbedproof}

  For semantics consider $\interp{\judgeA[\Theta; \Gamma; \Delta]{[r/b]c}{\assert}}\;\theta;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\interp{c}^0}{Semantics}
    \eline{\interp{\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{c}{\assert}}\;\theta;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{TBinary}: $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{p \oplus q}{\assert}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{p}{\assert}$\\
    \oo By inversion, $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{q}{\assert}$\\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[r/b]p}{\assert}$\\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[r/b]q}{\assert}$\\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]{[r/b]p \oplus [r/b]q}{\assert}$\\
    \oo By subst def, $\judgeA[\Theta; \Gamma; \Delta]{[r/b](p \oplus q)}{\assert}$\\
  \end{tabbedproof}

  For semantics, consider $\interp{\judgeA[\Theta; \Gamma; \Delta]{[r/b](p \oplus q)}{\assert}}\;\theta\;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\begin{array}{l}
             (\interp{\judgeA[\Theta; \Gamma; \Delta]{[r/b]p}{\assert}}\;\theta\;\gamma\;\delta) \;\interp{\oplus}^2 \\
             \;\;(\interp{\judgeA[\Theta; \Gamma; \Delta]{[r/b]q}{\assert}}\;\theta\;\gamma\;\delta) 
      \end{array}}
    {Semantics}
    \eline{\begin{array}{l}
             (\interp{\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{p}{\assert}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)) \interp{\oplus}^2 \\
             \;\;(\interp{\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{q}{\assert}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)) 
      \end{array}}
    {Induction}
    \eline{\interp{\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{p \oplus q}{\assert}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{TQuantify1}: $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{Q u:\upsilon.\;p}{\assert}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'', u:\upsilon]{p}{\assert}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta, u:\upsilon]{[r/b]p}{\assert}$ \\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]
                         {Q u:\upsilon.\;[r/b]p}{\assert}$ \\
    \oo By def of subst, $\judgeA[\Theta; \Gamma; \Delta]
                                 {[r/b](Q u:\upsilon.\;p)}{\assert}$ 
  \end{tabbedproof}

  For semantics, consider
  $\interp{\judgeA[\Theta; \Gamma; \Delta]
                  {[r/b](Q u:\upsilon.\;p)}{\assert}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\begin{array}{l}
            \interp{Q}_{v \in \interp{\judgeSort{\upsilon}}\;\theta} \\
            \;\;\interp{\judgeA[\Theta;\Gamma;\Delta, u:\upsilon]{[r/b]p}{\assert}}\;\theta\,\gamma\,(\delta,v)
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
            \interp{Q}_{v \in \interp{\judgeSort[\Theta]{\upsilon}}\;\theta} \\
            \;\;\interp{\judgeA[\Theta;\Gamma; \Delta, b:\upsilon'', u:\upsilon]{p}{\assert}}\;\theta\,\gamma\,(\delta,\interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta, v)
           \end{array}}
          {Induction}
    \eline{\interp{\judgeA[\Theta, \alpha:\kappa;\Gamma;\Delta]{Q u:\upsilon.\;p}{\assert}}\;\theta\,\gamma\,(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{TQuantify2}: $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{Q x:A.\;p}{\assert}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta; \Gamma, x:A; \Delta, b:\upsilon'']{p}{\assert}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma, x:A; \Delta]{[r/b]p}{\assert}$ \\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]
                         {Q x:A.\;[r/b]p}{\assert}$ \\
    \oo By def of subst, $\judgeA[\Theta; \Gamma; \Delta]
                                 {[r/b](Q x:A.\;p)}{\assert}$ 
  \end{tabbedproof}

  For semantics, consider
  $\interp{\judgeA[\Theta; \Gamma; \Delta]
                  {[r/b](Q x:A.\;p)}{\assert}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\begin{array}{l}
            \interp{Q}_{v \in \interp{\judgeSort{A}}\;\theta} \\
            \;\;\interp{\judgeA[\Theta;\Gamma, x:A;\Delta]{[r/b]p}{\assert}}\;\theta\,(\gamma,v)\,\delta
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
            \interp{Q}_{v \in \interp{\judgeSort[\Theta]{A}}\;\theta} \\
            \;\;\interp{\judgeA[\Theta;\Gamma, x:A;\Delta, u:\upsilon'']{p}{\assert}}\;\theta\,(\gamma, v)\,(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)
           \end{array}}
          {Induction}
    \eline{\interp{\judgeA[\Theta;\Gamma; \Delta, b:\upsilon'']{Q x:A.\;p}{\assert}}\;\theta\,\gamma\,(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
          {Semantics}
  \end{eqnproof}
  Here, we make use of the fact that $x$ is not free in $r$, and we silently permute the context as 
  needed. 

\item Case \textsc{TQuantify3}: $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{Q \beta:\kappa'.\;p}{\assert}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta, \beta:\kappa'; \Gamma; \Delta, b:\upsilon'']{p}{\assert}$ \\
    \oo By induction, $\judgeA[\Theta, \beta:\kappa'; \Gamma; \Delta]{[r/b]p}{\assert}$ \\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]
                         {Q \beta:\kappa'.\;[r/b]p}{\assert}$ \\
    \oo By def of subst, $\judgeA[\Theta; \Gamma; \Delta]
                                 {[r/b](Q \beta:\kappa'.\;p)}{\assert}$ 
  \end{tabbedproof}

  For semantics, consider
  $\interp{\judgeA[\Theta; \Gamma; \Delta]
                  {[r/b](Q \beta:\kappa'.\;p)}{\assert}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\begin{array}{l}
            \interp{Q}_{\tau' \in \interp{\judgeSort{\kappa'}}\;\theta} \\
            \;\;\interp{\judgeA[\Theta, \beta:\kappa';\Gamma;\Delta]{[r/b]p}{\assert}}\;(\theta,\tau')\,\gamma\,\delta
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
            \interp{Q}_{\tau' \in \interp{\judgeSort[\Theta, \alpha:\kappa]{\kappa'}}\;\theta} \\
            \;\;\interp{\judgeA[\Theta, \beta:\kappa';\Gamma; \Delta, b:\upsilon'']{p}{\assert}}\;(\theta, \tau)\,\gamma\,(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)
           \end{array}}
          {Induction}
    \eline{\interp{\judgeA[\Theta;\Gamma;\Delta, b:\upsilon'']{Q \beta:\kappa'.\;p}{\assert}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta) }
          {Semantics}
  \end{eqnproof}
  In this case we silently use the fact that $\beta$ does not occur free in $e''$ or $B$.

\item Case \textsc{TEqual}: $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{p =_\omega q}{\assert}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{p}{\omega}$ \\
    \oo By inversion, $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{q}{\omega}$ \\
    \oo By inversion, $\judgeSort[\Theta]{\omega}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[r/b]p}{\omega}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[r/b]q}{\omega}$ \\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]{[r/b](p =_\omega q)}{\assert}$
  \end{tabbedproof}

  For the semantics, consider $\interp{\judgeA[\Theta; \Gamma; \Delta]{[r/b](p =_\omega q)}{\assert}}\;\theta\;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\mbox{if }\interp{[r/b]p}\theta\;\gamma\;\delta = \interp{[r/b]q}\theta\;\gamma\;\delta\mbox{ then }\top \mbox{ else } \bot}
          {Semantics}
    \eline{\mbox{if }\interp{p}\;\theta\;(\gamma, \interp{e''}\theta\;\gamma)\;\delta = \interp{q}\;\theta\;\gamma\;(\delta,  \interp{r}\theta\;\gamma\;\delta)\mbox{ then }\top \mbox{ else } \bot}
          {Induction}
    \eline{\interp{\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{(p =_\omega q)}{\assert}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{TPointsto}: $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{e \pointsto_A e'}{\assert}$

  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{e}{\reftype{A}}$ \\
    \oo By inversion, $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{e'}{A}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[r/b]e}{\reftype{A}}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[r/b]e'}{A}$ \\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]{[r/b](e \pointsto_A e')}{\assert}$
  \end{tabbedproof}

  For the semantics, consider $\interp{\judgeA[\Theta; \Gamma; \Delta]{[r/b](e \pointsto_A e')}{\assert}}\;\theta\;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\begin{array}{l}
           \interp{\judgeE[\Theta]{\Gamma}{[r/b]e}{\reftype{A}}}\;\theta\;\gamma \\ 
           \pointsto \\
           \interp{\judgeE[\Theta]{\Gamma}{[r/b]e'}{A}}\;\theta\;\gamma
           \end{array}}
          {Semantics}
    \eline{\interp{\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{e \pointsto_A e'}{\assert}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{TEqSort}: $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{p}{\omega}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeSortEq{\omega}{\omega'}$ \\
    \oo By inversion, $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{p}{\omega'}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[r/b]p}{\omega'}$ \\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]{[r/b]p}{\omega}$ \\
  \end{tabbedproof}

  For the semantics, consider $\interp{\judgeA[\Theta; \Gamma; \Delta]{[r/b]p}{\omega}}\;\theta\;\gamma\;\delta$ \\
  \begin{eqnproof}
    \eline{\interp{\judgeA[\Theta; \Gamma; \Delta]{[r/b]p}{\omega'}}\;\theta\;\gamma\;\delta}
          {Semantics}
    \eline{\interp{\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{p}{\omega'}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
          {Induction}
    \eline{\interp{\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{p}{\omega}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{TSpec}: $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{\validprop{S}}{\assert}$:
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeS[\Theta; \Gamma; \Delta, b:\upsilon'']{S}$ \\
    \oo By mutual induction $\judgeS[\Theta; \Gamma; \Delta]{[r/b]S}$\\
    \oo By rule, $\judgeA[\Theta; \Gamma; \Delta]{[r/b]\validprop{S}}{\assert}$
  \end{tabbedproof}

  For the semantics, consider $\interp{\judgeA[\Theta; \Gamma; \Delta]{[r/b]\validprop{S}}{\assert}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\mbox{if } \interp{[r/b]S}\;\theta\;\gamma\;\delta = \top \mbox{ then } \top \mbox{ else } \bot}
          {Semantics}
    \eline{\mbox{if } \interp{S}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta) = \top \mbox{ then } \top \mbox{ else } \bot}
          {Induction}
    \eline{\interp{\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{\validprop{S}}{\assert}}\; \theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{SpecTriple}: $\judgeS[\Theta; \Gamma; \Delta, b:\upsilon'']{\spec{p}{c}{a:A}{q}}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{p}{\assert}$ \\
    \oo By inversion, $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{\comp{c}}{\monad{A}}$ \\
    \oo By inversion, $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'', a:A]{q}{\assert}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[r/b]p}{\assert}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{\comp{[r/b]c}}{\monad{A}}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta, a:A]{[r/b]q}{\assert}$ \\
    \oo By rule, $\judgeS[\Theta; \Gamma; \Delta]{[r/b](\spec{p}{c}{a:A}{q})}$
  \end{tabbedproof}

  For the semantics, consider $\interp{\judgeS[\Theta; \Gamma; \Delta]{[r/b](\spec{p}{c}{a:A}{q})}}\;\theta;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\begin{array}{l}
           \{\interp{\judgeA[\Theta; \Gamma; \Delta]{[r/b]p}{\assert}}\;\theta\;\gamma\;\delta\} \\
           \interp{\judgeC{\Gamma}{[r/b]c}{A}}\;\theta\;\gamma \\
           \{v.\;\interp{\judgeA[\Theta; \Gamma, a:A; \Delta]{[r/b]q}{\assert}}\;\theta\;(\gamma,v)\;\delta\} 
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
           \{\interp{\judgeA[\Theta, \Gamma; \Delta]{p}{\assert}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)\} \\
           \interp{\judgeC[\Theta]{\Gamma}{c}{A}}\;\theta\;\gamma \\
           \{v.\;\interp{\judgeA[\Theta; \Gamma, a:A; \Delta, b:\upsilon'']{q}{\assert}}\;\theta\;(\gamma, v)\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)\} 
           \end{array}}
          {Induction}
    \eline{\interp{\judgeS[\Theta; \Gamma; \Delta, b:\upsilon'']{(\spec{p}{c}{a:A}{q})}}\;\theta;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{SpecMTriple}: $\judgeS[\Theta; \Gamma; \Delta, b:\upsilon'']{\mspec{p}{e}{a:A}{q}}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{p}{\assert}$ \\
    \oo By inversion, $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{e}{\monad{A}}$ \\
    \oo By inversion, $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'', a:A]{q}{\assert}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[r/b]p}{\assert}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta]{[r/b]e}{\monad{A}}$ \\
    \oo By induction, $\judgeA[\Theta; \Gamma; \Delta, a:A]{[r/b]q}{\assert}$ \\
    \oo By rule, $\judgeS[\Theta; \Gamma; \Delta]{[r/b](\mspec{p}{e}{a:A}{q})}$
  \end{tabbedproof}

  For the semantics, consider $\interp{\judgeS[\Theta; \Gamma; \Delta]{[r/b](\mspec{p}{e}{a:A}{q})}}\;\theta;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\begin{array}{l}
           \{\interp{\judgeA[\Theta; \Gamma; \Delta]{[r/b]p}{\assert}}\;\theta\;\gamma\;\delta\} \\
           \interp{\judgeE{\Gamma}{[r/b]e}{\monad{A}}}\;\theta\;\gamma \\
           \{v.\;\interp{\judgeA[\Theta; \Gamma, a:A; \Delta]{[r/b]q}{\assert}}\;\theta\;(\gamma,v)\;\delta\} 
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
           \{\interp{\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{p}{\assert}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)\} \\
           \interp{\judgeE{\Gamma}{e}{\monad{A}}}\;\theta\;\gamma \\
           \{v.\;\interp{\judgeA[\Theta; \Gamma, a:A; \Delta, b:\upsilon'']{q}{\assert}}\;\theta\;(\gamma, v)\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)\} 
           \end{array}}
          {Induction}
    \eline{\interp{\judgeS[\Theta; \Gamma; \Delta, b:\upsilon'']{(\mspec{p}{e}{a:A}{q})}}\;\theta;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{SpecQuantify1}: $\judgeS[\Theta; \Gamma; \Delta, b:\upsilon'']{Q u:\upsilon.\;S}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeS[\Theta; \Gamma; \Delta, b:\upsilon'', u:\upsilon]{S}$ \\
    \oo By induction, $\judgeS[\Theta; \Gamma; \Delta, u:\upsilon]{[r/b]S}$ \\
    \oo By rule, $\judgeS[\Theta; \Gamma; \Delta]
                         {Q u:\upsilon.\;[r/b]S}$ \\
    \oo By def of subst, $\judgeS[\Theta; \Gamma; \Delta]
                                 {[r/b](Q u:\upsilon.\;S)}$ 
  \end{tabbedproof}

  For semantics, consider
  $\interp{\judgeS[\Theta; \Gamma; \Delta]
                  {[r/b](Q u:\upsilon.\;S)}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\begin{array}{l}
            \interp{Q}_{v \in \interp{\judgeSort{\upsilon}}\;\theta} \\
            \;\;\interp{\judgeS[\Theta;\Gamma;\Delta, u:\upsilon]{[r/b]S}}\;\theta\,\gamma\,(\delta,v)
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
            \interp{Q}_{v \in \interp{\judgeSort[\Theta]{\upsilon}}\;\theta} \\
            \;\;\interp{\judgeS[\Theta;\Gamma; \Delta, b:\upsilon'', u:\upsilon]{S}}\;\theta\,\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta,v)
           \end{array}}
          {Induction}
    \eline{\interp{\judgeS[\Theta;\Gamma; \Delta, b:\upsilon'']{Q u:\upsilon.\;S}}\;\theta\,\gamma\,(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{SpecQuantify2}: $\judgeS[\Theta; \Gamma; \Delta, b:\upsilon'']{Q x:A.\;S}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeS[\Theta; \Gamma, x:A; \Delta, b:\upsilon'']{S}$ \\
    \oo By induction, $\judgeS[\Theta; \Gamma, x:A; \Delta]{[r/b]S}$ \\
    \oo By rule, $\judgeS[\Theta; \Gamma; \Delta]
                         {Q x:A.\;[r/b]S}$ \\
    \oo By def of subst, $\judgeS[\Theta; \Gamma; \Delta]
                                 {[r/b](Q x:A.\;S)}$ 
  \end{tabbedproof}

  For semantics, consider
  $\interp{\judgeS[\Theta; \Gamma; \Delta]
                  {[r/b](Q x:A.\;S)}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\begin{array}{l}
            \interp{Q}_{v \in \interp{\judgeSort{A}}\;\theta} \\
            \;\;\interp{\judgeS[\Theta;\Gamma, x:A;\Delta]{[r/b]S}}\;\theta\,(\gamma,v)\,\delta
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
            \interp{Q}_{v \in \interp{\judgeSort[\Theta]{A}}\;\theta} \\
            \;\;\interp{\judgeS[\Theta;\Gamma, x:A;\Delta, b:\upsilon'']{S}}\;\theta\,(\gamma,v)\,(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)
           \end{array}}
          {Induction}
    \eline{\interp{\judgeS[\Theta;\Gamma;\Delta, b:\upsilon'']{Q x:A.\;S}}\;\theta\,\gamma\,(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{SpecQuantify3}: $\judgeS[\Theta; \Gamma; \Delta, b:\upsilon'']{Q \beta:\kappa'.\;S}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeS[\Theta, \beta:\kappa'; \Gamma; \Delta, b:\upsilon'']{S}$ \\
    \oo By induction, $\judgeS[\Theta, \beta:\kappa'; \Gamma; \Delta]{[r/b]S}$ \\
    \oo By rule, $\judgeS[\Theta; \Gamma; \Delta]
                         {Q \beta:\kappa'.\;[r/b]S}$ \\
    \oo By def of subst, $\judgeS[\Theta; \Gamma; \Delta]
                                 {[r/b](Q \beta:\kappa'.\;S)}$ 
  \end{tabbedproof}

  For semantics, consider
  $\interp{\judgeS[\Theta; \Gamma; \Delta]
                  {[r/b](Q \beta:\kappa'.\;S)}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\begin{array}{l}
            \interp{Q}_{\tau' \in \interp{\judgeSort{\kappa'}}\;\theta} \\
            \;\;\interp{\judgeS[\Theta, \beta:\kappa';\Gamma;\Delta]{[r/b]S}}\;(\theta,\tau')\,\gamma\,\delta
           \end{array}}
          {Semantics}
    \eline{\begin{array}{l}
            \interp{Q}_{\tau' \in \interp{\judgeSort[\Theta]{\kappa'}}\;\theta} \\
            \;\;\interp{\judgeS[\Theta, \beta:\kappa';\Gamma;\Delta, b:\upsilon'']{S}}\;(\theta, \tau')\,\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta,v)
           \end{array}}
          {Induction}
    \eline{\interp{\judgeS[\Theta;\Gamma;\Delta, b:\upsilon'']{Q \beta:\kappa'.\;S}}\;\theta\,\gamma\,(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
          {Semantics}
  \end{eqnproof}


\item Case \textsc{SpecBinary}: $\judgeS[\Theta; \Gamma; \Delta, b:\upsilon'']{S \oplus S'}$
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeS[\Theta; \Gamma; \Delta, b:\upsilon'']{S}$\\
    \oo By inversion, $\judgeS[\Theta; \Gamma; \Delta, b:\upsilon'']{S'}$\\
    \oo By induction, $\judgeS[\Theta; \Gamma; \Delta]{[r/b]S}$\\
    \oo By induction, $\judgeS[\Theta; \Gamma; \Delta]{[r/b]S'}$\\
    \oo By rule, $\judgeS[\Theta; \Gamma; \Delta]{[r/b]S \oplus [r/b]S'}$\\
    \oo By subst def, $\judgeS[\Theta; \Gamma; \Delta]{[r/b](S \oplus S')}$\\
  \end{tabbedproof}

  For semantics, consider $\interp{\judgeS[\Theta; \Gamma; \Delta]{[r/b](S \oplus S')}}\;\theta\;\gamma\;\delta$
  \begin{eqnproof}
    \eline{\begin{array}{l}
             (\interp{\judgeS[\Theta; \Gamma; \Delta]{[r/b]S}}\;\theta\;\gamma\;\delta) \;\interp{\oplus} \\
             \;\;(\interp{\judgeS[\Theta; \Gamma; \Delta]{[r/b]S'}}\;\theta\;\gamma\;\delta) 
      \end{array}}
    {Semantics}
    \eline{\begin{array}{l}
             (\interp{\judgeS[\Theta; \Gamma; \Delta, b:\upsilon'']{S}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)) \interp{\oplus} \\
             \;\;(\interp{\judgeS[\Theta; \Gamma; \Delta, b:\upsilon'']{S'}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)) 
      \end{array}}
    {Induction}
    \eline{\interp{\judgeS[\Theta; \Gamma; \Delta, b:\upsilon'']{S \oplus S'}}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
          {Semantics}
  \end{eqnproof}

\item Case \textsc{TSpec}: $\judgeS[\Theta; \Gamma; \Delta, b:\upsilon'']{\setof{p}}$:
  
  First, the syntax:
  \begin{tabbedproof}
    \oo By inversion, $\judgeA[\Theta; \Gamma; \Delta, b:\upsilon'']{p}{\assert}$ \\
    \oo By mutual induction $\judgeA[\Theta; \Gamma; \Delta]{[r/b]p}{\assert}$\\
    \oo By rule, $\judgeS[\Theta; \Gamma; \Delta]{[r/b]\setof{p}}$
  \end{tabbedproof}

  For the semantics, consider $\interp{\judgeS[\Theta; \Gamma; \Delta]{[r/b]\setof{p}}}\;\theta\;\gamma\;\delta$ 
  \begin{eqnproof}
    \eline{\mbox{if } \interp{[r/b]p}\;\theta\;\gamma\;\delta = \top \mbox{ then } \top \mbox{ else } \bot}
          {Semantics}
    \eline{\mbox{if } \interp{p}\;\theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta) = \top \mbox{ then } \top \mbox{ else } \bot}
          {Induction}
    \eline{\interp{\judgeS[\Theta; \Gamma; \Delta, b:\upsilon'']{\setof{p}}}\; \theta\;\gamma\;(\delta, \interp{\judgeA{r}{\upsilon''}}\;\theta\;\gamma\;\delta)}
          {Semantics}
  \end{eqnproof}

\end{enumerate}

\end{proof}




\subsection{Soundness of Assertion Logic Axioms}

\begin{lemma}{(Getting Specs Into Assertions)} 
  If $\judgeS{S}$ is valid, then $\judgeA{\validprop{S}}{\assert}$ is valid. 
\end{lemma}
\begin{proof}
  Assume we have a suitable $\theta, \gamma,$ and $\delta$. By hypothesis we know
$\interp{\judgeS{S}}\;\theta\;\gamma\;\delta$ $=$ $\top$ in the specification lattice. However,
we know the interpretation of $\interp{\judgeA{\validprop{S}}{\assert}}\;\theta\;\gamma\;\delta$ is 
equal to $\IfTE{\interp{\judgeS{S}}\;\theta\;\gamma\;\delta = \top}{\top}{\bot}$, so it 
follows that $\interp{\judgeA{\validprop{S}}{\assert}}\;\theta\;\gamma\;\delta = \top$ in the assertion
lattice. Hence it is true for all substitutions, and is therefore valid. 
\end{proof}\\

\begin{lemma}{(Getting Assertions out of Specs)}
If $\judgeA{p}{\assert}$, then $\judgeA{\validprop{\setof{p}} \implies p}{\assert}$ is valid. 
\end{lemma}
\begin{proof}
\begin{tabbedproof}
\oo Assume we have $\judgeA{p}{\assert}$ and a suitable $\theta, \gamma,$ and $\delta$. \\ 
\oo We want to show that $\interp{\judgeA{\validprop{\setof{p}} \implies
    p}{\assert}}\;\theta\;\gamma\;\delta$ is equal to $\top$.  \\
\oo This is equivalent to every $h \in H$ being in 
    $\interp{\judgeA{\validprop{\setof{p}} \implies p}{\assert}}\;\theta\;\gamma\;\delta$ \\
\oo From the semantics of implication, we want to show that \\ 
\ooo if $h \in \interp{\judgeA{\validprop{\setof{p}}}{\assert}}\;\theta\;\gamma\;\delta$, 
     then  $h \in \interp{\judgeA{p}{\assert}}\;\theta\;\gamma\;\delta$. \\
\oo Assume we have an $h \in \interp{\judgeA{\validprop{\setof{p}}}{\assert}}\;\theta\;\gamma\;\delta$. \\
\ooo We know  $\IfTE{\interp{\judgeS{\setof{p}}}\;\theta\;\gamma\;\delta = \top}{\top}{\bot}$ \\
\ooo Since we have an $h$ in this set,  $\interp{\judgeS{\setof{p}}}\;\theta\;\gamma\;\delta = \top$. \\
\ooo However,  $\interp{\judgeS{\setof{p}}}\;\theta\;\gamma\;\delta = \IfTE{\interp{\judgeA{p}{\assert}}\;\theta\;\gamma\;\delta = \top}{\top}{\bot}$ \\
\ooo So $\interp{\judgeA{p}{\assert}}\;\theta\;\gamma\;\delta = \top$. \\ 
\ooo Since this is the full set of heaps $H$, it follows that $h \in \interp{\judgeA{p}{\assert}}\;\theta\;\gamma\;\delta$. 
\end{tabbedproof}
\end{proof}


\begin{lemma}{(Soundness of Equality)}
  If $\judgeEqA{p}{q}{\omega}$ is a valid equality, then $\judgeA{p =_\omega q}{\assert}$ is valid.
\end{lemma}
\begin{proof}
\begin{tabbedproof}
\oo Assume $\judgeEqA{p}{q}{\omega}$ is a valid equality \\
\oo Assume we have a suitable $\theta, \gamma,$ and $\delta$. \\ 
\ooo Then we know that $\interp{\judgeA{p}{\assert}}\;\theta\;\gamma\;\delta = \interp{\judgeA{q}{\omega}}\;\theta\;\gamma\;\delta$. \\
\ooo By semantics $\interp{\judgeA{p =_\omega q}{\assert}}\;\theta\;\gamma\;\delta = $
\ooox $\IfTE{\interp{\judgeA{p}{\omega}}\;\theta\;\gamma\;\delta = \interp{\judgeA{q}{\omega}}\;\theta\;\gamma\;\delta}{\top}{\bot}$ \\
\ooo Therefore $\interp{\judgeA{p =_\omega q}{\assert}}\;\theta\;\gamma\;\delta = \top$ \\
\oo Therefore $\judgeA{p =_\omega q}{\assert}$ is valid.
\end{tabbedproof}
\end{proof}

\subsection{Soundness of Program Logic Axioms}

\begin{lemma}{(Validity and Classical and Intuitionistic Implication)}
The statement that $\judgeS{S_1 \specimp S_2}$ is valid is logically equivalent to: if
for all $\theta, \gamma, \delta$ and $r$, if $r \in \interp{\judgeS{S_1}}\;\theta\;\gamma\;\delta$ then $r \in \interp{\judgeS{S_2}}\;\theta\;\gamma\;\delta$  
\end{lemma}

\begin{proof}
  \begin{tabbedproof}
    \oo $\To$ direction:\\
    \ooo Assume $\judgeS{S_1 \specimp S_2}$ is valid\\
    \oooo We want to show for all $\theta, \gamma, \delta$ and $r$, if $r \in \interp{\judgeS{S_1}}\;\delta$, then\\
    \ooox $r \in \interp{\judgeS{S_2}}\;\theta\;\gamma\;\delta$ \\
    \oooo Assume appropriate $\theta\;\gamma\;\delta$, and $r$ such that $r \in \interp{\judgeS{S_1}}\;\theta\;\gamma\;\delta$ \\
    \ooooo We want to show $r \in \interp{\judgeS{S_2}}\;\theta\;\gamma\;\delta$ \\
    \oooooo From the hypothesis we know that $\interp{\judgeS{S_1 \specimp S_2}}\;\theta\;\gamma\;\delta = \top$ \\
    \oooooo So we know for all $r$ and $s \worldgeq r$, that \\
    \oooooox if $s \in \interp{\judgeS{S_1}}\;\theta\;\gamma\;\delta$ then $s \in \interp{\judgeS{S_2}}\;\theta\;\gamma\;\delta$ \\
    \oooooo Since $r \worldgeq r$, we know \\
    \oooooox if $r \in \interp{\judgeS{S_1}}\;\theta\;\gamma\;\delta$ then $s \in \interp{\judgeS{S_2}}\;\theta\;\gamma\;\delta$ \\
    \oooooo Since $r \in \interp{\judgeS{S_1}}\;\theta\;\gamma\;\delta$, we know that $r \in \interp{\judgeS{S_2}}\;\theta\;\gamma\;\delta$ \\
    \oo $\From$ direction:\\
    \ooo Assume for all $\theta\;\gamma\;\delta$ and $r$, \\
    \ooox if $r \in \interp{\judgeS{S_1}}\;\theta\;\gamma\;\delta$, then 
          $r \in \interp{\judgeS{S_2}}\;\theta\;\gamma\;\delta$ \\
    \ooo We want to show for all $\theta\;\gamma\;\delta$ that $\interp{\judgeS{S_1 \specimp S_2}}\;\theta\;\gamma\;\delta = \top$ \\
    \ooo Assume $\theta\;\gamma\;\delta$ are suitable substitutions \\
    \oooo So we want to show $\interp{\judgeS{S_1 \specimp S_2}}\;\theta\;\gamma\;\delta = \top$ \\
    \oooo So we want to show for all $r$ and $s \worldgeq r$, that \\
    \oooox if $s \in \interp{\judgeS{S_1}}\;\theta\;\gamma\;\delta$ then $s \in \interp{\judgeS{S_2}}\;\theta\;\gamma\;\delta$ \\
    \oooo Assume $r$ and $s$ such that $s \worldgeq r$ and $s \in \interp{\judgeS{S_1}}\;\theta\;\gamma\;\delta$ \\
    \ooooo Instantiate the quantifier in the hypothesis with $\theta\;\gamma\;\delta$ and $s$, so we learn \\
    \ooooox if $s \in \interp{\judgeS{S_1}}\;\theta\;\gamma\;\delta$ then $s \in \interp{\judgeS{S_2}}\;\theta\;\gamma\;\delta$ \\
    \ooooo Since $s \in \interp{\judgeS{S_1}}\;\theta\;\gamma\;\delta$ we see that $s \in \interp{\judgeS{S_2}}\;\theta\;\gamma\;\delta$ \\
  \end{tabbedproof}
\end{proof}

\begin{lemma}{(Equivalence of the Two Forms of Triples)}
We have that $\judgeS{\spec{p}{c}{a:A}{q}}$ is valid if and only if $\judgeS{\mspec{p}{\comp{c}}{a:A}{q}}$ is valid.
\end{lemma}

\begin{proof}
\begin{tabbedproof}
\oo We want to show that for all suitable $\theta, \gamma$, and $\delta$, $\judgeS{\spec{p}{c}{a:A}{q}} = \top$  \\
\ox iff $\judgeS{\mspec{p}{\comp{c}}{a:A}{q}} = \top$  \\
\oo Now, let \\
\oox $P = \interp{\judgeA{p}{\assert}}\;\theta\;\gamma\;\delta$ \\
\oox $E = \interp{\judgeE[\Theta]{\Gamma}{[c]}{A}}\; \theta\;\gamma$ \\
\oox $C = \interp{\judgeC[\Theta]{\Gamma}{c}{A}}\; \theta\;\gamma$ \\
\oox $Q = \semfun{v}{\interp{\judgeA[\Theta;\Gamma, a:A; \Delta]{q}{\assert}}\;\theta\;\gamma\;\theta\;(\gamma, v)\;\delta}$ \\
\oo Observe that $E = C$, from the semantics of $\comp{c}$ \\
\oo $\Rightarrow$: Assume $\judgeS{\spec{p}{c}{a:A}{q}}$ is valid \\
\ooo Hence the semantic spec $\spec{P}{C}{a}{Q(a)} = \top$ \\
\ooo Hence $\spec{P}{E}{a}{Q(a)} = \top$ \\
\oo $\Leftarrow$: Assume $\judgeS{\mspec{p}{\comp{c}}{a:A}{q}}$ is valid \\
\ooo Hence the semantic spec $\spec{P}{E}{a}{Q(a)} = \top$ \\
\ooo Hence $\spec{P}{C}{a}{Q(a)} = \top$
\end{tabbedproof}
\end{proof}


\begin{lemma}{(Return Value Axiom)}
The schema $\judgeS{\spec{P}{e}{a:A}{P \land a = e}}$ is valid.
\end{lemma}

\begin{proof}
\begin{tabbedproof}
\oo We want to show that for all suitable $\theta, \gamma,$ and $\delta$, $\interp{\spec{P}{e}{a:A}{P \land a = e}}\;\theta\;\gamma\;\delta = \top$ \\
\oo Now let \\
\oox $P = \interp{\judgeA{p}{\assert}}\;\theta\;\gamma\;\delta$ \\
\oox $C = \interp{\judgeC[\Theta]{\Gamma}
                  {e}{A}} \;\theta
                          \;\gamma$ \\
\oox $E = \interp{\judgeE[\Theta]{\Gamma}
                  {e}{A}} \;\theta
                          \;\gamma$ \\
\oox $Q = \semfun{v}{\interp{\judgeA[\Theta; \Gamma, a:A; \Delta]{P \land a = e}{\assert}}\;\theta\;(\gamma, v)\;\delta}$ \\
\oo We want to show that $\spec{P}{C}{a}{Q(a)} = \top$ \\
\oo So we want to show that for all $R$, we have $R \in \spec{P}{C}{a}{Q(a)}$ \\
\oo Hence it suffices to show that $\basicspec{P * R}{C}{v}{P \land \interp{a = e}\;\theta\;(\gamma, v)\;\delta * R}$ \\
\oo So we want to show that for all $h \in P * R$, \\
\oox we have $C\;\mathit{Best}(\semfun{v}{P \land \interp{a = e * R}\;\theta\;(\gamma, v)\;\delta})\;h = \bot$ \\
\oo Assume we have $h \in P * R$ \\
\ooo Next, observe that $C\;k\;h = k\;E\;h$ \\
\ooo To show that $\mathit{Best}(\semfun{a}{P \land a = e * R})\;E\;h = \bot$, \\
\oox we need to show that $k\;\;E\;h = \bot$, for every $k \in \mathit{Approx}(\semfun{a}{P \land a = e *R})$ \\
\ooo So assume $k \in \mathit{Approx}(\semfun{v}{P \land \interp{a = e}\;\theta\;(\gamma, v)\;\delta * R})$ \\
\oooo Therefore for all $v \in \interp{A}$, and $h \in Q(v) * R$, we know $k\;v\;h = \bot$ \\
\oooo We know $E \in \interp{A}$ \\
\oooo So we need to show that given $h \in P * R$, we have $h \in Q(E) * R$ \\
\ooooo Assume we have $h \in P * R$ \\
\ooooo So we need to show $h \in (P \land \interp{a = e}\;(\delta,E)) * R$ \\
\ooooo Note that $\interp{a = e}\;(\delta,E) = \top$ if $E = E$, which is true \\
\ooooo Hence $P = (P \land \interp{a = e}\;(\delta,E))$ \\
\ooooo Hence we need to show $h \in P * R$ \\
\ooooo This is a hypothesis, so we are done \\
\end{tabbedproof}
\end{proof}


\begin{lemma}{(Assignment Axiom)}
$\judgeS{\spec{e \pointsto_A -}{e := e'}{a:\unittype}{e \pointsto_A e'}}$ is valid  
\end{lemma}
\begin{proof}
  \begin{tabbedproof}
    \oo Assume suitable $\theta$, $\gamma$, and $\delta$ \\
    \ooo We want to show $\interp{\judgeS{\spec{e \pointsto_A -}{e := e'}{a:\unittype}{e \pointsto_A e'}}}\;\theta\;\gamma\;\delta = \top$ \\
    \ooo So we want to show $\forall r.\; r \in \interp{\judgeS{\spec{e \pointsto_A -}{e := e'}{a:\unittype}{e \pointsto_A e'}}}\;\theta\;\gamma\;\delta$ \\
    \ooo Assume $r$ \\
    \oooo We want to show $r \in \interp{\judgeS{\spec{e \pointsto_A -}{e := e'}{a:\unittype}{e \pointsto_A e'}}}\;\theta\;\gamma\;\delta$ \\
    \oooo Let $P = \interp{\judgeA{e \pointsto_A -}{\assert}}\;\theta\;\gamma\;\delta$ \\
    \oooo Let $C = \interp{\judgeE[\Theta]{\Gamma}{\comp{e := e'}}{\monad{A}}}\;\theta\;\gamma$ \\
    \oooo Let $E = \interp{\judgeE[\Theta]{\Gamma}{e}{\reftype{A}}}\;\theta\;\gamma$ \\
    \oooo Let $E' = \interp{\judgeE[\Theta]{\Gamma}{e'}{A}}\;\theta\;\gamma$ \\
    \oooo let $Q = \semfun{v}{\interp{\judgeA{e \pointsto_A e'}{\assert}}\;\theta\;(\gamma, v)\;\delta}$ \\
    \oooo We want to show $r \in \spec{P}{C}{a:A}{Q(a)}$ \\
    \oooo We want to show $\forall s \succeq r.\; \basicspec{P * s}{C}{a:A}{Q(a) * s}$ \\
    \oooo Assume $s \succeq r$ \\
    \ooooo We want to show $\basicspec{P * s}{C}{a:A}{Q(a) * s}$ \\
    \ooooo We want to show $\forall h \in (P * s).\; C\;Best(\semfun{a}{Q(a) * s})\;h = \bot$ \\
    \ooooo Assume $h \in P * s$ \\
    \oooooo By semantics $h \in P * s$ means $\exists h_1, h_2.\; h_1 \in P$, $h_2 \in s$, and
            $h_1 \# h_2$ \\
    \oooooo By semantics of assertions, $h_1 \in P$ means 
            $\exists v \in \interp{\judgeWK[\Theta]{A}{\bigstar}}\;\theta.\;
               h_1 = [E:v]$ \\
    \oooooo Expanding definitions, 
             $C = \semfun{k}{\semfun{h}{k\;\unit\;\mbox{if } E\in\domain{h} \mbox{ then } [h|E:E'] \mbox{ else }\top}}$ \\
    \oooooo Therefore $C\;Best(\semfun{a}{Q(a) * s})\;h = $ \\
    \oooooox $\mbox{if }E\in\domain{h_1 \cdot h_2} \mbox{ then }Best(\semfun{a}{Q(a) * s})\;\unit\;[h_1 \cdot h_2|E:E'] \mbox{ else } \top$ \\
    \oooooo Since $E \in \domain{h_1}$, we know $C\;Best(\semfun{a}{Q(a) * s})\;h = $ \\
    \oooooox $Best(\semfun{a}{Q(a) * s})\;\unit\;[h_1 \cdot h_2|E:E']$ \\
    \oooooo Therefore we want to show $Best(\semfun{a}{Q(a) * s})\;\unit\;[h_1 \cdot h_2|E:E'] = \bot$ \\
    \oooooo So we must show $\lnot \exists k \in Approx(\semfun{a}{Q(a) * s}).\; k\;\unit\;[h_1 \cdot h_2|E'] = \top$ \\
    \oooooo So we must show $\forall k \in Approx(\semfun{a}{Q(a) * s}).\; k\unit\;[h_1\cdot h_2|E:E'] = \bot$ \\
    \oooooo Assume $k \in Approx(\semfun{a}{Q(a) * s})$ \\
    \ooooooo Since $[h_1\cdot h_2|E:E'] = [E:E']\cdot h_2$, we want 
             $k\unit\;([E:E']\cdot h_2) = \bot$ \\
    \ooooooo Now, $k \in Approx(\semfun{a}{Q(a) * s})$ means $\forall v, h \in (Q(v) * s)\; k\;v\;h = \bot$ \\
    \ooooooo Now, instantiate the quantifier with $\unit$ and $[E:E']\cdot h_2$ \\
    \ooooooo Now we must check $[E:E']\cdot h_2 \in Q(\unit) * s$ \\
    \ooooooo We will check that $[E:E'] \in Q(\unit)$ and $h_2 \in s$ \\
    \ooooooo By semantics of assertions $Q(\unit) = \setof{[E:E']}$, so $[E:E'] \in Q(\unit)$ \\
    \ooooooo From line 19, $h_2 \in s$ \\
    \ooooooo Since $[E:E']$ has the same domain as $h_1$, we know $[E:E'] \# h_2$ \\
    \ooooooo Therefore $[E:E']\cdot h_2 \in Q(\unit) * s$ \\
    \ooooooo Therefore $k\unit\;[h_1\cdot h_2|E:E'] = \bot$ \\
    \oooooo Therefore $\forall k \in Approx(\semfun{a}{Q(a) * s}).\; k\unit\;[h_1\cdot h_2|E:E'] = \bot$ \\
    \oooooo Therefore $\lnot \exists k \in Approx(\semfun{a}{Q(a) * s}).\; k\;\unit\;[h_1 \cdot h_2|E'] = \top$ \\
    \oooooo Therefore $Best(\semfun{a}{Q(a) * s})\;\unit\;[h_1 \cdot h_2|E:E'] = \bot$ \\
    \ooooo Therefore $\forall h \in (P * s).\; C\;Best(\semfun{a}{Q(a) * s})\;h = \bot$ \\
    \ooooo Therefore $\basicspec{P * s}{C}{a:A}{Q(a) * s}$ \\
    \oooo Therefore $\forall s \succeq r.\; \basicspec{P * s}{C}{a:A}{Q(a) * s}$ \\
    \oooo Therefore $r \in \spec{P}{C}{a:A}{Q(a)}$ \\
    \ooo Therefore $\forall r.\; r \in \interp{\judgeS{\spec{e \pointsto_A -}{e := e'}{a:\unittype}{e \pointsto_A e'}}}\;\theta\;\gamma\;\delta$ \\
    \ooo Therefore $\interp{\judgeS{\spec{e \pointsto_A -}{e := e'}{a:\unittype}{e \pointsto_A e'}}}\;\theta\;\gamma\;\delta = \top$ \\
  \end{tabbedproof}
\end{proof}



\begin{lemma}{(Allocation Axiom)}
If $\judgeS{\spec{\emp}{\newref{A}{e}}{a:\reftype{A}}{a \pointsto e}}$ is valid
\end{lemma}
\begin{proof}
  \begin{tabbedproof}
    \oo Assume suitable $\theta$, $\gamma$, and $\delta$ \\
    \ooo We want to show $\interp{\judgeS{\spec{\emp}{\newref{A}{e}}{a:\reftype{A}}{a \pointsto e}}}\theta\;\gamma\;\delta = \top$ \\
    \ooo So we want to show $\forall r.\; r \in \interp{\judgeS{\spec{\emp}{\newref{A}{e}}{a:\reftype{A}}{a \pointsto e}}}\theta\;\gamma\;\delta$ \\
    \ooo Assume $r$, \\
    \oooo So we want to show $r \in \interp{\judgeS{\spec{\emp}{\newref{A}{e}}{a:\reftype{A}}{a \pointsto e}}}\theta\;\gamma\;\delta$ \\
    \oooo Let $C = \interp{\judgeE{\Gamma}{\comp{\newref{A}{e}}}{\monad{\reftype{A}}}\;\theta}\;\gamma$ \\
    \oooo Let $E = \interp{\judgeE{\Gamma}{e}{A}\;\theta}\;\gamma$ \\
    \oooo Let $Q = \semfun{v}{\interp{\judgeA[\Delta, a:\reftype{A}]{a \pointsto_A e}{\assert}}\;\theta\;(\gamma, v)\;\delta}$ \\
    \oooo So we want to show $r \in \spec{I}{C}{a:A}{Q(a)}$ \\
    \oooo So we want to show $\forall s \succeq r.\; \basicspec{s}{C}{a:A}{Q(a)*s}$ \\
    \oooo Assume $s \succeq r$ \\
    \ooooo We want to show $\basicspec{s}{C}{a:A}{Q(a)*s}$ \\
    \ooooo We want to show $\forall h \in s.\; C\;Best(\semfun{a}{Q(a)*s})\;h = \bot$ \\
    \ooooo Assume $h \in s$ \\
    \oooooo Expanding definitions, $C\;Best((\semfun{a}{Q(a)*s})\;h = $ \\
    \oooooox let $l = \newloc{h}{A}, [\theta(A)])$ in $Best(\semfun{a}{Q(a)*s})\;l\;[h|l:E]$ \\
    \oooooo So let $l = \newloc{h}{A}$ \\
    \oooooo We want to show $Best(\semfun{a}{Q(a)*s})\;l\;[h|l:E] = \bot$ \\
    \oooooo To show this, we must show $\lnot (\exists k \in Approx(\semfun{a}{Q(a)*s}).\;k\;l\;[h|l:E] = \top)$ \\
    \oooooo So we must show $\forall k \in Approx(\semfun{a}{Q(l)*s}).\;k\;l\;[h|l:E] = \bot)$ \\
    \oooooo Assume $k \in Approx(\semfun{a}{Q(a)*s})$ \\
    \ooooooo This means $\forall v, h \in Q(v)*s.\; k\;v\;h = \bot$ \\
    \ooooooo Instantiate $v$ with $l$, and $h$ with $[l:E]\cdot h$ \\
    \ooooooo Now we must check $[l:E]\cdot h \in Q(l) * s$ \\
    \ooooooo So we will check $[l:E] \in Q(l)$ and $h \in s$ \\
    \ooooooo Expanding definitions, $Q(l) = \setof{[l:E]}$, so $[l:E] \in Q(l)$ \\
    \ooooooo From line 18, $h \in s$ \\
    \ooooooo Since $l$ is bigger than anything in $\domain{h}$, it follows $[l:E] \# h$ \\
    \ooooooo Therefore $[l:E]\cdot h \in Q(l) * s$ \\
    \ooooooo Therefore $k\;l\;([l:E]\cdot h) = \bot$ \\
    \oooooo Therefore $\forall k \in Approx(\semfun{a}{Q(l)*s}).\;k\;l\;[h|l:E] = \bot)$ \\
    \ooooo Therefore $\forall h \in s.\; C\;Best(\semfun{a}{Q(a)*s})\;h = \bot$ \\
    \ooooo Therefore $\basicspec{s}{C}{a:A}{Q(a)*s}$ \\
    \oooo Therefore $\forall s \succeq r.\; \basicspec{s}{C}{a:A}{Q(a)*s}$ \\
    \oooo Therefore $r \in \spec{I}{C}{a:A}{Q(a)}$ \\
    \ooo Therefore $\forall r.\; r \in \interp{\judgeS{\spec{\emp}{\newref{A}{e}}{a:\reftype{A}}{a \pointsto e}}}\theta\;\gamma\;\delta$ \\
    \ooo Therefore $\interp{\judgeS{\spec{\emp}{\newref{A}{e}}{a:\reftype{A}}{a \pointsto e}}}\theta\;\gamma\;\delta = \top$ \\
  \end{tabbedproof}
\end{proof}

\begin{lemma}{(Read Axiom)}
We have that $\judgeS{\spec{e \pointsto_A e'}{!e}{a:A}{e \pointsto_A e' \land a = e'}}$ is valid.\end{lemma}
\begin{proof}
  \begin{tabbedproof}
    \oo Assume suitable $\theta$, $\gamma$, and $\delta$ \\
    \ooo We want to show $\interp{\judgeS{\spec{e \pointsto_A e'}{!e}{a:A}{e \pointsto e' \land a = e'}}}\theta\;\gamma\;\delta = \top$ \\
    \ooo So we want to show $\forall r.\; r \in \interp{\judgeS{\spec{e \pointsto_A e'}{!e}{a:A}{e \pointsto e' \land a = e'}}}\theta\;\gamma\;\delta$ \\
    \ooo Assume $r$, \\
    \oooo So we want to show $r \in r \in \interp{\judgeS{\spec{e \pointsto_A e'}{!e}{a:A}{e \pointsto e' \land a = e'}}}\theta\;\gamma\;\delta$ \\
    \oooo Let $P = \interp{\judgeA{e \pointsto_A e'}{\assert}}\;\theta\;\gamma\;\delta$ \\
    \oooo Let $C = \interp{\judgeE{\Gamma}{\comp{!e}}{\monad{A}}\;\theta}\;\gamma$ \\
    \oooo Let $E = \interp{\judgeE{\Gamma}{e}{\reftype{A}}\;\theta}\;\gamma$ \\
    \oooo Let $E' = \interp{\judgeE{\Gamma}{e'}{A}\;\theta}\;\gamma$ \\
    \oooo Let $Q = \semfun{v}{\interp{\judgeA[\Theta; \Gamma, a:\reftype{A}; \Delta]{e \pointsto_A e' \land a = e'}{\assert}}\;\theta\;(\gamma, v)\;\delta}$ \\
    \oooo So we want to show $r \in \spec{P}{C}{a:A}{Q(a)}$ \\
    \oooo So we want to show $\forall s \succeq r.\; \basicspec{P*s}{C}{a:A}{Q(a)*s}$ \\
    \oooo Assume $s \succeq r$ \\
    \ooooo We want to show $\basicspec{P*s}{C}{a:A}{Q(a)*s}$ \\
    \ooooo We want to show $\forall h \in P*s.\; C\;Best(\semfun{a}{Q(a)*s})\;h = \bot$ \\
    \ooooo Assume $h \in P*s$ \\
    \oooooo There are $h_1$ and $h_2$ such that $h_1 \in P$, and $h_2 \in s$, and $h_1 \# h_2$ \\
    \oooooo Expanding definitions, $C\;Best(\semfun{a}{Q(a)*s})\;(h_1 \cdot h_2) = $ \\
    \oooooox if $E \in \domain{h}$ then $Best(\;(h\;E)\;h$ else $\top$ \\
    \oooooo From definition of $P$, $h_1 = [E:E']$ \\
    \oooooo Hence $E \in \domain{h_1}$, so $E \in \domain{h_1 \cdot h_2}$ \\
    \oooooo Hence $C\;Best((\semfun{a}{Q(a)*s})\;(h_1 \cdot h_2) = 
                   Best(\semfun{a}{Q(a)*s})\;(h\;E)\;h$ \\
    \oooooo So we want to show $Best(\semfun{a}{Q(a)*s})\;(h\;E)\;h = \bot$ \\
    \oooooo To show this, we must show $\lnot(\exists k \in Approx(\semfun{a}{Q(a)*s}).\; (h\;E)\;h = \top)$ \\
    \oooooo So we want $\forall k \in Approx(\semfun{a}{Q(a)*s}).\; (h\;E)\;h = \bot)$ \\
    \oooooo Assume $k \in Approx(\semfun{a}{Q(a)*s})$ \\
    \ooooooo So we know $\forall v, h \in Q(v)*s.\; k\;v\;h = \bot$ \\
    \ooooooo Instantiate with $v$ with $(h\;E)$, and $h$ with $h$ \\
    \ooooooo So we must show $h \in Q(h\;E)*s$ \\
    \ooooooo So we will check $h_1 \in Q(h\;E)$ and $h_2 \in s$, since $h_1 \cdot h_2 = h$ \\
    \ooooooo So we want to check $h_1 \in \interp{\judgeA{e \pointsto_A e'}{\assert}}\;\theta\;\gamma\;\delta = P$ \\
    \ooooooox and also $h_1 \in \interp{\judgeA[\Gamma,a:A]{a = e'}{\assert}}(\delta,h\;E)$ \\
    \ooooooo We know $h_1 \in P$ by assumption \\
    \ooooooo Since $h\;E = E' = \interp{\judgeA{e'}{A}}\theta\;\gamma\;\delta$, we know 
              $\interp{\judgeA[\Theta; \Gamma,a:A; \Delta]{a = e'}{\assert}}\;\theta\;(\gamma,h\;E)\;\delta = H$ \\
    \ooooooo Therefore $h_1 \in \interp{\judgeA[\Theta; \Gamma,a:A; \Delta]{a = e'}{\assert}}\;\theta\;(\gamma, h\;E)\;\delta$ \\
    \ooooooo We know $h_2 \in s$ by assumption\\
    \ooooooo Therefore $h \in Q(h\;E)*s$ \\
    \ooooooo Therefore we know $k\;(h\;E)\;h = \bot$ \\
    \oooooo Therefore $\forall k \in Approx((\semfun{a}{Q(a)*s}).\; (h\;E)\;h = \bot$ \\
    \oooooo Therefore $Best(\semfun{a}{Q(a)*s})\;(h\;E)\;h = \bot$ \\
    \ooooo Therefore $\forall h \in P*s.\; C\;Best(\semfun{a}{Q(a)*s})\;h = \bot$ \\
    \ooooo Therefore $\basicspec{P*s}{C}{a:A}{Q(a)*s}$ \\
    \oooo Therefore $\forall s \succeq r.\; \basicspec{P*s}{C}{a:A}{Q(a)*s}$ \\
    \oooo Therefore $r \in \spec{P}{C}{a:A}{Q(a)}$ \\
    \ooo Therefore $\forall r.\; r \in \interp{\judgeS{\spec{e \pointsto_A e'}{!e}{a:A}{e \pointsto e' \land a = e'}}}\theta\;\gamma\;\delta$ \\
    \ooo Therefore $\interp{\judgeS{\spec{e \pointsto_A e'}{!e}{a:A}{e \pointsto e' \land a = e'}}}\theta\;\gamma\;\delta = \top$ \\
  \end{tabbedproof}
\end{proof}

\begin{lemma}{(Sequential Composition Axiom)}
Suppose $\judgeS{\mspec{p}{e}{x:A}{q}}$ is valid, and $\judgeS[\Delta,x:A]{\spec{q}{c}{a:B}{r}}$ is valid, and $x \not\in \FV{r}$. Then $\judgeS{\spec{p}{\letv{x}{e}{c}}{a:B}{r}}$ is valid. 
\end{lemma}

\begin{proof}
  \begin{tabbedproof}
    \oo Assume $\judgeS{\mspec{p}{e}{x:A}{q}}$ is valid \\
    \oo Assume $\judgeS[\Delta,x:A]{\spec{q}{c}{a:B}{r}}$ is valid\\
    \ooo Assume suitable $\theta$, $\gamma$, and $\delta$ \\
    \oooo We want to show $\interp{\judgeS{\spec{p}{\letv{x}{e}{c}}{a:B}{r}}}\theta\;\gamma\;\delta = \top$\\
    \oooo So we want $\forall t.\; t \in \interp{\judgeS{\spec{p}{\letv{x}{e}{c}}{a:B}{r}}}\theta\;\gamma\;\delta$ \\
    \oooo Assume $t$ \\
    \ooooo Let $E = \interp{\judgeE{\Gamma}{e}{\monad{A}}}\;\theta\;\gamma$ \\
    \ooooo Let $F = \semfun{v}{\interp{\judgeE{\Gamma,x:A}{\comp{c}}{\monad{B}}}\;\theta\;(\gamma,v)}$ \\
    \ooooo Let $P = \interp{\judgeA{p}{\assert}}\theta\;\gamma\;\delta$ \\
    \ooooo Let $Q = \semfun{v}{\interp{\judgeA[\Theta; \Gamma ,x:A;\Delta]{q}{\assert}}\;\theta\;(\gamma,v)\;\delta}$ \\
    \ooooo Let $R = \semfun{v}{\semfun{v'}{\interp{\judgeA[\Theta;\Gamma,x:A,a:B;]{q}{\assert}}\;\theta\;(\gamma, v, v')\;\delta}}$ \\
    \ooooo Let $R' = \semfun{v'}{\interp{\judgeA[\Theta; \Gamma, a:B; \Delta]{q}{\assert}}\;\theta\;(\gamma, v')\;\delta}$ \\
    \ooooo Note $\forall v.\; R\;v = R'$ since $x \not\in \FV{r}$ \\
    \ooooo Let $C = \interp{\judgeE{\Gamma}{\comp{\letv{x}{e}{c}}}{\monad{B}}}\;\theta\;\gamma$ \\
    \ooooo By semantics, $C = F^*(E)$ \\
    \ooooo By definition of monadic lift, $C = \semfun{k}{E\;(\semfun{v}{F\;v\;k})}$ \\
    \ooooo So we want to show $t \in \spec{P}{C}{a:A}{R'(a)}$ \\
    \ooooo So we want $\forall u \succeq t.\; \basicspec{P * u}{C}{a:A}{(R'(a) * u)}$ \\
    \ooooo Assume $u \succeq t$ \\
    \oooooo So we want to show $\forall h \in P * u.\; C\;Best(\semfun{a}{R'(a) * u})\;h = \bot$\\
    \oooooo Assume $h \in P * u$ \\
    \ooooooo So we want to show $E\;(\semfun{v}{F\;v\;Best(\semfun{a}{R'(a)*u})})\;h = \bot$ \\
    \ooooooo We know $\judgeS{\mspec{p}{e}{x:A}{q}}$ is valid \\
    \ooooooo Instantiating with the environment $\theta\;\gamma\;\delta$, we get $\forall t.\; t \in \spec{P}{E}{a:A}{Q(a)}$ \\
    \ooooooo Thus $\forall t, u \succeq t.\; \basicspec{P * u}{E}{a:A}{Q(a) * u}$ \\
    \ooooooo Thus $\forall t, u \succeq t, h \in P * u, E\;Best(\semfun{a}{Q(a) * u})\;h = \bot$ \\
    \ooooooo Instantiating, we get $E\;Best(\semfun{a}{Q(a) * u})\;h = \bot$ \\
    \ooooooo So it suffices to show $(\semfun{v}{F\;v\;Best(\semfun{a}{R'(a)*u})}) \sqsubseteq 
                                Best(\semfun{a}{Q(a) * u})$ \\
    \ooooooo To do this, we can show $(\semfun{v}{F\;v\;Best(\semfun{a}{R'(a)*u})}) \in Approx(\semfun{a}{Q(a) * u})$ \\
    \ooooooo To do this, we must show $\forall v, h \in Q(v) * u, F\;v\;Best(\semfun{a}{R'(a)*u})\;h = \bot$ \\
    \ooooooo Assume $v, h \in Q(v) * u$ \\
    \oooooooo We know $\judgeS[\Delta,x:A]{\spec{q}{c}{a:B}{r}}$ is valid\\
    \oooooooo Instantiating with the environment $\theta\;(\gamma, v)\;\delta$, we get \\
    \oooooooox $\forall v, t, u \succeq t, h \in Q(v) * u, (F\;v)\;Best(\semfun{a}{R\;v\;a * u})\;h = \bot$ \\
    \oooooooo Instantiating, we get $(F\;v)\;Best(\semfun{a}{R\;v\;a * u})\;h = \bot$ \\
    \oooooooo By equality, we get $(F\;v)\;Best(\semfun{a}{R'(a) * u})\;h = \bot$ \\
    \ooooooo Therefore $\forall v, h \in Q(v) * u, F\;v\;Best(\semfun{a}{R'(a)*u})\;h = \bot$ \\
    \ooooooo Therefore $(\semfun{v}{F\;v\;Best(\semfun{a}{R'(a)*u})}) \sqsubseteq 
                                Best(\semfun{a}{Q(a) * u})$ \\
    \ooooooo Therefore $(\semfun{v}{F\;v\;Best(\semfun{a}{R'(a)*u})}) \in Approx(\semfun{a}{Q(a) * u})$ \\                        
    \ooooooo Therefore $E\;(\semfun{v}{F\;v\;Best(\semfun{a}{R'(a)*u})})\;h = \bot$ \\
    \oooooo Therefore $\forall h \in P * u.\; C\;Best(\semfun{a}{R'(a) * u})\;h = \bot$\\
    \ooooo Therefore $\forall u \succeq t.\; \basicspec{P * u}{C}{a:A}{(R'(a) * u)}$ \\
    \ooooo Therefore $t \in \spec{P}{C}{a:A}{R'(a)}$ \\
    \oooo Therefore $\forall t.\; t \in \interp{\judgeS{\spec{p}{\letv{x}{e}{c}}{a:B}{r}}}\theta\;\gamma\;\delta$ \\
    \oooo Therefore $\interp{\judgeS{\spec{p}{\letv{x}{e}{c}}{a:B}{r}}}\theta\;\gamma\;\delta = \top$\\
  \end{tabbedproof}
\end{proof}

\begin{lemma}{(Fixed Point Induction)}
We have that if 
\begin{displaymath}
   S \triangleq 
   \judgeS{(\forall x:\monad{A}.\; \mspec{p}x{a:A}{q(a)} \specimp \mspec{p}{e}{a:A}{q})}
\end{displaymath}
\noindent is valid, then 
\begin{displaymath}
  S' \triangleq \judgeS{\mspec{p}{\fix{x:\monad{A}}{e}}{a:A}{q}}
\end{displaymath}
is valid.
\end{lemma}

\begin{proof}
  \begin{tabbedproof}
    \oo Let $S = \forall x:\monad{A}.\; \mspec{p}x{a:A}{q(a)} \specimp \mspec{p}{e}{a:A}{q}$\\
    \oo Let $S' = \mspec{p}{\fix{x:\monad{A}}{e}}{a:A}{q}$ \\
    \oo Assume suitable $\theta$, $\gamma$, and $\delta$ \\
    \ooo So we want to show $\interp{S'}\;\theta\;\gamma\;\delta = \top$ \\
    \ooo Let $P = \interp{\judgeA{P}{\assert}}\;\theta\;\gamma\;\delta$ \\
    \ooo Let $C = \interp{\judgeE{\Gamma}{\fix{x:\monad{A}}{e}}{\monad{A}}}\;\theta\;\gamma$ \\
    \ooo Let $Q = \semfun{v}{\interp{\judgeA[\Theta; \Gamma, a:A; \Delta]{q}{\assert}}\;\theta\;(\gamma, v)\;\delta}$ \\
    \ooo Let $F(v) = \interp{\judgeE{\Gamma, a:A}{e}{\monad{A}}}\;\theta\;(\gamma, v)$ \\
    \ooo So we want to show $\spec{P}{C}{a:A}{Q(a)} = \top$ \\
    \ooo We know $\interp{S}\;\theta\;\gamma\;\delta = \top$ \\
    \ooo Thus for all $v$, we know $\interp{\mspec{p}x{a:A}{q(a)} \specimp \mspec{p}{e}{a:A}{q}}\;\theta\;(\gamma, v)\;\delta = \top$ \\
    \ooo Thus we know for all $v$, $r$, and $s \succeq r$, \\
    \ooox if $s \in \interp{\mspec{p}x{a:A}{q(a)}}\;\theta\;(\gamma, v)\;\delta$ then $s \in \interp{\mspec{p}{e}{a:A}{q}}\;\theta\;(\gamma, v)\;\delta$ \\
    \ooo Since $x \not\in \FV{p}$, we know for all $v$, 
         $\interp{\judgeA[\Theta; \Gamma,x:\monad{A}; \Delta]{p}{\assert}}\;\theta\;(\gamma, v)\;\delta = P$ \\
    \ooo Since $x \not\in \FV{q}$, we know for all $v$, 
         $\semfun{v'}{\interp{\judgeA[\Theta; \Gamma, x:\monad{A}, a:A; \Delta]{q}{\assert}}\;\theta\;(\gamma,v,v') \;\delta} = Q$ \\
    \ooo Thus we know for all $v$, $r$, and $s \succeq r$, \\
    \ooox if $s \in  \spec{P}{v}{a:A}{Q(a)}$ then 
             $s \in \spec{P}{F(v)}{a:A}{Q(a)}$ \\
    \ooo This implies that for all $v$, if $\spec{P}{F(v)}{a:A}{Q(a)} = \top $ 
                                        then $\spec{P}{F(v)}{a:A}{Q(a)} = \top$ \\
    \ooo Then by the semantic fixed point theorem, 
          $\spec{P}{fix(F)}{a:A}{Q(a)} = \top$ \\
    \ooo So $\spec{P}{C}{a:A}{Q(a)} = \top$ \\
    \ooo Therefore $\interp{S'}\;\theta\;\gamma\;\delta = \top$ \\
  \end{tabbedproof}
\end{proof}

\begin{lemma}{(Assumptions From Preconditions)}
If we know that $\judgeS{\setof{r} \specimp \spec{p}{c}{a:A}{q}}$ is
valid, $r$ is a pure formula of separation logic, and we know that $p
\implies r$ is a valid truth of separation logic, then
$\judgeS{\spec{p}{c}{a:A}{q}}$ is valid.
\end{lemma}

\begin{proof}
  \begin{tabbedproof}
    \oo Assume $\judgeS{\setof{r} \specimp \spec{p}{c}{a:A}{q}}$ is valid \\
    \oo Assume $p \implies r$ is a valid truth of separation logic \\
    \ooo We know that all suitable $\theta$, $\gamma$, and $\theta$, $\interp{\judgeS{\setof{r} \specimp \spec{p}{c}{a:A}{q}}}\;\theta\;\gamma\;\delta$ is $\top$\\
    \ooo We want for all suitable $\theta$, $\gamma$, and $\theta$, that $\interp{\judgeS{\spec{p}{c}{a:A}{q}}}\;\theta\;\gamma\;\delta = \top$ \\
    \ooo Assume $\theta\;\gamma\;\delta$ is a suitable environment \\
    \oooo We want to show for all $r$, and all $s \worldgeq r$, that $\basicspec{P*s}{C}{a}{Q(a) * s}$ holds\\
    \ooox where \\
    \oooox $R = \interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta$ \\
    \oooox $P = \interp{\judgeA{p}{\assert}}\;\theta\;\gamma\;\delta$ \\
    \oooox $C = \interp{\judgeC[\Theta]{\Gamma}{c}{A}}\;\theta\;\gamma$ \\
    \oooox $Q = \semfun{v}{\interp{\judgeA[\Theta; \Gamma, a:A; \Delta]{q}{\assert}}\;\theta\;(\gamma, v)\;\delta}$ \\
    \oooo To show $\basicspec{P*s}{C}{a}{Q(a)*s}$, we must show 
          $\forall h \in P * s.\; c\; (Best(\semfun{a}{Q(a)*s}))\;h = \bot$ \\
    \oooo Assume $h \in P * s$ \\
    \ooooo Since $p \implies r$ is a valid truth, we know $P \implies R$ and so $h \in R * s$ \\
    \ooooo Since $R$ is pure, we know $h \in R \land s$ \\
    \ooooo So we know $h \in R$ \\
    \ooooo Since $R$ is pure it is either $\emptyset$ or $H$, and since we know $h \in R$, $R = H$ \\
    \ooooo Therefore we know that $\interp{\judgeS{\setof{r}}}\;\theta\;\gamma\;\delta = \top$ \\
    \ooooo Therefore we know that $\interp{\judgeS{\spec{p}{c}{a:A}{q}}}\;\theta\;\gamma\;\delta = \top$ \\
  \end{tabbedproof}
\end{proof}

\begin{lemma}{(Assumptions Into Preconditions)}
If we know that $\judgeS{\setof{r} \specimp \spec{p \land r}{c}{a:A}{q}}$ is
valid, then $\judgeS{\setof{r} \specimp \spec{p}{c}{a:A}{q}}$ is valid.
\end{lemma}

\begin{proof}
\begin{tabbedproof}
  \oo Assume $\judgeS{\setof{r} \specimp \spec{p \land r}{c}{a:A}{q}}$ is valid. \\
  \ooo This is equivalent to for all suitable $\theta$, $\gamma$, $\theta$ and $s$, \\
  \ooox if $s \in \interp{\setof{r}}\;\theta\;\gamma\;\delta$, then $s \in \interp{\spec{p \land r}{c}{a:A}{q}}\;\theta\;\gamma\;\delta$. \\
  \ooo We want to show that $\judgeS{\setof{r} \specimp \spec{p}{c}{a:A}{q}}$ is valid \\
  \ooo This is equivalent to showing for all suitable $\theta$, $\gamma$, and $\theta$ and $s$, \\
  \ooox if $s \in \interp{\setof{r}}\;\theta\;\gamma\;\delta$, then $s \in \interp{\spec{p}{c}{a:A}{q}}\;\theta\;\gamma\;\delta$. \\
  \ooo Assume we have $\theta\;\gamma\;\delta$ and $s$ such that $s \in \interp{\setof{r}}\;\theta\;\gamma\;\delta$. \\
  \oooo We want to show $s \in \interp{\spec{p}{c}{a:A}{q}}\;\theta\;\gamma\;\delta$ is valid. \\
  \oooo So we want to show for all $t \worldgeq s$, that $\basicspec{P*t}{C}{a}{Q(a) * t}$ holds\\
  \ooox where \\
  \oooox $R = \interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta$ \\
  \oooox $P = \interp{\judgeA{p}{\assert}}\;\theta\;\gamma\;\delta$ \\
  \oooox $C = \interp{\judgeC[\Theta]{\Gamma}{c}{A}}\;\theta\;\gamma$ \\
  \oooox $Q = \semfun{v}{\interp{\judgeA[\Theta; \Gamma, a:A; \Delta]{q}{\assert}}\;\theta\;(\gamma, v)\;\delta}$ \\
  \oooo Assume $t \worldgeq s$, and $h \in P * t$. \\
  \ooooo We want to show that $C\;\mathit{Best}(\semfun{a}{Q(a) * s})\;h = \bot$ \\
  \ooooo Since $s \in \interp{\spec{p \land r}{c}{a:A}{q}}\;\theta\;\gamma\;\delta$, we know $C\;\mathit{Best}(\semfun{a}{Q(a) * s})\;h = \bot$ if  $h \in (P \land R) * t$. \\
  \ooooo Since we assumed that $\interp{\setof{r}}\;\theta\;\gamma\;\delta$ was non-empty, this means that $\interp{r}\;\theta\;\gamma\;\delta = \top = H$. \\
  \ooooo Hence $h \in (P \land R) * t$. \\
  \ooooo Hence $C\;\mathit{Best}(\semfun{a}{Q(a) * s})\;h = \bot$ \\ 
\end{tabbedproof}
\end{proof}

\begin{lemma}{(Getting Specs Out of Assertions)}
We have that $\judgeS{\setof{\validprop{S}} \specimp S}$ is valid.
\end{lemma}
\begin{proof}
  \begin{tabbedproof}
    \oo We want to show $\judgeS{\setof{\validprop{S}} \specimp S}$ is valid \\
    \oo Equivalently, we need for all suitable $\theta$, $\gamma$, and $\theta$ and $r$, if $r \in \interp{\judgeS{\setof{\validprop{S}}}}\;\theta\;\gamma\;\delta$\\
    \ox    then $r \in \interp{\judgeS{S}}\;\theta\;\gamma\;\delta$ \\
    \oo Assume we have a suitable $\theta, \gamma,$ and $\delta$ and $r$ such that $r \in \interp{\judgeS{\setof{\validprop{S}}}}\;\theta\;\gamma\;\delta$ \\
    \ooo From the semantics, we know $\interp{\judgeS{\setof{\validprop{S}}}}\;\theta\;\gamma\;\delta$ is either $\top$ or $\bot$ \\
    \ooo Since $r \in \interp{\judgeS{\setof{\validprop{S}}}}\;\theta\;\gamma\;\delta$, we know it is non-empty, hence \\
    \ooox $\interp{\judgeS{\setof{\validprop{S}}}}\;\theta\;\gamma\;\delta = \top$ \\
    \ooo Therefore, we know that $\interp{\judgeA{\validprop{S}}{\assert}}\;\theta\;\gamma\;\delta = H$ \\
    \ooo Therefore, we know that $\interp{\judgeS{S}}\;\theta\;\gamma\;\delta = \top$ \\
  \end{tabbedproof}
\end{proof}

\begin{lemma}{(Existential Dropping 1)}
If $\judgeS{\spec{\exists u:\upsilon.\;p}{c}{a:A}{q}}$ is valid, then 
   $\judgeS[\Theta; \Gamma; \Delta, u:\upsilon]{\spec{p}{c}{a:A}{q}}$ is valid. 
\end{lemma}

\begin{proof}
  \begin{tabbedproof}
    \oo Assume $\judgeS{\spec{\exists y:\upsilon.\;p}{c}{a:A}{q}}$ is valid \\
    \ooo We want to show $\judgeS[\Theta; \Gamma; \Delta, u:\upsilon]{\spec{p}{c}{a:A}{q}}$ is valid \\
    \ooo So we want to show for all $\theta, \gamma, v, \delta$, \\
    \ooox that $\interp{\judgeS[\Theta; \Gamma; \Delta, u:\upsilon]{\spec{p}{c}{a:A}{q}}}\;\theta\;\gamma\;(\delta,v) = \top$ \\
    \ooo Assume we have a suitable $(\theta, \gamma, \delta, v)$ and $\delta' = (\delta, v)$\\ 
    \oooo We want to show for all $r$, that $r \in \spec{P}{C}{a}{Q(a)}$ \\
    \oooo where \\
    \oooox $P = \interp{\judgeA[\Theta; \Gamma; \Delta, u:\upsilon]{p}{\assert}}\;\theta\;\gamma\;\delta'$ \\
    \oooox $C = \interp{\judgeC[\Theta]{\Gamma, y:B}{c}{A}}\;\theta\;\gamma$ \\
    \oooox $Q = \semfun{v'}{\interp{\judgeA[\Theta; \Gamma, a:A; \Delta, u:\upsilon]{q}{\assert}}\;\theta\;(\gamma, v')\;\delta'}$ \\
    \oooo We also know that $C = \interp{\judgeC[\Theta]{\Gamma}{c}{A}}\;\theta\;\gamma$ \\
    \oooo and that $Q = \semfun{v'}{\interp{\judgeA[\Theta;\Gamma, a:A;\Delta]{q}{\assert}}\;\theta\;(\gamma, v')\;\delta'}$\\
    \oooo So now we must show for all $s \worldgeq r$, that $\basicspec{P * s}{C}{a}{Q(a) * s}$ holds\\
    \oooo Now assume $s$ such that $s \worldgeq r$ \\
    \ooooo We need for all $h \in \basicspec{P * s}{C}{a}{Q(a) * s}$, that 
             $C\;Best(\semfun{a}{Q(a) * s})\;h = \bot$ \\
    \ooooo We know $\spec{\exists u:\upsilon.\;p}{c}{a:A}{q}$ is valid \\
    \ooooo So we know for all $r$, that $r \in \spec{P'}{C}{a}{Q(a)}$ \\
    \oooox where $P' = \bigvee_{v \in \interp{\judgeSort{\upsilon}}\;\theta} \interp{\judgeA[\Theta; \Gamma; \Delta, u:\upsilon]{p}{\assert}}\;\theta\;\gamma\;(\delta,v)$ \\
    \ooooo Since $P = \interp{\judgeA[\Theta; \Gamma; \Delta, u:\upsilon]{p}{\assert}}\;\theta\;\gamma\;\delta'$, we know $P \subseteq P'$ \\
    \ooooo Therefore $h \in P' * s$, and so $C\;Best(\semfun{a}{Q(a) * s})\;h = \bot$ \\
    
  \end{tabbedproof}
\end{proof}

\begin{lemma}{(Existential Dropping 2)}
If $\judgeS{\spec{\exists y:B.\;p}{c}{a:A}{q}}$ is valid, then 
   $\judgeS[\Theta; \Gamma, y:B; \Delta]{\spec{p}{c}{a:A}{q}}$ is valid. 
\end{lemma}

\begin{proof}
  \begin{tabbedproof}
    \oo Assume $\judgeS{\spec{\exists y:B.\;p}{c}{a:A}{q}}$ is valid \\
    \ooo We want to show $\judgeS[\Theta; \Gamma, y:B; \Delta]{\spec{p}{c}{a:A}{q}}$ is valid \\
    \ooo So we want to show for all $\theta, \gamma, v, \delta$, \\
    \ooox that $\interp{\judgeS[\Theta; \Gamma, y:B; \Delta]{\spec{p}{c}{a:A}{q}}}\;\theta\;(\gamma,v)\;\delta = \top$ \\
    \ooo Assume we have a suitable $(\theta, \gamma, \delta, v)$ and $\gamma' = (\gamma, v)$\\ 
    \oooo We want to show for all $r$, that $r \in \spec{P}{C}{a}{Q(a)}$ \\
    \oooo where \\
    \oooox $P = \interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{p}{\assert}}\;\theta\;\gamma'\;\delta$ \\
    \oooox $C = \interp{\judgeC[\Theta]{\Gamma, y:B}{c}{A}}\;\theta\;\gamma'$ \\
    \oooox $Q = \semfun{v'}{\interp{\judgeA[\Theta; \Gamma, y:B, a:A; \Delta]{q}{\assert}}\;\theta\;(\gamma', v')\;\delta}$ \\
    \oooo We also know that $C = \interp{\judgeC[\Theta]{\Gamma}{c}{A}}\;\theta\;\gamma$ \\
    \oooo and that $Q = \semfun{v'}{\interp{\judgeA[\Theta;\Gamma, a:A;\Delta]{q}{\assert}}\;\theta\;(\gamma, v')\;\delta}$\\
    \oooo So now we must show for all $s \worldgeq r$, that $\basicspec{P * s}{C}{a}{Q(a) * s}$ holds\\
    \oooo Now assume $s$ such that $s \worldgeq r$ \\
    \ooooo We need for all $h \in \basicspec{P * s}{C}{a}{Q(a) * s}$, that 
             $C\;Best(\semfun{a}{Q(a) * s})\;h = \bot$ \\
    \ooooo We know $\spec{\exists y:B.\;p}{c}{a:A}{q}$ is valid \\
    \ooooo So we know for all $r$, that $r \in \spec{P'}{C}{a}{Q(a)}$ \\
    \oooox where $P' = \bigvee_{v \in \interp{\judgeSort{B}}\;\theta} \interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{p}{\assert}}\;\theta\;(\gamma, v)\;\delta$ \\
    \ooooo Since $P = \interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{p}{\assert}}\;\theta\;(\gamma, v)\;\delta$, we know $P \subseteq P'$ \\
    \ooooo Therefore $h \in P' * s$, and so $C\;Best(\semfun{a}{Q(a) * s})\;h = \bot$ \\
    
  \end{tabbedproof}
\end{proof}

\begin{lemma}{(Existential Dropping 3)}
If $\judgeS{\spec{\exists \alpha:\kappa.\;p}{c}{a:A}{q}}$ is valid, then 
   $\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{\spec{p}{c}{a:A}{q}}$ is valid. 
\end{lemma}

\begin{proof}
  \begin{tabbedproof}
    \oo Assume $\judgeS{\spec{\exists \alpha:\kappa.\;p}{c}{a:A}{q}}$ is valid \\
    \ooo We want to show $\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{\spec{p}{c}{a:A}{q}}$ is valid \\
    \ooo So we want to show for all $\theta, \tau, \gamma, \delta$  \\
    \ooox that $\interp{\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{\spec{p}{c}{a:A}{q}}}\;(\theta, \tau)\;\gamma\;\delta = \top$ \\
    \ooo Assume we have a suitable $(\theta, \gamma, \delta, \tau)$ and $\theta' = (\theta, v)$\\ 
    \oooo We want to show for all $r$, that $r \in \spec{P}{C}{a}{Q(a)}$ \\
    \oooo where \\
    \oooox $P = \interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\assert}}\;\theta'\;\gamma\;\delta$ \\
    \oooox $C = \interp{\judgeC[\Theta, \alpha:\kappa]{\Gamma, y:B}{c}{A}}\;\theta'\;\gamma$ \\
    \oooox $Q = \semfun{v'}{\interp{\judgeA[\Theta, \alpha:\kappa; \Gamma, a:A; \Delta]{q}{\assert}}\;\theta'\;(\gamma, v')\;\delta}$ \\
    \oooo We also know that $C = \interp{\judgeC[\Theta]{\Gamma}{c}{A}}\;\theta\;\gamma$ \\
    \oooo and that $Q = \semfun{v'}{\interp{\judgeA[\Theta;\Gamma, a:A;\Delta]{q}{\assert}}\;\theta\;(\gamma, v')\;\delta}$\\
    \oooo So now we must show for all $s \worldgeq r$, that $\basicspec{P * s}{C}{a}{Q(a) * s}$ holds\\
    \oooo Now assume $s$ such that $s \worldgeq r$ \\
    \ooooo We need for all $h \in \basicspec{P * s}{C}{a}{Q(a) * s}$, that 
             $C\;Best(\semfun{a}{Q(a) * s})\;h = \bot$ \\
    \ooooo We know $\spec{\exists \alpha:\kappa.\;p}{c}{a:A}{q}$ is valid \\
    \ooooo So we know for all $r$, that $r \in \spec{P'}{C}{a}{Q(a)}$ \\
    \oooox where $P' = \bigvee_{\tau \in \interp{\judgeSort{\kappa}}\;\theta} \interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\assert}}\;(\theta, \tau)\;\gamma\;\delta$ \\
    \ooooo Since $P = \interp{\judgeA[\Theta, \alpha:\kappa; \Gamma; \Delta]{p}{\assert}}\;\theta'\;\gamma\;\delta$, we know $P \subseteq P'$ \\
    \ooooo Therefore $h \in P' * s$, and so $C\;Best(\semfun{a}{Q(a) * s})\;h = \bot$ \\
    
  \end{tabbedproof}
\end{proof}



\begin{lemma}{(Disjunction Rule)}
If $\judgeS{\spec{p}{c}{a:A}{q}}$ is valid and 
   $\judgeS{\spec{p'}{c}{a:A}{q'}}$ is valid, 
then $\judgeS{\spec{p \vee p'}{c}{a:A}{q \vee q'}}$ is valid. 
\end{lemma}

\begin{proof}
  \begin{tabbedproof}
    \oo Assume $\judgeS{\spec{p}{c}{a:A}{q}}$ is valid \\
    \oo Assume $\judgeS{\spec{p'}{c}{a:A}{q'}}$ is valid \\

    \oo Assume suitable $\theta$, $\gamma$, and $\delta$ \\
    \ooo We want to show $\interp{\judgeS{\spec{p \vee p'}{c}{a:A}{q \vee q'}}}\theta\;\gamma\;\delta = \top$ \\
    \ooo So we want to show $\forall r.\; r \in \interp{\judgeS{\spec{p \vee p'}{c}{a:A}{q \vee q'}}}\theta\;\gamma\;\delta$ \\
    \ooo Assume $r$, \\
    \oooo So we want to show $r \in\interp{\judgeS{\spec{p \vee p'}{c}{a:A}{q \vee q'}}}\theta\;\gamma\;\delta$ \\
    \oooo Let $P'' = \interp{\judgeA{p \vee p'}{\assert}}\;\theta\;\gamma\;\delta$ \\
    \oooo Let $C = \interp{\judgeE{\Gamma}{[c]}{\monad{A}}}\;\theta\;\gamma$ \\
    \oooo Let $Q'' = \semfun{v}{\interp{\judgeA[\Theta; \Gamma,a:A; \Delta]{q \vee q'}{\assert}}\;\theta\;(\gamma, v)\;\delta}$ \\
    \oooo So we want to show $r \in \spec{P''}{C}{a:A}{Q''(a)}$ \\
    \oooo So we want to show $\forall s \succeq r.\; \basicspec{P'' * s}{C}{a:A}{Q''(a) * s}$ \\
    \oooo Assume $s \succeq r$ \\
    \ooooo We want to show $\basicspec{P'' * s}{C}{a:A}{Q''(a) * s}$ \\
    \ooooo We want to show $\forall h \in P'' * s.\; C\;Best(\semfun{a}{Q''(a) * s})\;h = \bot$ \\
    \ooooo Assume $h \in P'' * s$ \\
    \oooooo Therefore there are $h_1 \in P''$ and $h_2 \in s$ such that $h = h_1 \cdot h_2$ \\
    \oooooo We know $P'' = \interp{\judgeA{p \vee p'}{\assert}}\;\theta\;\gamma\;\delta = $\\
    \oooooox $\interp{\judgeA{p}{\assert}}\;\theta\;\gamma\;\delta \vee 
                           \interp{\judgeA{p'}{\assert}}\;\theta\;\gamma\;\delta$ \\ 
    \oooooo Call $P = \interp{\judgeA{p}{\assert}}\;\theta\;\gamma\;\delta$ and $P' = \interp{\judgeA{p'}{\assert}}\;\theta\;\gamma\;\delta$ \\
    \oooooo Call $Q(v) = \interp{\judgeA[\Theta; \Gamma, a:A; \Delta]{q}{\assert}}\;\theta\;(\gamma,v)\;\delta$ \\
    \ooooox and $Q'(v) = \interp{\judgeA[\Theta; \Gamma, a:A; \Delta]{q'}{\assert}}\;\theta\;(\gamma,v)\;\delta$ \\
    \oooooo By the definition of $\vee$, we know that $h_1 \in P$ or $h_1 \in P'$ \\
    \oooooo Suppose $h_1 \in P$: \\
    \ooooooo We know by assumption that $\basicspec{P * s}{C}{a:A}{Q(a) * s}$ \\
    \ooooooo We know that $h = h_1 \cdot h_2 \in P * s$ \\
    \ooooooo Hence $C\;\mathit{Best}(\semfun{a}{Q(a) * s})\;h = \bot$ \\
    \ooooooo For any $a$, $Q(a) \subseteq Q''(a)$, \\
    \ooooooo Hence $\mathit{Best}(\semfun{a}{Q''(a) * s}) \sqsubseteq \mathit{Best}(\semfun{a}{Q(a) * s})$ \\ 
    \ooooooo Since $C$ is continuous, $C\;\mathit{Best}(\semfun{a}{Q''(a) * s})\;h = \bot$ \\
    \oooooo Suppose $h_1 \in P'$: \\
    \ooooooo We know by assumption that $\basicspec{P' * s}{C}{a:A}{Q(a) * s}$ \\
    \ooooooo We know that $h = h_1 \cdot h_2 \in P' * s$ \\
    \ooooooo Hence $C\;\mathit{Best}(\semfun{a}{Q'(a) * s})\;h = \bot$ \\
    \ooooooo For any $a$, $Q'(a) \subseteq Q''(a)$ \\
    \ooooooo Hence $\mathit{Best}(\semfun{a}{Q''(a) * s}) \sqsubseteq \mathit{Best}(\semfun{a}{Q'(a) * s})$ \\
    \ooooooo Since $C$ is continuous, $C\;\mathit{Best}(\semfun{a}{Q''(a) * s})\;h = \bot$ \\
  \end{tabbedproof}
\end{proof}

\begin{lemma}{(Equality Substitution)}
If $\judgeS{\setof{r} \specimp \spec{p}{c[e/x]}{a:A}{q}}$ is valid and
$\validP{r \implies e =_A e'}$ is valid, then $\judgeS{\setof{r} \specimp \spec{p}{c[e'/x]}{a:A}{q}}$ is valid.
\end{lemma}

\begin{proof}
\begin{tabbedproof}
\oo Assume $\judgeS{\setof{r} \specimp \spec{p}{c[e/x]}{a:A}{q}}$ is valid. \\
\ooo This is equivalent to assuming for all suitable $\theta$, $\gamma$, and $\theta$ and $s$, \\
\oooo if $s \in \interp{\setof{r}}\;\theta\;\gamma\;\delta$, then $s \in \interp{\spec{p}{c[e/x]}{a:A}{q}}\;\theta\;\gamma\;\delta$. \\
\ooo Assume $\theta\;\gamma\;\delta$, $r$, and $s \in \interp{\setof{r}}\;\theta\;\gamma\;\delta$ \\
\oooo Let \\
\oooox $C = \interp{c[e/x]}\;\theta\;\gamma$ \\
\oooox $C' = \interp{c[e'/x]}\;\theta\;\gamma$ \\
\oooox $P = \interp{\judgeA{p}{\assert}}\;\theta\;\gamma\;\delta$ \\
\oooox $Q = \semfun{v}{\interp{\judgeA[\Theta; \Gamma,a:A; \Delta]{q}{\assert}}\;\theta\;(\gamma, v)\;\delta}$ \\
\oooo Since we have $r$, we know that $R = \interp{r}\;\theta\;\gamma\;\delta = \top = H$. \\
\oooo Therefore it follows that $\interp{\judgeA{e =_A e'}{\assert}}\;\theta\;\gamma\;\delta = H$ \\
\oooo Therefore $\interp{\judgeE[\Theta]{\Gamma}{e}{A}}\;\theta\;\gamma = \interp{\judgeE[\Theta]{\Gamma}{e'}{A}}\;\theta\;\gamma$ \\
\oooo Since substitution is sound, $\interp{c[e/x]}\;\theta\;\gamma  = \interp{c[e'/x]}\;\theta\;\gamma$, or $C = C'$\\
\oooo By hypothesis, $s \in \interp{\spec{p}{c[e/x]}{a:A}{q}}\;\theta\;\gamma\;\delta$. \\
\oooo So for all $t \worldgeq s, h \in P * t$, we have $C\;\mathit{Best}(\semfun{v}{Q(v) * t})\;h = \bot$ \\
\oooo Since $C = C'$, we know for all $t \worldgeq s, h \in P * t$, we have $C'\;\mathit{Best}(\semfun{v}{Q(v) * t})\;h = \bot$ \\
\oooo Therefore, $s \in \interp{\spec{p}{c[e'/x]}{a:A}{q}}\;\theta\;\gamma\;\delta$. \\
\end{tabbedproof}
\end{proof}

\begin{lemma}{(Case Analysis)}
  Suppose $\judgeS[\Theta; \Gamma,x:A; \Delta]{\mspec{p \land e =_{A+B} \inl(x)}{e_A}{a:C}{q}}$ is valid,
      and $\judgeS[\Theta; \Gamma,y:B; \Delta]{\mspec{p \land e =_{A+B} \inr(y)}{e_B}{a:C}{q}}$ is valid.

Then $\judgeS{\mspec{p}{\Case{e}{x}{e_A}{y}{e_B}}{a:C}{q}}$ is valid. 
\end{lemma}

\begin{proof}
\begin{tabbedproof}
\oo Assume $\judgeS[\Delta,x:A]{\mspec{p \land e =_{A+B} \inl(x)}{e_A}{a:C}{q}}$ is valid. \\
\oo Assume $\judgeS[\Delta,y:B]{\mspec{p \land e =_{A+B} \inr(y)}{e_B}{a:C}{q}}$ is valid. \\
\ooo We want to show $\judgeS{\mspec{p}{\Case{e}{x}{e_A}{y}{e_B}}{a:C}{q}}$ is valid. \\
\ooo We want to show that for all $\theta\;\gamma\;\delta, s$, \\
\ooox $s \in \interp{\judgeS{\mspec{p}{\Case{e}{x}{e_A}{y}{e_B}}{a:C}{q}}}\;\theta\;\gamma\;\delta$ \\
\ooo Assume $\theta\;\gamma\;\delta$ and $s$, and $h \in P * s$, letting \\
\ooox $P = \interp{\judgeA{p}{\assert}}\;\theta\;\gamma\;\delta$ \\
\ooox $Q = \semfun{v}{\interp{\judgeA[\Theta; \Gamma, a:C; \Delta]{p}{\assert}}\;\theta\;(\gamma, v)\;\delta}$ \\
\ooox $C_A = \semfun{v}{\interp{\judgeE{\Gamma, x:A}{e_A}{\monad{C}}}\;\theta\;(\gamma, v)\;\delta}$ \\
\ooox $C_B = \semfun{v}{\interp{\judgeE{\Gamma, y:B}{e_B}{\monad{C}}}\;\theta\;(\gamma, v)\;\delta}$ \\
\ooox $E = \interp{\judgeE[\Theta]{\Gamma}{e}{A+B}}\;\theta\;\gamma$ \\
\oooo We want to show $[C_A,C_B](E)\;\mathit{Best}(\semfun{v}{Q(v)*s})\;h = \bot$\\
\oooo Suppose $E = \inl(u)$ for some $u$: \\
\ooooo Then we want to show that $C_A\;u\;\mathit{Best}(\semfun{v}{Q(v)*s})\;h = \bot$\\
\ooooo We know $\judgeS[\Delta,x:A]{\mspec{p \land e =_{A+B} \inl(x)}{e_A}{a:C}{q}}$ is valid. \\
\ooooo So for all $h \in (P \land \interp{e =_{A+B} \inl(x)}\;\theta\;(\gamma,\inl(u))\;\delta) * s$, $C_A\;u\;\mathit{Best}(\semfun{v}{Q(v)*s})\;h = \bot$\\
\ooooo Since $E=\inl(u)$, we know that $\top = \interp{\judgeA[\Theta; \Gamma, x:A; \Delta]{e=_{A+B}\inl(x)}{\assert}}\;\theta\;(\gamma,\inl(u)\;\delta)$\\
\ooooo Since equality is pure, $h \in \interp{p \land e =_{A+B} \inl(x)}\;\theta\;(\gamma,\inl(u))\;\delta * s$ \\
\ooooo Therefore $C_A\;u\;\mathit{Best}(\semfun{v}{Q(v)*s})\;h = \bot$\\
\oooo Suppose $E = \inr(u)$ for some $u$:  \\
\ooooo Then we want to show that $C_B\;u\;\mathit{Best}(\semfun{v}{Q(v)*s})\;h = \bot$\\
\ooooo We know $\judgeS[\Theta; \Gamma, y:B; \Delta]{\mspec{p \land e =_{A+B} \inr(x)}{e_A}{a:C}{q}}$ is valid. \\
\ooooo So for all $h \in (P \land \interp{e =_{A+B} \inr(x)}\;\theta\;(\gamma,\inr(u))\;\delta) * s$, $C_B\;u\;\mathit{Best}(\semfun{v}{Q(v)*s})\;h = \bot$\\
\ooooo Since $E=\inr(u)$, we know that $\top = \interp{\judgeA[\Theta; \Gamma, y:B; \Delta]{e=_{A+B}\inr(x)}{\assert}}\;\theta\;(\gamma,\inr(u)\;\delta)$\\
\ooooo Since equality is pure, $h \in \interp{p \land e =_{A+B} \inr(x)}\;\theta(\gamma,\inr(u))\;\delta * s$ \\
\ooooo Therefore $C_B\;u\;\mathit{Best}(\semfun{v}{Q(v)*s})\;h = \bot$\\

\end{tabbedproof}
\end{proof}

\begin{lemma}{(The Rule of Consequence)}
If $\judgeS{\spec{p}{c}{a:A}{q}}$ is valid and $\judgeA{p' \implies p}{\assert}$ is valid
and $\judgeA[\Theta; \Gamma,a:A; \Delta]{q \implies q'}{\assert}$ is valid, then $\judgeS{\spec{p'}{c}{a:A}{q'}}$ is valid.
\end{lemma}
\begin{proof}
\begin{tabbedproof}
\oo Assume $\judgeS{\spec{p}{c}{a:A}{q}}$ is valid \\
\oo Assume $\judgeA{p' \implies p}{\assert}$ is valid \\
\oo Assume $\judgeA{q \implies q'}{\assert}$ is valid \\
\oo Assume suitable $\theta$, $\gamma$, and $\delta$ \\
\ooo We want to show $\forall r.\; r \in \judgeS{\spec{p'}{c}{a:A}{q'}}$ \\
\ooo Assume $r$, and let \\
\ooox $P = \interp{\judgeA{p}{\assert}}\theta\;\gamma\;\delta$ \\
\ooox $P' = \interp{\judgeA{p'}{\assert}}\theta\;\gamma\;\delta$ \\
\ooox $C = \interp{\judgeC{\Gamma}{c}{A}}\;\theta\;\gamma$ \\
\ooox $Q = \semfun{v}{\interp{\judgeA[\Theta; \Gamma,a:A; \Delta]{q}{\assert}}\;\theta\;(\gamma, v)\;\delta}$ \\
\ooox $Q' = \semfun{v}{\interp{\judgeA[\Theta; \Gamma,a:A; \Delta]{q}{\assert}}\;\theta\;(\gamma, v)\;\delta}$ \\
\ooo We know $\interp{\judgeA{p' \implies p}{\assert}}\;\theta\;\gamma\;\delta = P' \implies P$. \\
\ooo We know for all $v$, $\interp{\judgeA[\Theta; \Gamma,a:A; \Delta]{q \implies q'}{\assert}}\;\theta\;(\gamma,v)\;\delta = Q(v) \implies Q'(v)$. \\
\ooo So we want to show that $\forall s \succeq r.\; \basicspec{P' * s}{C}{a:A}{Q'(a) * s}$ \\
\ooo Assume $s \succeq r$, and $h \in P' * s$ \\
\oooo Hence $\exists$ $h_1$ and $h_2$ such that $h_1 \# h_2$ and $h = h_1 \cdot h_2$ 
     and $h_1 \in P'$ and $h_2 \in s$ \\
\oooo Since $P'$ is a subset of $P$, $h_1 \in P$. So $h \in P * s$ \\
\oooo Therefore $C\;\mathit{Best}(\semfun{a}{Q(a) * s})\;h = \bot$ \\
\oooo For any $a$, we know that $Q(a) \subseteq Q'(a)$ \\
\oooo Hence  we know that $\mathit{Best}(\semfun{a}{Q'(a) * s}) \sqsupseteq \mathit{Best}(\semfun{a}{Q(a) * s})$ \\
\oooo Hence by continuity, $C\;\mathit{Best}(\semfun{a}{Q'(a) * s})\;h = \bot$ \\
\ooo Hence $\forall s \succeq r.\; \basicspec{P' * s}{C}{a:A}{Q'(a) * s}$ \\
\ooo Hence $\forall r.\; r \in \interp{\judgeS{\spec{p'}{c}{a:A}{q'}}}\;\theta\;\gamma\;\delta$ \\



\end{tabbedproof}
\end{proof}


\subsection{The Syntactic Frame Property}

We have defined a \emph{syntactic} frame operator $\Frame{S}{r}$ on
specifications.

\begin{displaymath}
  \begin{array}{lcl}
    \Frame{\spec{p}{c}{a:A}{q}}{r}    & = & \spec{p * r}{c}{a:A}{q * r} \\
    \Frame{\mspec{p}{c}{a:A}{q}}{r}   & = & \mspec{p * r}{c}{a:A}{q * r} \\
    \Frame{\setof{p}}{r}              & = & \setof{p} \\
    \Frame{(S_1 \specand S_2)}{r}      & = & \Frame{S_1}{r} \specand \Frame{S_2}{r} \\
    \Frame{(S_1 \specor S_2)}{r}       & = & \Frame{S_1}{r} \specor \Frame{S_2}{r} \\
    \Frame{(S_1 \specimp S_2)}{r}      & = & \Frame{S_1}{r} \specimp \Frame{S_2}{r} \\
    \Frame{(\forall x:\omega.\; S)}{r} & = & \forall x:\omega.\; (\Frame{S}{r}) \\
    \Frame{(\exists x:\omega.\; S)}{r} & = & \exists x:\omega.\; (\Frame{S}{r}) \\
  \end{array}
\end{displaymath}

\begin{prop*}{(Syntactic Well-Formedness of Frame Operator)}
If $\judgeS{S}$ and $\judgeA{p}{\assert}$, then
we define $\judgeS{\Frame{S}{p}}$.  
\end{prop*}
\begin{proof}
  By structural induction on specifications.
\end{proof}

More interesting than the syntactic well-formedness of the frame
operator is its semantic well-formedness. 

\begin{lemma*}{(Syntactic Framing is Semantic Framing)}
If $\judgeS{S}$ and $\judgeA{r}{\assert}$, then for all suitable $\theta, \gamma,$ and $\delta$, 
$\interp{\judgeS{\Frame{S}{r}}}\;\theta\;\gamma\;\delta = 
\Frame{\interp{\judgeS{S}}\;\theta\;\gamma\;\delta}{\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta}$ \\
\end{lemma*}

\begin{proof}
  This proof proceeds by induction on the derivation of $S$. 

  \begin{itemize}
  \item Case \textsc{SpecTriple}: 
    \begin{tabbedproof}
      \oo We know $\judgeS{\spec{p}{c}{a:A}{q}}$ \\
      \oo By the semantics of triples, we know that \\
      \ooo 
          $\interp{\judgeS{\spec{p}{c}{a:A}{q}}}\;\theta\;\gamma\;\delta = \spec{P}{C}{a}{Q(a)}$ \\ 
          % $\spec{p}[c}{a:A}{q}\;\delta = \spec{P}{C}{a}{Q(a)}$ \\
      \ox where \\
      \oox $P = \interp{\judgeA{p}{\assert}}\;\theta\;\gamma\;\delta$ \\
      \oox $C = \interp{\judgeC[\Theta]{\Gamma}{c}{A}}\;\theta\;\gamma$ \\
      \oox $Q = \semfun{v}{(\interp{\judgeA[\Theta; \Gamma, a:A; \Delta]{q}{\assert}}\;\theta\;(\gamma, v)\;\delta}$ \\
      \oo Now from the definition of syntactic framing, we know that $\Frame{S}{r} = \spec{p * r}{c}{a:A}{q(a) * r}$ \\
      \oo By semantics of triples, we know that \\
      \oox $\interp{\judgeS{\spec{p * r}{c}{a:A}{q * r}}}\;\theta\;\gamma\;\delta = \spec{P * R}{C}{a}{Q(a) * R}$ \\ 
      \ox where $R = \interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta$ \\
      \oo By lemma we know that $\spec{P * R}{C}{a}{Q(a) * R} = \Frame{\spec{P}{C}{a}{Q(a)}}{R}$ 
          semantically \\
      \oo Therefore $\interp{\judgeS{\Frame{\spec{p}{c}{a:A}{q}}{r}}}\;\theta\;\gamma\;\delta = $ \\
      \oox $\Frame{\interp{\judgeS{\spec{p}{c}{a:A}{q}}}\;\theta\;\gamma\;\delta}{(\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta)}$
    \end{tabbedproof}

  \item Case \textsc{SpecMTriple}
    \begin{tabbedproof}
      \oo We know $\judgeS{\mspec{p}{e}{a:A}{q}}$ \\
      \oo By the semantics of triples, we know that \\
      \oox  $\interp{\judgeS{\mspec{p}{e}{a:A}{q}}}\;\theta\;\gamma\;\delta = \mspec{P}{E}{a}{Q(a)}$ \\ 
      \ox where \\
      \oox $P = \interp{\judgeA{p}{\assert}}\;\theta\;\gamma\;\delta$ \\
      \oox $E = \interp{\judgeE[\Theta]{\Gamma}{e}{\monad{A}}}\;\theta\;\gamma$ \\
      \oox $Q = \semfun{v}{(\interp{\judgeA[\Theta; \Gamma, a:A; \Delta]{q}{\assert}}\;\theta\;(\gamma, v)\;\delta}$ \\
      \oo Now from the definition of syntactic framing, we know that $\Frame{S}{r} = \mspec{p * r}{e}{a:A}{q(a) * r}$ \\
      \oo By semantics of triples, we know that \\
      \oox $\interp{\judgeS{\mspec{p * r}{e}{a:A}{q * r}}}\;\theta\;\gamma\;\delta = \mspec{P * R}{e}{a}{Q(a) * R}$ \\ 
      \ox where $R = \interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta$ \\
      \oo By lemma we know that $\mspec{P * R}{E}{a}{Q(a) * R} = \Frame{\mspec{P}{E}{a}{Q(a)}}{R}$ 
          semantically \\
      \oo Therefore $\interp{\judgeS{\Frame{\mspec{p}{c}{a:A}{q}}{r}}}\;\theta\;\gamma\;\delta = $ \\
      \oox $\Frame{\interp{\judgeS{\mspec{p}{c}{a:A}{q}}}\;\theta\;\gamma\;\delta}{(\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta)}$
    \end{tabbedproof}

    \item Case \textsc{SpecAssert}
      \begin{tabbedproof}
        \oo We know $\judgeS{\setof{p}}$ \\
        \oo So we also know that $\Frame{\setof{p}}{r} = \setof{p}$ \\
        \oo Therefore, $\interp{\judgeS{\setof{p}}}\;\theta\;\gamma\;\delta$ is either $\top$ or $\bot$, \\
        \ox depending on
            whether $\interp{\judgeA{p}{\assert}}\;\theta\;\gamma\;\delta$ is $H$ or $\emptyset$ \\
        \oo Now, we will do a case analysis on the meaning of $\setof{p}$ \\
        \ooo If $\interp{\judgeS{\setof{p}}}\;\theta\;\gamma\;\delta = \top$ \\
        \oooo Then, since $S \subseteq \Frame{S}{R}$ for all $S$ and $R$, and $\top$ is maximal, we know that \\
        \oooox $\top = \Frame{\top}{(\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta)}$ \\
        \oooo So $\interp{\judgeS{\Frame{\setof{p}}{r}}}\;\theta\;\gamma\;\delta = $ \\
        \oooox $\Frame{\interp{\judgeS{\setof{p}}}\;\theta\;\gamma\;\delta}{(\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta)}$ \\
        \ooo If $\interp{\judgeS{\setof{p}}}\;\theta\;\gamma\;\delta = \bot$ \\
        \oooo Then, since $\bot$ is the empty set, and since $\Frame{S}{r} = \comprehend{p}{p * r \in S}$, \\
        \ooooo we know $\bot = \Frame{\bot}{\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta}$ \\
        \oooo  So we know $\interp{\judgeS{\Frame{\setof{p}}{r}}}\;\theta\;\gamma\;\delta = $ \\
        \oooox  $\Frame{\interp{\judgeS{\setof{p}}}\;\theta\;\gamma\;\delta}{(\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta)}$ \\
      \end{tabbedproof}

    \item Case \textsc{SpecBinary}
      \begin{tabbedproof}
        \oo We know $\judgeS{S_1 \otimes S_2}$, where $\oplus \in \setof{\specand, \specor, \specimp}$ \\
        \oo We also know that $\Frame{(S_1 \oplus S_2)}{r} = (\Frame{S_1}{r}) \oplus (\Frame{S_2}{r})$ \\
        \oo By the semantics, we know \\
        \oox $\interp{\judgeS{S_1 \oplus S_2}}\;\theta\;\gamma\;\delta $ \\
        \ooox $= \interp{\judgeS{S_1}}\;\theta\;\gamma\;\delta \;\interp{\oplus} \; \interp{\judgeS{S_2}}\;\theta\;\gamma\;\delta$ \\
        \oo By the semantics, we know that \\
        \oox $\interp{\judgeS{\Frame{(S_1 \oplus S_2)}{r}}}\;\theta\;\gamma\;\delta = $ \\
        \ooox $(\interp{\judgeS{\Frame{S_1}{r}}}\;\theta\;\gamma\;\delta) \interp{\oplus}
               (\interp{\judgeS{\Frame{S_2}{r}}}\;\theta\;\gamma\;\delta)$ \\
        \oo By induction, we know \\
        \oox $\interp{\judgeS{\Frame{S_1}{r}}}\;\theta\;\gamma\;\delta = 
                                   \Frame{\interp{\judgeS{S_1}}\;\theta\;\gamma\;\delta}{(\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta)}$ \\
        \oo By induction, we know \\
        \oox $\interp{\judgeS{\Frame{S_2}{r}}}\;\theta\;\gamma\;\delta = 
                                   \Frame{\interp{\judgeS{S_2}}\;\theta\;\gamma\;\delta}{(\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta)}$ \\

        \oo Therefore, we know $\interp{\judgeS{\Frame{(S_1 \oplus S_2)}{r}}}\;\theta\;\gamma\;\delta = $ \\
        \oox                   $(\Frame{\interp{\judgeS{S_1}}\;\theta\;\gamma\;\delta}{(\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta)})$ \\
        \oox $\interp{\oplus}$ \\
        \oox $(\Frame{\interp{\judgeS{S_2}}\;\theta\;\gamma\;\delta}{(\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta)})$ \\
        \oo Therefore we know $\interp{\judgeS{\Frame{(S_1 \oplus S_2)}{r}}}\;\theta\;\gamma\;\delta = $ \\
        \oox $\Frame{(\interp{\judgeS{S_1}}\;\theta\;\gamma\;\delta \;\interp{\oplus}\; \interp{\judgeS{S_2}}\;\theta\;\gamma\;\delta)}
                    {(\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta)}$ \\
        \oo Therefore we know $\interp{\judgeS{\Frame{(S_1 \oplus S_2)}{r}}}\;\theta\;\gamma\;\delta = $ \\
        \oox $\Frame{\interp{\judgeS{S_1 \oplus S_2}}\;\theta\;\gamma\;\delta}{(\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta)}$ \\
      \end{tabbedproof}

    \item Case \textsc{SpecQuantify1}:
      \begin{tabbedproof}
        \oo We know $\judgeS{Q u:\upsilon.\; S}$, where $Q \in \setof{\forall, \exists}$ \\
        \oo We also know that $\Frame{(Q u:\upsilon.\; S)}{r} = Q u:\upsilon.\; (\Frame{S}{r})$ \\
        \oo By the semantics, we know that $\interp{\judgeS{Q u:\upsilon.\; (\Frame{S}{r)}}}\;\theta\;\gamma\;\delta = $ \\
        \oox $\interp{Q}_{v \in \interp{\judgeSort{\upsilon}}\;\theta} \interp{\judgeS[\Theta; \Gamma; \Delta, u:\upsilon]{\Frame{S}{r}}}\;\theta\;\gamma\;(\delta, v)$\\
        \oo By induction, we know that for all appropriate $\theta\;\gamma\;\delta'$, 
               $\interp{\judgeS[\Theta; \Gamma; \Delta, u:\upsilon]{\Frame{S}{r}}}\;\theta\;\gamma\;\delta' = $ \\
        \oox $\Frame{\interp{\judgeS[\Theta; \Gamma; \Delta, u:\upsilon]{S}}\;\theta\;\gamma\;\delta'}{\interp{\judgeA[\Delta, u:\upsilon]{r}{\assert}}\;\theta\;\gamma\;\delta'}$ \\
        \oo Now, choosing $\theta, \gamma,$ and  $\delta' = (\delta,v)$, \\
        \oox then $\interp{\judgeA[\Theta;\Gamma;\Delta, u:\upsilon]{r}{\assert}}\;\theta\;\gamma\;\delta' = 
                                                   \interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta$ since $u \not\in \FV{r}$ \\
        \oo So we know $\interp{\judgeS{Q u:\upsilon.\; (\Frame{S}{r)}}}\;\theta\;\gamma\;\delta = $ \\
        \oox $\interp{Q}_{v \in \interp{\judgeSort{\upsilon}}\;\theta} (\Frame{\interp{\judgeS[\Theta;\Gamma;\Delta, u:\upsilon]{S}}\;\theta\;\gamma\;(\delta,v)}{\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta})$ \\
        \oo Since framing distributes through meets, we know $\interp{\judgeS{Q u:\upsilon.\; (\Frame{S}{r)}}}\;\theta\;\gamma\;\delta = $ \\
        \oox $\Frame{(\interp{Q}_{v \in \interp{\judgeSort{\upsilon}}\;\delta} \interp{\judgeS[\Theta; \Gamma; \Delta, u:\upsilon]{S}}\;\theta\;\gamma\;(\delta, v))}{(\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta)}$ \\
        \oo So we know $\interp{\judgeS{Q u:\upsilon.\; (\Frame{S}{r)}}}\;\theta\;\gamma\;\delta = $ \\
        \oox $\Frame{\interp{\judgeS{Q u:\upsilon.\;S}}\;\theta\;\gamma\;\delta}{(\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta)}$ \\
        \oo So we know $\interp{\judgeS{\Frame{(Q u:\upsilon.\; S)}{r}}}\;\theta\;\gamma\;\delta = $ \\
        \oox $\Frame{\interp{\judgeS{Q u:\upsilon.\;S}}\;\theta\;\gamma\;\delta}{(\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta)}$ \\        
      \end{tabbedproof}

    \item Case \textsc{SpecQuantify3}:
      \begin{tabbedproof}
        \oo We know $\judgeS{Q y:B.\; S}$, where $Q \in \setof{\forall, \exists}$ \\
        \oo We also know that $\Frame{(Q y:B.\; S)}{r} = Q y:B.\; (\Frame{S}{r})$ \\
        \oo By the semantics, we know that $\interp{\judgeS{Q y:B.\; (\Frame{S}{r)}}}\;\theta\;\gamma\;\delta = $ \\
        \oox $\interp{Q}_{v \in \interp{\judgeSort{B}}\;\theta} \interp{\judgeS[\Theta; \Gamma, y:B; \Delta]{\Frame{S}{r}}}\;\theta\;(\gamma, v)\;\delta$\\
        \oo By induction, we know that for all appropriate $\theta\;\gamma'\;\delta$, 
               $\interp{\judgeS[\Theta; \Gamma, y:B; \Delta]{\Frame{S}{r}}}\;\theta\;\gamma'\;\delta = $ \\
        \oox $\Frame{\interp{\judgeS[\Theta; \Gamma, y:B; \Delta]{S}}\;\theta\;\gamma'\;\delta}{\interp{\judgeA[\Delta, y:B]{r}{\assert}}\;\theta\;\gamma'\;\delta}$ \\
        \oo Now, choosing $\theta, \delta$ and $\gamma' = (\gamma, v)$, \\
        \oox then $\interp{\judgeA[\Theta;\Gamma;\Delta, y:B]{r}{\assert}}\;\theta\;\gamma'\;\delta = 
                                                   \interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta$ since $u \not\in \FV{r}$ \\
        \oo So we know $\interp{\judgeS{Q y:B.\; (\Frame{S}{r)}}}\;\theta\;\gamma\;\delta = $ \\
        \oox $\interp{Q}_{v \in \interp{\judgeSort{B}}\;\theta} (\Frame{\interp{\judgeS[\Theta;\Gamma;\Delta, y:B]{S}}\;\theta\;(\gamma, v)\;\theta\;\gamma\;\delta}{\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta})$ \\
        \oo Since framing distributes through meets, we know $\interp{\judgeS{Q y:B.\; (\Frame{S}{r)}}}\;\theta\;\gamma\;\delta = $ \\
        \oox $\Frame{(\interp{Q}_{v \in \interp{\judgeSort{B}}\;\delta} \interp{\judgeS[\Theta; \Gamma, y:B; \Delta]{S}}\;\theta\;(\gamma, v)\;\theta\;\gamma\;\delta)}{(\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta})$ \\
        \oo So we know $\interp{\judgeS{Q y:B.\; (\Frame{S}{r)}}}\;\theta\;\gamma\;\delta = $ \\
        \oox $\Frame{\interp{\judgeS{Q y:B.\;S}}\;\theta\;\gamma\;\delta}{(\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta)}$ \\
        \oo So we know $\interp{\judgeS{\Frame{(Q y:B.\; S)}{r}}}\;\theta\;\gamma\;\delta = $ \\
        \oox $\Frame{\interp{\judgeS{Q y:B.\;S}}\;\theta\;\gamma\;\delta}{(\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta)}$ \\        
      \end{tabbedproof}

    \item Case \textsc{SpecQuantify2}:
      \begin{tabbedproof}
        \oo We know $\judgeS{Q \alpha:\kappa.\; S}$, where $Q \in \setof{\forall, \exists}$ \\
        \oo We also know that $\Frame{(Q \alpha:\kappa.\; S)}{r} = Q \alpha:\kappa.\; (\Frame{S}{r})$ \\
        \oo By the semantics, we know that $\interp{\judgeS{Q \alpha:\kappa.\; (\Frame{S}{r)}}}\;\theta\;\gamma\;\delta = $ \\
        \oox $\interp{Q}_{\tau \in \interp{\judgeSort{\kappa}}\;\theta} \interp{\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{\Frame{S}{r}}}\;(\theta, \tau)\;\gamma\;\delta$\\
        \oo By induction, we know that for all appropriate $\theta'\;\gamma\;\delta$, 
               $\interp{\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{\Frame{S}{r}}}\;\theta\;\gamma\;\delta = $ \\
        \oox $\Frame{\interp{\judgeS[\Theta, \alpha:\kappa; \Gamma; \Delta]{S}}\;\theta\;\gamma\;\delta}{\interp{\judgeA[\Delta, \alpha:\kappa]{r}{\assert}}\;\theta\;\gamma\;\delta}$ \\
        \oo Now, choosing $\theta' = (\theta, \tau)$ and $\gamma, \delta$ \\
        \oox then $\interp{\judgeA[\Theta, \alpha:\kappa;\Gamma;\Delta]{r}{\assert}}\;\theta'\;\gamma\;\delta = 
                                                   \interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta$ since $\alpha \not\in \FV{r, \Gamma, \Delta}$ \\
        \oo So we know $\interp{\judgeS{Q \alpha:\kappa.\; (\Frame{S}{r)}}}\;\theta\;\gamma\;\delta = $ \\
        \oox $\interp{Q}_{\tau \in \interp{\judgeSort{\kappa}}\;\theta} (\Frame{\interp{\judgeS[\Theta;\Gamma;\Delta, \alpha:\kappa]{S}}\;(\theta, \tau)\;\gamma\;\delta}{\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta})$ \\
        \oo Since framing distributes through meets, we know $\interp{\judgeS{Q \alpha:\kappa.\; (\Frame{S}{r)}}}\;\theta\;\gamma\;\delta = $ \\
        \oox $\Frame{(\interp{Q}_{\tau \in \interp{\judgeSort{\kappa}}\;\theta} \interp{\judgeS[\Theta; \alpha:\kappa; \Gamma; \Delta]{S}}\;(\theta, \tau)\;\gamma\;\delta)}{\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta})$ \\
        \oo So we know $\interp{\judgeS{Q \alpha:\kappa.\; (\Frame{S}{r)}}}\;\theta\;\gamma\;\delta = $ \\
        \oox $\Frame{\interp{\judgeS{Q \alpha:\kappa.\;S}}\;\theta\;\gamma\;\delta}{(\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta)}$ \\
        \oo So we know $\interp{\judgeS{\Frame{(Q \alpha:\kappa.\; S)}{r}}}\;\theta\;\gamma\;\delta = $ \\
        \oox $\Frame{\interp{\judgeS{Q \alpha:\kappa.\;S}}\;\theta\;\gamma\;\delta}{(\interp{\judgeA{r}{\assert}}\;\theta\;\gamma\;\delta)}$ \\        
      \end{tabbedproof}
  \end{itemize}
\end{proof}




